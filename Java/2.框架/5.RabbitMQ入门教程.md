### 1.初识MQ

#### 1.1 同步和异步通讯

##### 1.1.1 同步通讯的优缺点

同步方式虽然调用可以实时得到结果，但却存在下面的问题：

![image-20211119223715893](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230426.png) 

**同步调用的优点：**

- 时效性较强，可以立即得到结果。

**同步调用的缺点：**

- 耦合度高；
- 性能和吞吐能力下降；
- 有额外的资源消耗；
- 有级联失败问题。

##### 1.1.2 异步通讯的优缺点

异步调用常见实现就是事件驱动模式，以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，需要调用物流服务，从仓库分配响应的库存并准备发货，以及调用短信服务通知支付结果。如下所示：

![image-20211119225121579](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230435.png) 

在事件模式中，支付服务是事件`发布者`(publisher)，在支付完成后只需要发布一个支付成功的`事件`(event)，事件中带上订单id。订单服务、物流服务以及短信服务都是事件`订阅者`(Consumer)，订阅支付成功的事件，监听到事件后完成自己业务即可。

为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是通过起到中间人角色的Broker。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。

![image-20211119225730288](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230442.png) 

Broker是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。

**异步调用的优点：**

- `吞吐量提升`：无需等待订阅者处理完成，响应更快速；
- `故障隔离`：服务没有直接调用，不存在级联失败问题；
- `调用无阻塞`：调用间没有阻塞，不会造成无效的资源占用；
- `低耦合`：耦合度极低，每个服务都可以灵活插拔，可替换；
- `流量削峰`：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件。

**异步调用的缺点：**

- 架构复杂了，业务没有明显的流程线，不好管理；
- 需要依赖于Broker的可靠性、安全性以及性能。

> **说明**：开源软件或云平台上Broker的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。

#### 1.2 常见的MQ技术对比

MQ(MessageQueue)，中文是消息队列，字面来看就是存放消息的队列，也就是事件驱动架构中的Broker。

几种常见MQ的对比如下：

![image-20211119231325786](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119231821.png) 

结论如下：

- `追求可用性`：Kafka、RocketMQ、RabbitMQ
- `追求可靠性`：RabbitMQ、RocketMQ
- `追求吞吐能力`：RocketMQ、Kafka
- `追求消息低延迟`：RabbitMQ、Kafka

### 2.RabbitMQ入门

#### 2.1 RabbitMQ概述

[RabbitMQ](https://www.rabbitmq.com/)是基于Erlang语言开发的开源消息通信中间件，它的基本结构如下所示：

![image-20211119232135006](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119232543.png) 

RabbitMQ中的一些角色：

- `publisher`：生产者；
- `consumer`：消费者；
- `exchange`：交换机，负责消息路由；
- `queue`：队列，存储消息；
- `virtualHost`：虚拟主机，隔离不同租户的exchange、queue以及消息的隔离。

#### 2.2 RabbitMQ的安装

##### 2.2.1 普通方式安装

1. 首先我们从github上下载[rabbitmq安装包](https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm)以及它依赖的[erlang环境包](https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.7/erlang-21.3.7-1.el7.x86_64.rpm)，如果网速不好，也可以使用以下备用下载地址进行下载：

   ```bash
   # 下载rabbitmq-server-3.8.8-1.el7.noarch.rpm
   https://gongsl.lanzoui.com/ioQACwoi41e
   
   # 下载erlang-21.3.7-1.el7.x86_64.rpm
   https://gongsl.lanzoui.com/igGtzwoi3yb
   ```

2. 将下载的包传到linux主机上后就可以进行安装了：

   ```bash
   # 首先安装一个erlang的依赖
   yum install -y socat
   
   # 然后使用rpm命令安装erlang环境
   rpm -ivh erlang-21.3.7-1.el7.x86_64.rpm
   
   # 最后安装rabbitmq
   rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm
   ```

3. 下载完成之后，直接启动即可：

   ```bash
   systemctl start rabbitmq-server
   ```

4. rabbitmq启动成功之后，我们需要安装一个web管理插件，以便能够访问rabbitmq控制台：

   ```bash
   rabbitmq-plugins enable rabbitmq_management
   ```

   ![image-20211120005231454](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120011849.png) 

5. 然后需要添加一个用户，方便登录控制台：

   ```bash
   # 创建用户，用户名是admin，密码是123
   rabbitmqctl add_user admin 123
   
   # 设置用户角色
   rabbitmqctl set_user_tags admin administrator
   
   # 设置用户在"/"这个虚拟主机下的所有权限
   rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"
   
   # 然后我们也可以通过以下命令查看用户
   rabbitmqctl list_users
   ```

6. 最后使用创建好的用户名密码登录控制台即可，地址就是我们主机的地址，端口是`15672`，比如下面这样：

   ```http
   http://192.168.68.11:15672/
   ```

   ![image-20211120011600590](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120011854.png) 

##### 2.2.2 docker方式安装

1. 下载镜像文件：

   ```bash
   # 我这边直接下载目前最新镜像
   docker pull rabbitmq:3.9.9-management
   ```

2. 直接使用`docker run`命令运行MQ容器：

   ```bash
   # 运行容器时创建一个用户，用户名密码都是admin，下面的15672是控制台端口，5672是消息通信的端口
   docker run \
    -e RABBITMQ_DEFAULT_USER=admin \
    -e RABBITMQ_DEFAULT_PASS=admin \
    --name mq \
    --hostname rabbitmq \
    -p 15672:15672 \
    -p 5672:5672 \
    -d \
    rabbitmq:3.9.9-management
   
   # 容器创建成功后我们也可以使用如下命令进行查看
   docker ps
   ```

   > **说明**：我们不手动创建用户也可以，也会自动创建一个用户，用户名密码都是guest。

3. 浏览器直接输入RabbitMQ所在主机地址和`15672`端口即可访问RabbitMQ的控制台，如下所示：

   ```http
   http://192.168.68.11:15672/
   ```

   ![image-20211120112935388](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120113033.png) 

##### 2.2.3 k8s方式部署RabbitMQ集群

**说明**：这里安装所涉及到的yaml文件均来自github上rabbitmq官方的[diy-kubernetes-examples](https://github.com/rabbitmq/diy-kubernetes-examples/tree/master/minikube)项目。这种方式的安装属于迷你版的，像存储之类的东西都没有配置，所以只建议学习使用，不建议用于生产环境。

1. 依次执行以下命令进行集群部署：

   ```bash
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/namespace.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/configmap.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/rbac.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/services.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/sts.yaml
   ```

2. 然后使用如下命令查看部署情况：

   ```bash
   kubectl get svc,po -n test-rabbitmq -o wide
   ```

   ![image-20211120124327956](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125220.png) 

3. 由以上截图可知，控制台的`15672`端口映射到主机的端口是`31672`，所以浏览器随便使用一个集群中主机的地址加上这个端口号即可访问控制台，默认用户名密码都是guest，如下所示：

   ```http
   http://192.168.68.20:31672/
   ```

   ![image-20211120124709159](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125225.png) 

   > **说明**：控制台的`Nodes`栏也可以看到我们部署的RabbitMQ中的三个节点信息。

4. 我们也可以使用`kubectl logs rabbitmq-0 -n test-rabbitmq`命令查看Pod的日志，通过日志可以发现，部署好的Pod会自动加入到MQ集群中。

   ![image-20211120125737867](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125747.png) 

#### 2.3 RabbitMQ消息模型

在RabbitMQ官网上介绍的[消息模型](https://www.rabbitmq.com/getstarted.html)总共有七种，但是其实最常用的只有前五种，如下所示：

![image-20211122122415988](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123313.png) 

- 第一种属于基本消息队列(BasicQueue)，如下图：

  ![image-20211122122656579](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123321.png) 

- 第二种属于工作消息队列(WorkQueue)，如下图：

  ![image-20211122122754441](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123325.png) 

- 第三种是发布、订阅的广播(Fanout)模式，如下图：

  ![image-20211122122954906](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123329.png) 

- 第四种是发布、订阅的路由(Direct)模式，如下图：

  ![image-20211122123033157](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123334.png) 

- 第五种是发布、订阅的主题(Topic)模式，如下图：

  ![image-20211122123106982](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123339.png) 

### 3.RabbitMQ入门案例

官方的HelloWorld案例是基于最基础的消息队列模型来实现的，只包括三个角色：

- `publisher`：消息发布者，将消息发送到队列queue；
- `queue`：消息队列，负责接受并缓存消息；
- `consumer`：订阅队列，处理队列中的消息。

![image-20211122141448984](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122152945.png) 

首先在IDEA中导入[rabbitmq-demo](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122152945.png)工程，该工程下包含publisher和consumer这两个子工程，其中publisher工程用于发布消息，consumer工程用于消费消息。

publisher工程中的用于发布消息的PublisherTest类内容如下：

```java
package com.mq.demo.test;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class PublisherTest {

    public static void main(String args[]) throws IOException, TimeoutException {
        // 1.建立连接
        ConnectionFactory factory = new ConnectionFactory();
        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
        factory.setHost("192.168.68.11"); //需要改成自己的MQ所在主机的地址
        factory.setPort(5672);
        factory.setVirtualHost("/");
        factory.setUsername("admin");
        factory.setPassword("admin");
        // 1.2.建立连接
        Connection connection = factory.newConnection();

        // 2.创建通道Channel
        Channel channel = connection.createChannel();

        // 3.创建队列
        String queueName = "simple.queue";
        channel.queueDeclare(queueName, false, false, false, null);

        // 4.发送消息
        String message = "hello, rabbitmq!";
        channel.basicPublish("", queueName, null, message.getBytes());
        System.out.println("发送消息成功：【" + message + "】");

        // 5.关闭通道和连接
        channel.close();
        connection.close();

    }
}
```

consumer工程中的用于消费消息的ConsumerTest类内容如下：

```java
package com.mq.demo.test;

import com.rabbitmq.client.*;
import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class ConsumerTest {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 1.建立连接
        ConnectionFactory factory = new ConnectionFactory();
        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
        factory.setHost("192.168.68.11");
        factory.setPort(5672);
        factory.setVirtualHost("/");
        factory.setUsername("admin");
        factory.setPassword("admin");
        // 1.2.建立连接
        Connection connection = factory.newConnection();

        // 2.创建通道Channel
        Channel channel = connection.createChannel();

        // 3.创建队列
        String queueName = "simple.queue";
        channel.queueDeclare(queueName, false, false, false, null);

        // 4.订阅消息
        channel.basicConsume(queueName, true, new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body) {
                // 5.处理消息
                String message = new String(body);
                String threadName = Thread.currentThread().getName();
                System.out.println("["+threadName+"]线程接收到消息：【" + message + "】");
            }
        });
        System.out.println("["+Thread.currentThread().getName()+"]线程等待接收消息。。。。");
    }
}
```

我们先运行`PublisherTest`类，运行成功后，我们到RabbitMQ控制台进行查看，可以发现在`队列`菜单栏下多出一个队列，名称就是我们在代码中命名的队列名：

![image-20211122173313570](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190544.png) 

点击队列名后，可以在`Get messages`下面查看到我们发布的消息的具体内容：

![image-20211122173648218](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190552.png) 

然后我们再运行`ConsumerTest`类，运行成功后，队列里的消息就被消费调了，然后控制台会打印如下内容：

![image-20211122173921541](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190604.png) 

> **说明**：我在代码中把当前线程的线程名打印出来了，通过以上截图也可以发现，RabbitMQ在消费消息的时候和发送消息一样都是通过异步的方式，都不会阻塞主线程。

### 4.整合SpringBoot

#### 4.1 什么是SpringAMQP

MQ和SpringBoot的整合主要依靠于SpringAMQP，关于[SpringAMQP](https://spring.io/projects/spring-amqp)的介绍如下：

![image-20211122191637494](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122191650.png) 

#### 4.2 演示基本消息队列

在RabbitMQ入门案例中，我们使用的**rabbitmq-demo**工程就是一个SpringBoot工程，所以这里就还使用这个工程。在整合SpringBoot时，给RabbitMQ发送消息，可以使用spring-rabbit提供的`RabbitTemplate`类。

1. 由于rabbitmq-demo工程中的两个子工程都需要用到AMQP相关的依赖，所以我们就直接在父工程的pom文件中引入相关依赖：

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   ```

2. 编写publisher服务的application.yml文件，添加MQ的连接信息：

   ```yaml
   spring:
     rabbitmq:
       host: 192.168.68.11 # MQ所在主机的IP地址
       port: 5672 # 端口
       virtual-host: / # 虚拟主机
       username: admin #用户名
       password: admin # 密码
   ```

3. 在publisher服务中新建一个测试类，并编写测试方法：

   ```java
   package com.mq.demo;
   
   import org.junit.Test;
   import org.junit.runner.RunWith;
   import org.springframework.amqp.rabbit.core.RabbitTemplate;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.test.context.junit4.SpringRunner;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-22 19:48
    */
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class SpringAmqpTest {
   
       @Autowired
       private RabbitTemplate rabbitTemplate;
   
       @Test
       public void testSimpleQueue() {
           //队列的名称
           String queueName = "simple.queue";
           //消息的内容
           String message = "hello, spring amqp!";
           rabbitTemplate.convertAndSend(queueName, message);
       }
   }
   ```

4. 启动测试，进行消息的发布，然后到控制台可以看到确实有一条待消费的消息存在：

   ![image-20211123112617061](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211123115519.png) 

   点击队列名称进去查看消息内容，发现确实是我们代码中设置的内容：

   ![image-20211123112745914](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211123115526.png) 

   > **注意**：使用`rabbitTemplate.convertAndSend()`发送消息的时候，如果队列已存在，消息可以发送成功；但是如果队列不存在，虽然代码执行不会报错，但是也不会自动创建队列，那么这个消息其实就算丢失了。

5. 接下来在consumer服务的application.yml中也配置MQ的连接信息：

   ```yaml
   spring:
     rabbitmq:
       host: 192.168.68.11 # MQ所在主机的IP地址
       port: 5672 # 端口
       virtual-host: / # 虚拟主机
       username: admin #用户名
       password: admin # 密码
   ```

6. 然后在consumer服务中新建一个消费消息的类，在类中定义一个使用`@RabbitListener`注解的方法，用于接收指定队列传过来的消息，并做相应处理：

   ```java
   package com.mq.demo.listener;
   
   import org.springframework.amqp.rabbit.annotation.RabbitListener;
   import org.springframework.stereotype.Component;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-23 16:33
    */
   @Component
   public class SpringRabbitListener {
   
       @RabbitListener(queues = "simple.queue")
       public void listenSimpleQueueMessage(String msg){
           System.out.println("消费者接收到消息：【" + msg + "】");
       }
   }
   ```

7. 之后我们直接运行consumer服务的启动类`ConsumerApplication`即可，可以看到控制台打印如下，说明我们发送的消息确实已经被消费了：

   ![image-20211123164227922](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151739.png) 

   然后在RabbitMQ管理控制台上也可以看到消息已经没有了：

   ![image-20211123164327848](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151745.png) 

   > **注意**：消息一旦被消费就会从队列中删除，而且RabbitMQ是没有消息回溯功能的。

#### 4.3 演示工作消息队列

工作消息队列和基本消息队列相比，最大的区别就是它有多个消费者，好处是可以提高消息处理速度，避免队列消息堆积。

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151750.png" alt="image-20211123170532794" style="zoom: 70%;" /> 

下面会沿用以上基本消息队列中用到的类，并在其中新增一些方式来演示工作消息队列：

1. 在publisher服务的`SpringAmqpTest`类中新增如下内容，然后运行该方法发布消息：

   ```java
   @Test
   public void testWorkQueue() throws InterruptedException {
       String queueName = "simple.queue";
       String message = ">>>hello, message-";
       for (int i = 1; i <= 50; i++) {
           //发消息
           rabbitTemplate.convertAndSend(queueName, message + i);
           //避免发送太快，让这50个消息在一秒钟内发完
           Thread.sleep(20);
       }
   }
   ```

2. 之后修改consumer服务的`SpringRabbitListener`类，将之前的listenSimpleQueueMessage方法暂时先注释掉，然后新增两个消费同一队列中消息的方法，最终内容如下：

   ```java
   package com.mq.demo.listener;
   
   import org.springframework.amqp.rabbit.annotation.RabbitListener;
   import org.springframework.stereotype.Component;
   import java.time.LocalTime;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-23 16:33
    */
   @Component
   public class SpringRabbitListener {
   
       /*@RabbitListener(queues = "simple.queue")
       public void listenSimpleQueueMessage(String msg){
           System.out.println("消费者接收到消息：【" + msg + "】");
       }*/
   
       @RabbitListener(queues = "simple.queue")
       public void listenWorkQueueMessage1(String msg) throws InterruptedException {
           System.out.println("消费者1接收到消息：【" + msg + "】--->" + LocalTime.now());
           Thread.sleep(25);
       }
   
       @RabbitListener(queues = "simple.queue")
       public void listenWorkQueueMessage2(String msg) throws InterruptedException {
           System.err.println("消费者2接收到消息：【" + msg + "】--->" + LocalTime.now());
           Thread.sleep(100);
       }
   }
   ```

3. 通过以上代码可知，消费者1每秒可以消费40个消息，消费者2每秒可以消费10个消息，两个消费者同时进行消费，按理说一秒内就能将我们发布的50个消息消费掉才对，但是运行consumer服务后控制台打印是这样的：

   ![image-20211123211721368](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151758.png) 

   ![image-20211123212431902](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151803.png) 

   > **说明**：从整个结果看，两个消费者消费50个消息，总共用了两秒多，比预期的时间慢了一倍。而且我们设置的消费者1的消费速度是更快的，按理说应该能者多劳，让消费者1消费更多消息的，但是从控制台打印结果看，并不是谁消费能力强谁就消费的多，反而是50个消息两个消费者对半分，一个消费者消费25个消息。

4. 出现以上结果的原因是受RabbitMQ内部的消费预取机制影响，这种机制就是不管处理的快不快，消费者都会先把消息拿过来再说，再慢慢处理。这样的话，就算消费者1早就已经消费完预取的消息啦，也没法继续处理剩下的消息了，因为剩下的消息已经被消费者2预取了。我们可以通过在consumer服务的application.yml文件中设置prefetch的值来控制预取消息的上限，如下所示：

   ```yaml
   spring:
     rabbitmq:
       listener:
         simple:
           prefetch: 1 # 每次只能获取一条消息，处理完成后才能获取下一个消息
   ```

5. 设置完成之后重启consumer服务，然后我们再发布50条消息，观察控制台打印结果：

   ![image-20211124112228446](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151810.png) 

   ![image-20211124112948490](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151815.png) 

#### 4.4 演示发布订阅队列

发布订阅模式与前面案例的区别就是允许将同一消息发送给多个消费者，实现方式是加入了exchange(交换机)。

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124155306.png" alt="image-20211124153125427" style="zoom:67%;" /> 

常见的exchange类型包括：

- `Fanout`：广播；
- `Direct`：路由；
- `Topic`：话题。

> **注意**：exchange是负责消息路由的，而不是存储，所以路由失败消息就会丢失。

##### 4.4.1 发布订阅-Fanout Exchange

`Fanout Exchange`会将接收到的消息广播到每一个跟其绑定的队列，如下所示：

![image-20211124155244716](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124155315.png) 

下面利用SpringAMQP演示Fanout Exchange的使用，具体思路如下：

- 在consumer服务中，利用代码声明Exchange、Queue，并将两者进行绑定；
- 在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2这两个队列；
- 在publisher服务中编写测试方法，向名为test.fanout的交换机发送消息。

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124160535.png" alt="image-20211124155721709" style="zoom:67%;" /> 

SpringAMQP是提供了声明交换机、队列、绑定关系的API的，如下所示：

![image-20211124160637947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165455.png) 

下面就演示下Fanout Exchange的使用，具体实现步骤如下所示：

1. 在consumer服务中增加一个配置类，并在该类中声明FanoutExchange、Queue和绑定关系对象Binding，具体内容如下所示：

   ```java
   package com.mq.demo.config;
   
   import org.springframework.amqp.core.Binding;
   import org.springframework.amqp.core.BindingBuilder;
   import org.springframework.amqp.core.FanoutExchange;
   import org.springframework.amqp.core.Queue;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-24 16:12
    */
   @Configuration
   public class FanoutConfig {
   
       //声明FanoutExchange交换机
       @Bean
       public FanoutExchange fanoutExchange(){
           return new FanoutExchange("test.fanout");
       }
   
       //声明第一个队列
       @Bean
       public Queue fanoutQueue1(){
           return new Queue("fanout.queue1");
       }
   
       //将队列1和交换机绑定起来
       @Bean
       public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){
           return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
       }
   
       //声明第二个队列
       @Bean
       public Queue fanoutQueue2(){
           return new Queue("fanout.queue2");
       }
   
       //将队列2和交换机绑定起来
       @Bean
       public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){
           return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);
       }
   }
   ```

2. 然后我们在consumer服务的`SpringRabbitListener`类中再添加两个方法，分别用于监听上一步声明的两个队列：

   ```java
   @RabbitListener(queues = "fanout.queue1")
   public void listenFanoutQueue1(String msg) {
       System.out.println("消费者1接收到fanout消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(queues = "fanout.queue2")
   public void listenFanoutQueue2(String msg) {
       System.out.println("消费者2接收到fanout消息：【" + msg + "】--->" + LocalTime.now());
   }
   ```

3. 之后在publisher服务的`SpringAmqpTest`类中添加测试方法，用于发布消息：

   ```java
   @Test
   public void testFanoutQueue() {
       //交换机名称
       String exchangeName = "test.fanout";
       //消息
       String message = "hello, everyone!";
       //发送消息，入参分别是交换机名称、routingKey(暂时为空)、消息
       rabbitTemplate.convertAndSend(exchangeName,"",message);
   }
   ```

4. 代码编写完成之后，启动consumer服务，然后在RabbitMQ的控制台可以看到在代码中创建的两个队列，而且也多了一个交换机，点击我们新增的那个交换机后，可以看到绑定的正是我们新增的那两个队列：

   ![image-20211124164547672](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165508.png) 

   ![image-20211124164716274](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165515.png) 

   点击名为`test.fanout`的交换机后，可以查看和队列的绑定关系：

   ![image-20211124165300396](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165520.png) 

5. 接下来运行publisher服务中SpringAmqpTest类里面的testFanoutQueue方法发送消息，通过consumer服务控制台的打印结果可知，发送的一条消息同时被多个消费者进行了消费：

   ![image-20211124165927021](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124170009.png) 

> **说明**：通过以上演示结果可知，Fanout Exchange确实会将消息路由到每个绑定的队列上，然后每个队列对应的消费者再从队列中获取消息进行消费。

##### 4.4.2 发布订阅-Direct Exchange

`Direct Exchange`会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式：

- 每一个Queue都与Exchange设置一个BindingKey；
- 发布者发送消息时，可以指定消息的RoutingKey进行发布；
- Exchange会将消息路由到BindingKey与消息的RoutingKey一致的队列。

如下图所示，RoutingKey的值如果为`blue`的话，消息会被路由到queue1队列，然后被该队列下的消费者消费；如果值为`yellow`的话，消息就会被路由到queue2队列，并被该队列下的消费者消费；如果值为`red`的话，那么消息就会被分别路由到queue1队列和queue2队列，并被它们各自的消费者消费：

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124174207.png" alt="image-20211124173747573" style="zoom: 60%;" /> 

下面利用SpringAMQP演示Direct Exchange的使用，具体思路如下：

- 利用@RabbitListener声明Exchange、Queue、RoutingKey；
- 在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2这两个队列；
- 在publisher服务中编写测试方法，向名为test.direct的交换机发送消息。

![image-20211124174626092](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124174700.png) 

> **说明**：前面在演示Fanout Exchange的时候，Exchange、Queue等都是通过`@Bean`注解声明的，这种方式太过于麻烦了，所以这里就直接通过配置`@RabbitListener`注解中的相关参数来进行声明。

下面就演示下Direct Exchange的使用，具体实现步骤如下所示：

1. 在consumer服务的`SpringRabbitListener`类中，编写两个消费者方法，使用`@RabbitListener`注解分别配置监听的队列，并通过该注解的其余参数声明Exchange以及RoutingKey，具体内容如下：

   ```java
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "direct.queue1"),
           exchange = @Exchange(name = "test.direct",type = ExchangeTypes.DIRECT),
           key = {"red", "blue"}
   ))
   public void listenDirectQueue1(String msg) {
       System.out.println("消费者1接收到direct消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "direct.queue2"),
           exchange = @Exchange(name = "test.direct",type = ExchangeTypes.DIRECT),
           key = {"red", "yellow"}
   ))
   public void listenDirectQueue2(String msg) {
       System.out.println("消费者2接收到direct消息：【" + msg + "】--->" + LocalTime.now());
   }
   ```

   > **说明**：在以上`@RabbitListener`注解中，`@QueueBinding`注解的exchange属性是用来绑定交换机的，并且可以通过`@Exchange`注解的type属性声明交换机的类型(默认类型就是**direct**)，然后@QueueBinding注解的另一个key属性就是用来指定**bindingKey**的，支持指定多个。

2. 然后在publisher服务的SpringAmqpTest类中添加一个发布消息的测试方法：

   ```java
   @Test
   public void testDirectQueue() {
       //交换机名称
       String exchangeName = "test.direct";
       String routingKey = "blue";
       //消息
       String message = "hello, blue!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

   > **说明**：这里将routingKey的值设置为`blue`，所以消息只会路由到queue1队列。

3. 启动consumer服务后，RabbitMQ的控制台就会多出direct.queue1和direct.queue2这两个队列，同时也会多出一个名为test.direct的交换机，点击进去后，可以查看交换机和队列的绑定关系：

   ![image-20211124182756184](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184709.png) 

4. 然后我们运行publisher服务中SpringAmqpTest类的testDirectQueue方法发布消息，观察consumer服务控制台的打印结果：

   ![image-20211124183025301](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184718.png) 

   > **说明**：由于direct.queue1队列与交换机的bindingKey中包含`blue`这个值，而发布消息时routingKey的值就设置的是`blue`，所以消息就只路由到了direct.queue1队列，并被该队列下的消费者消费。

5. 我们将publisher服务的SpringAmqpTest类中的testDirectQueue方法改成下面这样，再重新发布消息：

   ```java
   @Test
   public void testDirectQueue() {
       //交换机名称
       String exchangeName = "test.direct";
       String routingKey = "yellow";
       //消息
       String message = "hello, yellow!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

   通过consumer服务的控制台打印可以发现，由于只有direct.queue2队列与交换机的bindingKey中包含`yellow`这个值，所以消息就只路由到了direct.queue2队列，并被该队列下的消费者消费：

   ![image-20211124183553931](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184724.png) 

6. 如果我们将publisher服务的SpringAmqpTest类中的testDirectQueue方法改成下面这样：

   ```java
   @Test
   public void testDirectQueue() {
       //交换机名称
       String exchangeName = "test.direct";
       String routingKey = "red";
       //消息
       String message = "hello, red!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

   由于两个队列与交换机的bindingKey中都包含`red`这个值，所以当routingKey的值设置为`red`时，两个队列都是会收到路由过来的消息的，所以consumer服务的控制台打印如下：

   ![image-20211124184143616](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184729.png) 

> **说明**：在`Direct Exchange`这种模式中，如果所有与交换机绑定的队列的bindingKey里面都包含发布消息时设置的routingKey的值，那么这种模式就和`Fanout Exchange`模式功能是一样的啦。

##### 4.4.3 发布订阅-Topic Exchange

`Topic Exchange`与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以==.==分割。

Queue与Exchange指定BindingKey时也可以使用通配符：

- `#`：代指零个或多个单词；
- `*`：代指一个单词。

下面利用SpringAMQP演示Topic Exchange的使用，具体思路如下：

- 利用@RabbitListener声明Exchange、Queue、RoutingKey；
- 在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2这两个队列；
- 在publisher服务中编写测试方法，向名为test.topic的交换机发送消息。

![image-20211124210649082](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124212943.png) 

下面就演示下Topic Exchange的使用，具体实现步骤如下所示：

1. 在consumer服务的`SpringRabbitListener`类中，编写两个消费者方法，使用`@RabbitListener`注解分别配置监听的队列，并通过该注解的其余参数声明Exchange以及RoutingKey，具体内容如下：

   ```java
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "topic.queue1"),
           exchange = @Exchange(name = "test.topic",type = ExchangeTypes.TOPIC),
           key = "china.#"
   ))
   public void listenTopicQueue1(String msg) {
       System.out.println("消费者1接收到topic消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "topic.queue2"),
           exchange = @Exchange(name = "test.topic",type = ExchangeTypes.TOPIC),
           key = "#.news"
   ))
   public void listenTopicQueue2(String msg) {
       System.out.println("消费者2接收到topic消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "topic.queue3"),
           exchange = @Exchange(name = "test.topic",type = ExchangeTypes.TOPIC),
           key = "china.*"
   ))
   public void listenTopicQueue3(String msg) {
       System.out.println("消费者3接收到topic消息：【" + msg + "】--->" + LocalTime.now());
   }
   ```

2. 然后在publisher服务的SpringAmqpTest类中添加一个发布消息的测试方法：

   ```java
   @Test
   public void testTopicQueue() {
       //交换机名称
       String exchangeName = "test.topic";
       String routingKey = "china.news";
       //消息
       String message = "hello, topic!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

3. 启动consumer服务后，RabbitMQ的控制台就会多出topic相关的三个队列，同时也会多出一个名为test.topic的交换机，点击进去后，可以查看交换机和队列的绑定关系：

   ![image-20211124211227751](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124212959.png) 

4. 然后我们运行publisher服务中SpringAmqpTest类的testTopicQueue方法发布消息，观察consumer服务控制台的打印结果：

   ![image-20211124211340666](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124213008.png) 

   > **说明**：由于三个队列在和交换机绑定的时候，bindingKey中的通配符都可以匹配到RoutingKey的值，所以消息就都路由到这三个队列中了，所以它们对应的消费者就都消费消息了。

5. 如果我们将SpringAmqpTest类中testTopicQueue方法的routingKey的值改成`china.other`的话，那么当重新发布消息后，由于`topic.queue2`队列的bindingKey中的通配符匹配不到routingKey，所以不会向该队列路由消息，该队列的消费者也就无法消费消息，所以consumer服务的控制台打印如下：

   ![image-20211124212235957](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124213013.png) 

   如果我们把routingKey的值改成`china.today.news`的话，由于`topic.queue3`队列的bindingKey中的通配符使用的是`*`，所以只能匹配一个单词，如果routingKey的值是china.today的话还可以匹配到，但多个news就匹配不到了，所以不会向该队列路由消息，该队列的消费者也就无法消费消息，所以consumer服务的控制台打印如下：

   ![image-20211124212931103](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124213018.png) 

#### 4.5 发送Object类型的消息

在前面演示发布消息的时候，都是使用的字符串类型的消息，所以并不知道如果消息是一个Object对象的话会怎么样，这里就以Map集合为例：

在publisher服务的SpringAmqpTest类中新增一个测试方法：

```java
@Test
public void testObjectQueue() {
    //这里就直接使用演示基础消息队列时创建的队列
    String queueName = "simple.queue";
    Map<String, Object> msg = new HashMap<>();
    msg.put("name", "张三");
    msg.put("age", 20);
    rabbitTemplate.convertAndSend(queueName, msg);
}
```

直接运行testObjectQueue方法发布消息，然后到RabbitMQ控制台查看消息内容：

![image-20211124215449900](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211125000222.png) 

> **说明**：可以发现，Object类型的消息被序列化了。Spring对消息对象的处理是由`MessageConverter`来处理的。而默认实现是`SimpleMessageConverter`，基于JDK的ObjectOutputStream完成序列化使用的是java里面的序列化方式，这种方式我们是不推荐使用的，推荐用JSON方式序列化。

下面就演示使用JSON方式序列化的相关操作步骤：

1. 我们在父工程的pom文件中增加以下依赖：

   ```xml
   <dependency>
       <groupId>com.fasterxml.jackson.core</groupId>
       <artifactId>jackson-databind</artifactId>
   </dependency>
   ```

   在父工程添加的依赖，如果子工程引用不到的话，可以在子工程的`<parent>`标签中添加`<relativePath/>`解决，类似下面这样：

   ```xml
   <parent>
       <artifactId>rabbitmq-demo</artifactId>
       <groupId>com.mq.demo</groupId>
       <version>1.0-SNAPSHOT</version>
       <relativePath/>
   </parent>
   ```

2. 在publisher服务中新增一个配置类，然后在该类中修改序列化方式为JSON方式：

   ```java
   package com.mq.demo.config;
   
   import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
   import org.springframework.amqp.support.converter.MessageConverter;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-24 22:05
    */
   @Configuration
   public class ObjectConfig {
   
       @Bean
       public MessageConverter jsonMessageConverter(){
           return new Jackson2JsonMessageConverter();
       }
   }
   ```

3. 重新运行SpringAmqpTest类中的testObjectQueue方法，然后到RabbitMQ控制台查看消息内容：

   ![image-20211124234101172](D:\Program Files (x86)\Typora\images\5.RabbitMQ入门教程\image-20211124234101172.png) 

   > **说明**：可以发现，消息已经使用JSON方式进行展示了，并且content_type也变成了`application/json`。

4. 由于我们发布的消息已经转换成json串了，所以在consumer服务中接收消息时，就还是按照字符串接收就行。比如我们在SpringRabbitListener类中增加以下内容：

   ```java
   @RabbitListener(queues = "simple.queue")
   public void listenObjectQueueMessage(String msg) {
       System.out.println("消费者接收到object消息：" + msg);
   }
   ```

5. 当consumer服务启动后，就可以接收到消息了，控制台打印内容如下：

   ![image-20211125000121112](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211125000311.png) 

   > **说明**：如果在consumer服务中消费消息时，我们希望接收到的消息不是json串，而是转成json前的map集合的话，那就需要再转回来。首先需要像publisher服务中那样在配置类中修改序列化方式为JSON方式，然后再修改SpringRabbitListener类中listenObjectQueueMessage方法的入参为`Map<String,Object>`即可。

### 5.

















































