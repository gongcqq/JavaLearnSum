### 1.在CentOS上安装docker

如果之前安装过旧版本的docker，记得要先卸载，命令如下：

```bash
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```

#### 1.1 设置yum源

安装`yum-utils`软件包(提供`yum-config-manager`程序)并设置yum源为阿里云以便方便下载Docker Engine：

```bash
#安装yum-utils
sudo yum install -y yum-utils

#设置yum源为阿里云
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

#### 1.2 Docker的安装

安装最新版的Docker Engine和容器：

```bash
sudo yum install docker-ce docker-ce-cli containerd.io
```

安装时如果提示接受GPG密钥，请验证指纹是否匹配`060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`，如果匹配，继续安装即可。这个是用于检测安装包是否被篡改的，没有被篡改的话就说明我们安装的是安全的。

![image-20210215122150780](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210215122707.png) 

#### 1.3 Docker的启动与停止

```bash
#启动docker
sudo systemctl start docker

#停止docker
sudo systemctl stop docker

#重启docker
sudo systemctl restart docker

#设置开机启动
sudo systemctl enable docker

#查看docker状态
sudo systemctl status docker

#查看docker内容器的运行状态
sudo docker stats

#查看docker概要信息
sudo docker info

#查看docker帮助文档
sudo docker --help
```

#### 1.4 查看docker版本信息

```bash
[root@centos ~]# docker -v
Docker version 20.10.3, build 48d30b5
[root@centos ~]# docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:32:37 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
[root@centos ~]# 
```

#### 1.5 验证docker是否正确安装

```bash
[root@centos ~]# sudo systemctl start docker
[root@centos ~]# sudo docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

[root@centos ~]# 
```

**通过运行hello-world映像，验证Docker引擎是否正确安装。出现`Hello from Docker!`表示已经正确安装。**

#### 1.6 Docker的卸载

- 卸载Docker Engine、CLI和Containerd包：

```bash
sudo yum remove docker-ce docker-ce-cli containerd.io
```

- 删除镜像、容器、配置文件等内容：

```bash
sudo rm -rf /var/lib/docker
```

### 2.配置镜像加速

Docker从Docker Hub拉取镜像时，由于是从国外获取，所以速度较慢，我们可以通过配置国内镜像源的方式来提高拉取速度，这里主要介绍中国科学技术大学(USTC)和网易的开源镜像源。

- 编辑`daemon.json`文件：

```bash
vim /etc/docker/daemon.json
```

- 在`daemon.json`文件中输入以下内容并保存：

```json
{
  "registry-mirrors":["http://hub-mirror.c.163.com","https://docker.mirrors.ustc.edu.cn"]
}
```

- 重新加载配置文件并重启docker服务：

```bash
#重新加载配置文件
sudo systemctl daemon-reload

#重新启动docker
sudo systemctl restart docker
```

### 3.镜像相关命令

#### 3.1 查看镜像(docker images)

**用法：**

```bash
docker images [OPTIONS] [REPOSITORY[:TAG]]
```

`OPTIONS`就是下面表格中的内容，`REPOSITORY`是镜像的名称，`TAG`是镜像的标签。

**Options**

| 名称            | 默认值 | 描述                           |
| :-------------- | :----- | :--------------------------- |
| `--all , -a`    |        | 列出本地所有的镜像 |
| `--digests`     |        | 显示镜像的摘要信息     |
| `--filter , -f` |        | 根据提供的条件过滤输出 |
| `--format`      |        | 对镜像进行格式化展示 |
| `--no-trunc`    |        | 不截断输出(指的是会展示详细信息) |
| `--quiet , -q`  |        | 只显示镜像ID |

以下为了查看方便，所以我先使用`docker pull`命令拉取了几个镜像下来。

##### 3.1.1 查看所有镜像

使用`docker images`命令可以查看所有镜像，如下所示：

```bash
[root@centos ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
redis         5         e35748fd6a72   4 weeks ago     98.4MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
```

- `REPOSITORY`：镜像在仓库中的名称。
- `TAG`：镜像标签。
- `IMAGE ID`：镜像ID。
- `CREATED`：这个是镜像的创建日期，不是获取镜像的日期。
- `SIZE`：镜像大小。

这些镜像都存储在docker宿主机的`/var/lib/docker`目录下。

##### 3.1.2 查看指定名称的镜像

假如想要查看名称为redis的镜像，可以使用`docker images redis`命令，如下所示：

```bash
[root@centos ~]# docker images redis
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

根据名称查镜像，支持使用*号进行模糊匹配，如下所示：

```bash
[root@centos ~]# docker images red*
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

##### 3.1.3 查看指定名称及标签的镜像

比如使用`docker images redis:5`命令，就表示查出名称是**redis**，标签名是**5**的镜像，如下所示：

```bash
[root@centos ~]# docker images redis:5
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

我们也可以只根据标签查镜像，比如想要查标签名是**latest**的所有镜像，可以使用`docker images *:latest`命令，查询结果如下所示：

```bash
[root@centos ~]# docker images *:latest
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
```

##### 3.1.4 查看标签为空的镜像

可以使用`docker images -f "dangling=true"`命令列出**TAG**那一列值为空的镜像，如果dangling为false的话，就是列出**TAG**那一列值不为空的镜像。效果展示如下：

```bash
[root@centos ~]# docker images -f "dangling=true"
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<none>              <none>              450e15c7459f        10 hours ago        177MB
<none>              <none>              96ae66cb0553        16 hours ago        283MB
```

##### 3.1.5 只展示镜像ID

这里使用的是`docker images -q`命令，假设我们只想展示redis镜像的镜像id，效果如下：

```bash
[root@centos ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
busybox       latest    b97242f89c8a   4 weeks ago     1.23MB
redis         5         e35748fd6a72   4 weeks ago     98.4MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
[root@centos ~]# docker images redis
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
[root@centos ~]# docker images -q redis
eb0ab2d55fdf
e35748fd6a72
```

##### 3.1.6 自定义镜像的展示效果

这里需要用到`docker images --format`命令，该命令后跟的是自定义的输出模板，可以有如下占位符：

| 占位符          | 描述                             |
| --------------- | -------------------------------- |
| `.ID`           | 镜像ID                           |
| `.Repository`   | 镜像名称                         |
| `.Tag`          | 镜像标签                         |
| `.Digest`       | 镜像摘要                         |
| `.CreatedSince` | 镜像被创建至今已经过去了多长时间 |
| `.CreatedAt`    | 镜像被创建的具体时间             |
| `.Size`         | 镜像大小                         |

- 带表头展示镜像ID和名称：

```bash
[root@centos ~]# docker images --format "table {{.ID}}\t{{.Repository}}"
IMAGE ID       REPOSITORY
bf4709e77b18   tomcat
eb0ab2d55fdf   redis
b97242f89c8a   busybox
e35748fd6a72   redis
bf756fb1ae65   hello-world
```

- 不带表头展示镜像ID和名称：

```bash
[root@centos ~]# docker images --format "{{.ID}}\t{{.Repository}}"
bf4709e77b18    tomcat
eb0ab2d55fdf    redis
b97242f89c8a    busybox
e35748fd6a72    redis
bf756fb1ae65    hello-world
```

- 不带表头展示镜像名称、镜像标签和镜像大小：

```bash
[root@centos ~]# docker images --format "{{.Repository}}--->{{.Tag}}--->{{.Size}}"
tomcat--->latest--->667MB
redis--->latest--->104MB
busybox--->latest--->1.23MB
redis--->5--->98.4MB
hello-world--->latest--->13.3kB
```

- 不带表头展示镜像名称和时间：

```bash
[root@centos ~]# docker images --format "{{.Repository}}\t{{.CreatedAt}}\t{{.CreatedSince}}"
tomcat  2021-02-10 16:30:33 +0800 CST   5 days ago
redis   2021-02-10 01:03:48 +0800 CST   5 days ago
busybox 2021-01-13 17:25:26 +0800 CST   4 weeks ago
redis   2021-01-13 03:00:16 +0800 CST   4 weeks ago
hello-world     2020-01-03 09:21:37 +0800 CST   13 months ago
```

#### 3.2 搜索镜像(docker search)

##### 3.2.1 用法

```bash
docker search [OPTIONS] TERM
```

##### 3.2.2 描述说明

`docker search`用于从[Docker Hub](https://hub.docker.com)中搜索指定的镜像。

##### 3.2.3 选项

| 名称            | 默认值 | 描述                   |
| --------------- | ------ | ---------------------- |
| `--filter , -f` |        | 根据提供的条件过滤输出 |
| `--format`      |        | 对镜像进行格式化展示   |
| `--limit`       | 25     | 搜索结果的最大数量     |
| `--no-trunc`    |        | 不截断输出             |

##### 3.2.4 案例

###### 3.2.4.1 通过名称搜索镜像

假设我们想从docker Hub中搜索名称包含redis的镜像，可以使用`docker search redis`命令，如下所示：

![image-20210216193854357](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216195058.png) 

- `NAME`：镜像在仓库中的名称。

- `DESCRIPTION`：镜像的描述信息。
- `STARS`：镜像的收藏数。
- `OFFICIAL`：是否为docker官方发布的镜像。
- `AUTOMATED`：是否为自动化构建的镜像。

###### 3.2.4.2 限制搜索结果的展示数量

我们在搜索镜像时，默认情况下，会展示25条搜索结果，如果我们想要改变展示数量的话，可以使用`--limit`。比如我们只想展示5条记录，可以使用`docker search --limit 5 redis`命令，如下所示：

![image-20210216195906707](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216200003.png) 

###### 3.2.4.3 根据条件过滤展示搜索结果

我们可以使用`-f`or`--filter`进行条件过滤，过滤条件使用的是`key=value`这种键值对的形式，可以有多个过滤条件。

支持的过滤条件如下：

- `stars`：数字类型，表示镜像拥有的收藏数量。
- `is-automated`：布尔类型，表示是否为自动化构建的镜像。
- `is-official`：布尔类型，表示是否为官方发布的镜像。

**STARS**

搜索名称包含redis并且收藏数不小于15的镜像，可以使用`docker search -f stars=15 redis`命令。

![image-20210216202421991](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216202441.png) 

**IS-AUTOMATED**

搜索名称包含redis并且是自动化构建的镜像，可以使用`docker search -f is-automated=true redis`命令。

![image-20210216203156607](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216203159.png) 

**IS-OFFICIAL**

搜索名称包含redis并且是官方发布的镜像，可以使用`docker search -f is-official=true redis`命令。

![image-20210216203558030](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216203601.png) 

**组合过滤**

搜索名称包含redis并且是自动化构建的镜像，可以用`docker search -f is-automated=true -f stars=15 redis`命令。

![image-20210216204800097](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216204802.png) 

###### 3.2.4.4 自定义展示镜像的搜索结果

可以使用`--format`选项对搜索结果进行格式化输出，可以有如下占位符：

| 占位符         | 描述                   |
| -------------- | ---------------------- |
| `.Name`        | 镜像名称               |
| `.Description` | 镜像描述               |
| `.StarCount`   | 镜像收藏数             |
| `.IsOfficial`  | 是否为官方发布的镜像   |
| `.IsAutomated` | 是否为自动化构建的镜像 |

- 可以使用`docker search --format "table {{.Name}}\t{{.StarCount}}" redis`命令搜索名称包含redis，并且带表头只显示镜像名称和收藏数的镜像。

![image-20210216210251429](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216210253.png) 

- 可以使用`docker search --format "{{.Name}}" redis`命令搜索名称包含redis，并且不带表头只显示镜像名称的镜像。

![image-20210216210621283](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216213813.png) 

###### 3.2.4.5 展示搜索结果的详细信息

我们在搜索镜像的时候可以发现，描述信息并没有完全展示，如果我们想要完全展示的话，就需要用到`--no-trunc`选项，比如我们使用`docker search --no-trunc redis`命令搜索redis，可以发现，描述信息已经被全部展示了。

![image-20210217123205172](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123207.png) 

#### 3.3 拉取镜像(docker pull)

##### 3.3.1 根据名称拉取镜像

假设我们想要拉取nginx镜像，可以使用`docker pull nginx`命令，该命令拉取的镜像的标签默认是latest。

![image-20210216213756947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216213759.png) 

##### 3.3.2 根据名称和标签拉取镜像

我们也可以指定标签来拉取镜像，比如使用`docker pull nginx:1.19.6`命令拉取指定标签的镜像。

![image-20210216214204028](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216214206.png) 

#### 3.4 删除镜像(docker rmi)

##### 3.4.1 不加标签删除

不加标签默认会删除标签为latest的镜像，比如使用`docker rmi nginx`命令删除nginx镜像。

![image-20210216220851333](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216220854.png) 

##### 3.4.2 指定标签删除

比如使用`docker rmi nginx:mainline`命令删除标签为mainline的镜像。

![image-20210216221645629](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216221647.png) 

##### 3.4.3 根据镜像id删除

比如使用`docker rmi b9e1dc12387a`命令删除该id对应的镜像。

![image-20210217095107558](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217095115.png) 

##### 3.4.4 强制删除镜像

我们可以使用`--force`或者`-f`强制删除一个镜像，比如使用`docker rmi -f f6d0b4767a6c`命令强制删除该id对应的镜像。

![image-20210217095612682](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217095618.png) 

##### 3.4.5 删除所有镜像

可以使用`docker rmi -f $(docker images -aq)`命令删除本地所有镜像。

![image-20210217114301947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217114305.png) 

### 4.容器相关命令

#### 4.1 查看容器(docker ps)

**用法：**

```bash
docker ps [OPTIONS]
```

**Options**

| 名称            | 默认值 | 描述                                                         |
| --------------- | ------ | ------------------------------------------------------------ |
| `--all , -a`    |        | 显示所有容器(不使用该参数的话，默认只会显示正在运行中的容器) |
| `--filter , -f` |        | 根据提供的条件过滤输出                                       |
| `--format`      |        | 对容器进行格式化展示                                         |
| `--last , -n`   | -1     | 显示最后创建的容器(包括所有状态)                             |
| `--latest , -l` |        | 显示最近一次创建的容器(包括所有状态)                         |
| `--no-trunc`    |        | 不截断输出                                                   |
| `--quiet , -q`  |        | 只显示容器id                                                 |
| `--size , -s`   |        | 显示文件总大小                                               |

##### 4.1.1 查看所有容器

可以使用`docker ps -a`命令查看所有容器，包括正在运行的和已经停止运行的。

![image-20210217121258115](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217121301.png) 

##### 4.1.2 查看正在运行中的容器

使用`docker ps`命令可以查看所有正在运行中的容器，已经停止的容器，不会展示出来。

![image-20210217121502796](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123755.png) 

##### 4.1.3 展示容器的详细信息

比如可以使用`docker ps --no-trunc`命令展示正在运行中的容器的详细信息。

![image-20210217123712412](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123759.png) 

由上图可知，默认情况下**CONTAINER ID**和**COMMAND**这两列下的内容都被进行了截取，而只有在使用了`--no-trunc`选项之后这两列下的内容才完全展示出来。

##### 4.1.4 容器的磁盘大小展示

可以使用`docker ps -s`命令展示容器大小，展示的结果中会有两个数值，一个是容器真实增加的大小，一个是整个容器的虚拟大小，**容器虚拟大小 = 容器真实增加的大小 + 容器镜像的大小**。

![image-20210217124744087](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217124748.png) 

##### 4.1.5 根据条件过滤容器

我们可以使用`-f`or`--filter`进行条件过滤，过滤条件使用的是`key=value`这种键值对的形式，可以有多个过滤条件。

支持的过滤条件如下：

- `id`：容器的id。
- `name`：容器的名称。
- `label`：表示键或键值对的任意字符串。
- `exited`：表示容器退出的状态码，只有在使用`-a`这个选项时该条件才会生效。
- `status`：容器的状态(`created`,`restarting`,`running`,`removing`,`paused`,`exited`,`dead`)。
- `ancestor`：过滤从指定镜像创建的容器。
- `before` or `since`：过滤在给定的容器ID或名称之前或之后创建的容器。
- `volume`：过滤挂载有指定数据卷的容器。
- `network`：过滤连接到指定网络的容器。
- `publish` or `expose`：过滤发布或公开给定端口的容器。。
- `health`：根据容器的健康检查状态过滤容器(`starting`,`healthy`,`unhealthy`,`none`)。
- `isolation`：Windows daemon使用(`default`,`process`,`hyperv`)。
- `is-task`：是否是一个服务的task(`true` or `false`)。

###### 4.1.5.1 根据容器id或容器名称进行过滤

使用`docker ps -af "id=b64edfe27b8b"`命令或者`docker ps -af "name=bold_bouman"`命令就是根据容器id及容器名称进行过滤的方式。

![image-20210217172323762](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217173138.png) 

###### 4.1.5.2 根据容器退出的状态码进行过滤

比如只想展示退出的状态码是0的容器，可以使用`docker ps -af "exited=0"`命令。

![image-20210217173136555](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217173319.png) 

###### 4.1.5.3 根据容器的状态进行过滤

假设我们只想展示正在运行的容器，这时候就可以使用`docker ps -af status=running`命令。

![image-20210217173639022](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174126.png) 

###### 4.1.5.4 根据镜像过滤容器

假设我们只想展示tomcat这个镜像创建的容器，可以使用`docker ps -af ancestor=tomcat`命令。

![image-20210217174122193](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174640.png) 

除了可以使用镜像名称过滤外，也可以使用镜像id来过滤该镜像对应的容器。这种方式需要我们先获取到镜像的id，然后再根据id过滤即可，可以使用`docker ps -af ancestor=$(docker images -q tomcat)`命令。

![image-20210217174633731](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174646.png) 

##### 4.1.6 格式化展示容器

可以使用`--format`选项对容器进行格式化结果展示，可以有如下占位符：

| 占位符        | 描述                                       |
| :------------ | :----------------------------------------- |
| `.ID`         | 容器id                                     |
| `.Image`      | 镜像名称                                   |
| `.Command`    | 启动命令                                   |
| `.CreatedAt`  | 容器创建的时间                             |
| `.RunningFor` | 容器被创建至今已经过去了多长时间           |
| `.Ports`      | 端口信息                                   |
| `.State`      | 容器状态(比如`created`,`running`,`exited`) |
| `.Status`     | 带有持续时间和运行状况的状态               |
| `.Size`       | 容器磁盘大小                               |
| `.Names`      | 容器名称                                   |
| `.Labels`     | 分配给容器的所有标签                       |
| `.Label`      | 指定的标签值                               |
| `.Mounts`     | 容器中挂载的卷的名称                       |
| `.Networks`   | 连接到容器的网络名称                       |

使用`docker ps -a --format "table {{.ID}}\t{{.Image}}\t{{.CreatedAt}}\t{{.RunningFor}}\t{{.State}}\t{{.Status}}\t{{.Names}}"`命令进行格式化演示，如下所示：

![image-20210217182003114](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217182011.png) 

##### 4.1.7 显示最近创建的容器

如果我们想要展示最近一次或者前几次创建的容器，可以使用`-l`和`-n`选项来实现，比如使用`docker ps -l`命令就是展示最近一次创建的容器，使用`docker ps -n 3`命令则是展示前3次创建的容器。

![image-20210217185123880](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217185125.png) 

#### 4.2 运行容器(docker run)

**用法：**

```bash
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

**常用选项：**

| 名称             | 默认值 | 描述                                             |
| :--------------- | :----- | :----------------------------------------------- |
| `-d`             |        | 后台运行容器，并返回容器id，也即启动守护式容器   |
| `--name`         |        | 为容器指定一个名称                               |
| `-i`             |        | 以交互模式运行容器，通常与`-t`同时使用           |
| `-t`             |        | 为容器重新分配一个伪输入终端，通常与`-i`同时使用 |
| `-p`             |        | 指定端口映射，格式为：**宿主机端口:容器端口**    |
| `-P`             |        | 随机端口映射，容器内部端口随机映射到主机的端口   |
| `--rm`           |        | 当容器退出时自动移除该容器                       |
| `--privileged`   |        | 给这个容器扩展权限                               |
| `--workdir , -w` |        | 指定容器的工作目录                               |
| `--volume , -v`  |        | 绑定挂载卷                                       |
| `--env , -e`     |        | 设置环境变量                                     |

##### 4.2.1 前台运行容器

假设直接使用`docker run nginx`命令运行nginx，这种就属于前台运行，前台运行会占用我们的窗口。

![image-20210217202517929](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217203000.png) 

为了验证容器是否运行成功，可以另开一个窗口进行查看。由下图可知，容器确实运行成功了。

![image-20210217202710813](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217202942.png) 

##### 4.2.2 后台运行容器

如果想要后台运行容器，需要用到`-d`选项。比如可以使用`docker run -d tomcat`命令后台运行tomcat容器。

![image-20210217211959212](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217212001.png) 

##### 4.2.3 给需要运行的容器指定名称

我们可以使用`docker run --name mytomcat -d tomcat`命令通过后台的方式运行一个tomcat容器，并将该容器命名为mytomcat。

![image-20210217213909480](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217213916.png) 

##### 4.2.4 容器端口映射

容器中启动的应用，外部方式默认情况下是无法访问到的，这时候就可以通过端口映射的方式和宿主机进行关联，比如可以使用`-P`选项随机映射到宿主机的某个端口上。使用`docker run --name mynginx -P -d nginx`命令运行nginx容器就是指把运行的容器对应的80端口映射到宿主机的49153端口上，这时外部通过宿主机的49153端口就可以访问到容器中运行的nginx了。

![image-20210217214554883](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217220158.png) 

除了随机映射外，我们还可以通过`-p`选项指定端口映射。如下图所示，外部通过宿主机的12345端口就可以访问到容器中使用80端口运行的nginx了。使用的命令是` docker run --name nginxtest -p 12345:80 -d nginx`。

![image-20210217220153801](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217220205.png) 

##### 4.2.5 运行并进入容器

我们可以使用`-i`和`-t`选项在启动容器后就进入容器与容器进行交互。比如使用`docker run -it centos:7`命令就会启动并进入到容器中，下图中的`ls`命令就是在centos容器中使用的。

![image-20210217221342809](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217221903.png)

##### 4.2.6 进入容器的指定目录

假设我们想在运行容器后就直接进入到`/etc/yum`目录中，那么可以使用`docker run -w /etc/yum -it centos:7`命令来实现，如果该目录不存在，则会在容器中自动新建该目录。

![image-20210218095253265](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218095258.png) 

我们也可以直接进入容器的指定目录下执行指定的命令后再退出容器，比如我们想要在容器的`/etc/yum`目录下执行`ls`命令后再退出容器，可以使用`docker run -w /etc/yum -it centos:7 ls`命令。

![image-20210218100027654](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218100037.png) 

#### 4.3 退出容器

```bash
exit  # 使用-it选项运行并进入centos容器后，使用该命令退出容器后，同时也会停止容器
Ctrl + P + Q  # 退出不停止容器
```

#### 4.4 删除容器(docker rm)

与删除镜像的用法差不多，如果想要强制删除的话，需要用到`-f`选项，也可以通过容器id进行全量删除。

- 根据容器名称删除(比如：`docker rm amazing_jang`)

![image-20210218102908307](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218102910.png) 

- 根据容器id删除(比如：`docker rm 844c7ea979a4`)

![image-20210218103127487](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218103143.png) 

- 强制删除容器(比如：`docker rm -f def0deead9e5`)

使用`-f`选项可以删除正在运行中的容器。

![image-20210218103558726](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218103600.png) 

- 全量删除容器(比如：`docker rm $(docker ps -aq)`)

![image-20210218104535412](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218104538.png) 

- 删除多个容器(比如：`docker rm 9309fcf92cd6 ee765a728229`)

![image-20210218182229334](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218182231.png) 

#### 4.5 进入容器(docker exec)

我们可以通过容器名称或者容器id来进入容器，进入容器的命令后面可以跟`sh`也可以跟`bash`，比如我们想要进入一个正在运行的nginx容器中，可以使用`docker exec -it 8abd33e52701 sh`命令，8abd33e52701是容器的id，也可以使用`docker exec -it mynginx bash`命令，mynginx是容器的名称。

![image-20210218112401907](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218112408.png) 

#### 4.6 容器的停止和启动

我们可以使用`docker stop 容器名称|容器id`命令来停止容器，使用`docker start 容器名称|容器id`命令来启动容器。

![image-20210218115455420](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218115457.png) 

>  如果想要重启容器的话，就用`docker restart`命令。

#### 4.7 容器和宿主机之间的文件拷贝

我们可以将宿主机上的文件拷贝到容器中，也可以将容器中的文件拷贝到宿主机上。

- **宿主机--->容器：**

```bash
docker cp 宿主机的文件或目录 容器名称或id:容器目录
```

假设我们想将宿主机的`/root/nginx/linux-nginx-1.16.1.tar.gz`文件拷贝到容器的`/home`路径下，可以使用下图中的命令，当我们进入到容器的`/home`路径下时，发现确实有`linux-nginx-1.16.1.tar.gz`文件，说明拷贝成功了。

![image-20210218121407834](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218121410.png) 

- **容器--->宿主机：**

```bash
docker cp 容器名称或id:容器的文件或目录 宿主机的目录
```

比如使用`docker cp mynginx:/lib/init/vars.sh /root/test`命令将容器中的`/lib/init/vars.sh`文件拷贝到宿主机的`/root/test`目录下。由下图可知，已经拷贝成功了。

![image-20210218123608436](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218123610.png) 

#### 4.8 目录挂载(容器数据卷操作)

我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器，而且这个操作是双向绑定的，也就是说，容器内的操作也会影响到宿主机，可以实现备份功能。

使用目录挂载的话，当容器被删除的时候，宿主机与容器映射的目录下的内容并不会被删除。如果多个容器挂载了同一个目录，当其中一个容器被删除的时候，其他容器的该目录下的内容并不会受到影响。

> 容器与宿主机之间的数据卷属于引用的关系，数据卷是从外界挂载到容器内部中的，所以可以脱离容器的生命周期而独立存在，正是由于数据卷的生命周期并不等同于容器的生命周期，在容器退出或者删除以后，数据卷才不会受到影响。
>
> 目录挂载操作可能会出现权限不足的提示。这是因为CentOS7中的安全模块SELinux把权限禁掉了，在docker run时可以通过`--privileged=true`给该容器加权限来解决挂载的目录没有权限的问题。

##### 4.8.1 指定目录挂载

如果想要在运行容器的时候使用目录挂载，需要使用`-v`选项，该选项后跟的目录的格式为:`宿主机目录:容器目录`。也可以使用`docker run -v 宿主机目录:容器目录 -v 宿主机目录2:容器目录2 镜像名`这种格式进行多目录挂载。

假设我们想把宿主机的`/root/test`路径和容器的`/home/gsl`路径(没有该路径的话会自动创建)进行映射，那么我们可以在运行容器的时候使用`docker run --name mynginx -d -v /root/test:/home/gsl nginx`命令实现。然后我们进入到容器的`/home/gsl`目录下会发现，之前宿主机的`/root/test`目录下的vars.sh文件，在容器的`/home/gsl`目录下也存在，这就说明已经完成了目录挂载，这时不管对哪一个目录进行操作，都会完成数据同步。

![image-20210218153900305](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218153903.png) 

如果我们想要知道宿主机和容器之间的这个目录映射关系，可以使用`docker inspect 容器名称|容器id`命令查看，比如使用`docker inspect mynginx|grep -A9 "Mounts"`命令。

![image-20210218160018559](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218160154.png) 

##### 4.8.2 匿名目录挂载

匿名挂载不需要我们在运行容器时再指定宿主机的目录，只要指定容器的目录即可，然后宿主机上对应的目录都会自动生成到`/var/lib/docker/volumes`路径下。比如使用`docker run --name mynginx -d -v /usr/local/data nginx`。

![image-20210218164411072](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218164415.png) 

##### 4.8.3 具名目录挂载

具名挂载就是给数据卷起一个名字，容器外对应的目录会在`/var/lib/docker/volumes`路径中生成。比如我们给宿主机上的数据卷起名为host_data，使用`docker run --name mynginx01 -d -v host_data:/usr/local/data nginx`命令即可。

![image-20210218172143590](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218172145.png) 

##### 4.8.4 只读/读写

```bash
# 只读。只能通过修改宿主机内容实现对容器的数据管理，不能在容器中修改映射到容器的目录下的文件。
docker run -v /宿主机目录:容器目录:ro 镜像名
# 读写。默认就是读写，也就是说进行目录挂载后，宿主机和容器都能对映射目录下的文件进行修改。
docker run -v /宿主机目录:容器目录:rw 镜像名
```

##### 4.8.5 继承(volumes-from)

假设我们已经运行了一个使用了目录挂载的容器A，然后我们还想运行一个带目录挂载的容器B，并且希望容器B使用挂载对应宿主机的目录和容器中映射的目录和容器A都一样，这时候就可以使用`--volumes-from`选项来实现。命令如下：

```bash
# 运行mynginx容器
docker run -d --name mynginx -v /root/test:/usr/local/data nginx
# 运行mynginx01容器，并继承mynginx容器的目录挂载
docker run -d --name mynginx01 --volumes-from mynginx nginx
# 查看mynginx容器的目录挂载信息
docker inspect mynginx|grep -A9 "Mounts"
# 查看mynginx01容器的目录挂载信息
docker inspect mynginx01|grep -A9 "Mounts"
```

![image-20210218175903870](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218175906.png) 

##### 4.8.6 查看数据卷的基本信息

可以使用`docker volume inspect 数据卷名称`来查看数据卷的基本信息，比如之前创建了一个名字叫host_data的数据卷，那就可以使用`docker volume inspect host_data`命令查看这个数据卷的基本信息。

![image-20210218181625687](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218181628.png) 

##### 4.8.7 查看容器IP信息

可以使用`docker inspect`命令查看容器的IP信息，比如使用`docker inspect mynginx|grep -A16 "Networks"`命令查看mynginx容器的IP信息。

![image-20210218182755742](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218182758.png) 

#### 4.9 提交镜像(docker commit)

我们可以使用`docker commit`命令把自己更改过的容器创建成一个新的镜像。

**用法：**

```bash
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
```

**选项：**

| 名称             | 默认值 | 描述                               |
| ---------------- | ------ | ---------------------------------- |
| `--author , -a`  |        | 该选项用于添加镜像提交人的信息     |
| `--change , -c`  |        | 对创建的映像应用Dockerfile指令     |
| `--message , -m` |        | 该选项用于添加提交镜像时的描述信息 |
| `--pause , -p`   | true   | 在镜像的提交期间暂停容器           |

**命令举例：**

```bash
# "gongsl"是作者，"installed nginx"是描述信息，"mycentos"是生成的镜像的名称，"1.0.0"是生成的镜像的标签
docker commit -a="gongsl" -m="installed nginx" 容器id|容器名称 mycentos:1.0.0
```

当我们根据容器创建了一个新的镜像后，我们使用`docker images`命令是可以展示出这个新的镜像的。

![image-20210218201801415](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218201803.png) 

**实操演示：**

下面我就实操演示一下，如何在一个运行的centos容器中安装nginx并生成一个新的镜像。

![演示](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218213901.gif) 

### 5.Dockerfile的用法

#### 5.1 Dockerfile简介

Docker可以通过读取Dockerfile中的指令来自动构建镜像。Dockerfile是一种文本文档，它包含用户可以在命令行上调用的所有命令来组装镜像。使用docker构建，用户可以创建一个自动构建，连续执行几个命令行指令。

我们可以使用`docker build`命令来构建镜像。该命令根据Dockerfile和上下文构建镜像。构建的上下文是位于指定位置、路径或URL的一组文件。路径是本地文件系统上的一个目录。URL是一个Git存储库位置。

构建是由Docker守护进程运行的，而不是由CLI运行。构建过程所做的第一件事是将整个上下文(递归地)发送给守护进程。在大多数情况下，最好从一个空目录开始作为上下文，并将Dockerfile保存在该目录中。只添加构建Dockerfile所需的文件。不要使用你的根目录`/`作为路径，因为它会将你的硬盘驱动器的整个内容传输到Docker守护进程。

#### 5.2 Dockerfile的常用指令

##### 5.2.1 FROM

`FROM`指令一般用于初始化一个新的构建阶段，并为后续指令设置基本镜像。因此，一个有效的Dockerfile必须以FROM指令开始。镜像可以是任何有效的镜像，一般从公共存储库中提取镜像尤其容易。

**语法**：`FROM <image>:<tag>`

指明构建的新镜像是来自于哪个基础镜像，如果没有选择tag，那么默认值为latest。

**案例**：

```bash
FROM centos:7
```

> 如果不以任何镜像为基础，那么可以写成`FROM scratch`。scratch镜像是一个空镜像，如果我们想要从零开始构建一个属于自己的镜像，就可以使用scratch镜像，不过一般我们没必要这么做。

##### 5.2.2 LABEL

**语法**：`LABEL <key>=<value> <key>=<value> <key>=<value> ...`

该指令后跟的是键值对的形式，可以只有一个键值对，也可以有多个。我们可以使用该指令给镜像添加一些像描述信息，版本号，作者等信息。

**案例**：

```bash
LABEL author="gongsl" version="1.0" description="This is a description"
```

##### 5.2.3 RUN

**语法**：`RUN <command>`

该指令后跟的是构建镜像时需要运行的shell命令，一个Dockerfile中可以包含多个RUN指令。

**案例**：

比如在构建的新镜像中我们想要安装一个vim编辑器，可以使用如下命令：

```bash
RUN yum -y install vim
```

##### 5.2.4 ADD

**语法**：`ADD <src>... <dest>`

该指令可以将文件或目录拷贝到镜像中。上面的src可以是一个本地普通文件或压缩文件，如果是压缩文件的话，会自动进行解压。还可以是一个url，如果是url的话，那么ADD指令就类似于linux中的wget命令，会自动下载并解压。

**案例**：

```bash
ADD jdk-8u231-linux-x64.tar.gz /usr/local/java
```

> `jdk-8u231-linux-x64.tar.gz`指的是宿主机当前目录下的压缩文件，`/usr/local/java`指的是镜像里面的目录，如果该目录不存在，会自动进行创建。

##### 5.2.5 COPY

**语法**：`ADD <src>... <dest>`

该指令主要是拷贝文件或目录到镜像中，用法同ADD类似，不过这个指令就是单纯的拷贝，不支持自动下载和解压。

**案例**：

```bash
COPY readme.txt /usr/local
```

##### 5.2.6 EXPOSE

**语法**：`EXPOSE <port> [<port>/<protocol>...]`

该指令用于暴露容器运行时的监听端口给外部，可以指定端口是监听TCP还是UDP，如果未指定协议，默认是TCP。

**案例**：

```bash
EXPOSE 80 8080/tcp
```

> 这个指令只是暴露容器的端口，如果想要容器和宿主机的端口有映射关系，必须要在使用`docker run`命令运行容器的时候加上`-p`或者`-P`选项。

##### 5.2.7 ENV

**语法**：

- 添加单个：`ENV <key> <value>`

- 添加多个：`ENV <key>=<value> ...`

该指令主要用于设置容器内的环境变量的，可以使用该指令只添加一个，也可以添加多个。

**案例**：

```bash
ENV JAVA_HOME /usr/local/jdk1.8.0_231
```

##### 5.2.8 CMD

**语法**：

- `CMD ["executable","param1","param2"]`(比如：`CMD ["/usr/local/tomcat/bin/catalina.sh","run"]`)
- `CMD ["param1","param2"]`(比如：`CMD ["echo","$JAVA_HOME"]`)
- `CMD command param1 param2`(比如：`CMD echo $JAVA_HOME`)

该指令用于启动容器时需要执行的shell命令。在Dockerfile中只能有一条CMD指令，如果设置了多条CMD指令，只有最后一条会生效。

**案例**：

```bash
CMD ["/usr/local/apache-tomcat-8.5.47/bin/catalina.sh","run"]
```

**注意事项**：

- 如果`docker run`的时候指定了命令，则CMD指令会被替代。比如我们已经创建了一个`centos:7`镜像，然后现在使用了`docker run -it --name mycentos centos:7 echo "helloworld"`命令去运行它，那么CMD指令就会失效，上面案例中的tomcat就不会再启动了，而是输出`helloworld`；
- 这个`CMD`指令和前面说到的`RUN`指令有些类似，不过它们是有本质区别的。RUN指令是在使用`docker build`构建镜像的时候起作用，是构建镜像的一个步骤。好比我们想让镜像构建好后就包含某些命令或目录，就可以使用RUN指令下载命令或者创建目录。而CMD指令是在使用`docker run`启动容器时起作用，是启动容器后默认执行的命令。好比容器一启动就启动容器中的tomcat，或者输出java的环境变量信息等，都要使用CMD指令。

##### 5.2.9 ENTRYPOINT

**语法**：

- `ENTRYPOINT ["executable", "param1", "param2"]`

- `ENTRYPOINT command param1 param2`

该指令和CMD指令用法类似，指令后面跟的也是启动容器时需要执行的shell命令。ENTRYPOINT指令和CMD指令最大的不同就是，它不会被`docker run`命令后指定的命令所覆盖。在Dockerfile中只能有一条ENTRYPOINT指令，如果有多条该指令，只有最后一条会生效。

**案例**：

```bash
ENTRYPOINT echo $JAVA_HOME
```

**注意事项**：

- 如果在Dockerfile中同时出现了`ENTRYPOINT`指令和`CMD`指令,并且CMD指令不是一个完整的可执行的命令的话，那么CMD指令后的内容将会被作为ENTRYPOINT指令的参数；
- 如果在Dockerfile中同时出现了`ENTRYPOINT`指令和`CMD`指令,并且CMD指令是一个完整的可执行的命令的话，那么这两个指令会相互覆盖，谁在最后谁生效。

##### 5.2.10 WORKDIR

**语法**：`WORKDIR /path/to/workdir`

可以使用该指令设置一个工作目录，如果工作目录不存在，会自动创建。WORKDIR指令也可以解析在该指令之前使用ENV指令设置的环境变量。

**案例**：

```bash
# 直接设置一个绝对路径为工作目录
WORKDIR /usr/local

# 解析该指令前ENV指令设置的环境变量
ENV MYPATH /usr/local
WORKDIR $MYPATH
```

> 我们在进入已启动的容器时，默认是进入到`/`根目录下的，如果想要改变这个默认目录，就可以使用`WORKDIR`指令。假设我们使用该指令设置的工作目录是`/usr/local`的话，那么当我们进入容器后默认就会在这个目录下。

##### 5.2.11 VOLUME

**语法**：`VOLUME ["/data"]`

`VOLUME`指令使用指定的名称创建一个挂载点，并将其标记为保存来自本机主机或其他容器的外部挂载卷。一般的使用场景为需要持久化存储数据时。

**案例**：

```bash
# 容器的var/lib/mysql目录会在运行时自动挂载为匿名卷，匿名卷在宿主机的var/lib/docker/volumes目录下
VOLUME ["var/lib/mysql"]
```

> 一般不会在Dockerfile中用到该指令，更常见的是在使用`docker run`运行容器的时候通过`-v`选项指定数据卷。

#### 5.3 Dockerfile实战

> 如果我们想要通过读取Dockerfile中的指令来自动构建镜像，需要用到`docker build`命令。主要介绍下该命令的两个选项，分别是`-f`和`-t`。`-f`选项用于指定要读取的Dockerfile文件，而`-f`选项用于指定生成的镜像名。

接下来我们通过`docker build`命令读取Dockerfile文件的方式在基础镜像`centos:7`中安装jdk和tomcat，并将其制作为一个新的`mycentos:7`镜像。

**Dockerfile文件内容：**

```dockerfile
#指明构建的新镜像是来自于centos:7这个基础镜像
FROM centos:7
#通过镜像标签声明作者信息
LABEL author="gongsl"
#把宿主机的文件拷贝到容器指定目录中
COPY readme.txt /usr/local
#创建自定义目录
RUN mkdir -p /usr/local/java && mkdir -p /usr/local/tomcat
#将压缩包解压,并将解压后的目录拷贝到镜像的对应目录中
ADD jdk-8u231-linux-x64.tar.gz /usr/local/java
ADD apache-tomcat-8.5.47.tar.gz /usr/local/tomcat
#安装vim编辑器
RUN yum -y install vim
#随便配置一个环境变量，以便演示下面的WORKDIR指令
ENV MYPATH /usr/local
#将上一步设置的环境变量的值设置为工作目录
WORKDIR $MYPATH
#配置java和tomcat的环境变量
ENV JAVA_HOME /usr/local/java/jdk1.8.0_231
ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool.jar
ENV CATALINA_HOME /usr/local/tomcat/apache-tomcat-8.5.47
ENV CATALINA_BASE /usr/local/tomcat/apache-tomcat-8.5.47
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
#暴露容器运行时的8080监听端口给外部
EXPOSE 8080
#可以使用下面这种方式在启动容器后就启动tomcat,但是为了目录挂载获取实时日志,暂时就不使用这种方式了
#CMD ["/usr/local/tomcat/apache-tomcat-8.5.47/bin/catalina.sh","run"]
#使用下面这种方式启动tomcat的话,只要使用了目录挂载,就可以在宿主机上获取tomcat的实时日志
CMD /usr/local/tomcat/apache-tomcat-8.5.47/bin/startup.sh && tail -F /usr/local/tomcat/apache-tomcat-8.5.47/logs/catalina.out
```

**a.jsp文件内容：**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>My JSP</title>
    
        <meta http-equiv="pragma" content="no-cache">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="expires" content="0">    
        <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
        <meta http-equiv="description" content="This is my page">

  </head>
  <body>
    This is a test!
    <% System.out.println("tomcat is running..."); %>
  </body>
</html>
```

**web.xml文件内容：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1">
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
</web-app>
```

**readme.txt文件内容：**

```xml
This is a test document!
```

**构建新镜像前的目录结构：**

![image-20210220212255917](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220212521.png) 


```bash
/root/test/
         |
         |---Dockerfile   #这个就是Dockerfile文件，没有后缀名
         |
         |---logs/   #这个是挂载目录，对应容器中tomcat的logs目录
         |
         |---project/   #这也是一个挂载目录，同时也是最简单的一个小项目，用于测试tomcat运行情况
         |         |
         |         |---a.jsp
         |         |
         |         |---WEB-INF/
         |                   |
         |                   |---web.xml
         |---resource/
                    |
                    |---apache-tomcat-8.5.47.tar.gz
                    |
                    |---jdk-8u231-linux-x64.tar.gz
                    |
                    |---readme.txt   #这个是随便创建的一个文件，是用于测试Dockerfile的COPY指令用的
```

**构建新镜像：**

**命令**：`docker build -f /root/test/Dockerfile -t mycentos:1.0 /root/test/resource/`

> 上面的`/root/test/Dockerfile`是Dockerfile文件的位置，`/root/test/resource/`是Dockerfile文件中用到的软件和文件的位置。比如`COPY readme.txt /usr/local`这条指令需要把readme.txt文件拷贝到容器中，这个文件就是从`/root/test/resource/`目录中获取的。

- **开始构建：**

![image-20210219210518386](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219210520.png) 

- **构建成功：**

![image-20210219213328500](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219213330.png) 

**注意**：像下图这种，Dockerfile文件中用到的软件和文件都和Dockerfile文件在相同的`/root/test`目录下，并且也是在这个目录下使用`docker build`构建新镜像的话，那直接使用`docker build -t mycentos:1.0 .`命令就可以了。

![image-20210219205034411](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219205822.png) 

**运行镜像：**

`docker run -d -p 8080:8080 --name mytest \
-v /root/test/project/:/usr/local/tomcat/apache-tomcat-8.5.47/webapps/project \
-v /root/test/logs/:/usr/local/tomcat/apache-tomcat-8.5.47/logs \
mycentos:1.0`

![image-20210219214057759](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219214100.png) 

由上图可知，镜像已经运行成功了。

接下来可以进入到容器中看下，像[jdk-8u231-linux-x64.tar.gz](https://share.weiyun.com/4AUk6jRw)以及[apache-tomcat-8.5.47.tar.gz](https://gongsl.lanzous.com/i3Q1Llv89ed)的解压文件还有readme.txt文件是否都拷贝到容器中对应的目录中了。

![检查拷贝情况](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219221513.gif) 

通过上面的动图可知，该拷贝的确实已经拷贝成功了。接下来就是查看tomcat的运行效果以及目录挂载效果。由于在运行项目的时候，已经把宿主机的`/root/test/project`目录和容器中tomcat下的`webapps/project`目录做映射了，所以其实已经相当于在容器中的tomcat里部署了一个名为project的项目了。我们可以通过访问该项目下的`a.jsp`文件来观察容器中tomcat的运行情况。

![检查运行情况](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219222807.gif) 

通过上面的动图可知，能够成功访问到项目下的`a.jsp`文件，说明容器中tomcat的运行是没有问题的。然后再检查下日志目录的挂载情况，看容器中tomcat的日志是否实时同步到宿主机对应目录的文件中了。

![检查日志同步情况](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219223452.gif) 

通过上面的动图可知，日志目录挂载也没有问题，日志也能实时同步到宿主机对应目录的文件中。至此，Dockerfile实战部分结束。

### 6.镜像的备份、恢复和迁移

#### 6.1 镜像备份

可以使用`docker save`命令将指定镜像保存成tar归档文件。

**用法**：`docker save [OPTIONS] IMAGE [IMAGE...]`

**选项**：

- `-o`：镜像打包后的归档文件输出的目录。

**案例**：

```bash
# 下面的mycentos:7是要被打包的镜像的名称和标签
docker save -o /root/mycentos7.tar mycentos:1.0
```

![image-20210219225150134](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219225152.png) 

#### 6.2 镜像恢复

可以使用`docker load`命令导入使用docker save命令导出的镜像归档文件。

**用法**：`docker load [OPTIONS]`

**选项**：

- `--input, -i`：指定导入的文件。

- `--quiet, -q`：精简输出信息。

**案例**：

```bash
docker load -i /root/mycentos7.tar
```

![image-20210219230126850](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219230130.png) 

#### 6.3 镜像迁移

镜像的迁移同时涉及上面两个操作，即备份和恢复。

我们可以将任何一个docker镜像从一台机器迁移到另一台机器。在迁移过程中，首先我们要把容器构建为docker镜像，然后该docker镜像被作为tar包文件保存到本地。此时只需要拷贝或移动该镜像到我们想要的机器上，恢复该镜像并运行容器即可。

当然，除了这种方式之外，我们还可以使用镜像仓库实现镜像的备份、恢复和迁移。

### 7.镜像仓库的使用

#### 7.1 公共仓库的使用

这里的公共仓库指的是[DockerHub](https://hub.docker.com/)，上传到公共仓库的镜像是可以供所有人进行下载使用的。

推送镜像到公共仓库的具体步骤如下：

- 首先到DockerHub中注册一个属于自己的账号(如果页面登录进去的话，发现自己的仓库下是没有任何镜像的)；

![image-20210220105929912](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220105933.png) 

- 然后回到宿主机界面，使用`docker login`命令输入用户名和密码后进行登录；

![image-20210220110639330](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220110736.png) 

- 由于是国外网站，网速较慢，所以这里找一个小点的镜像进行演示，这里就使用`docker pull hello-world`拉取公共仓库的hello-world镜像；

![image-20210220111218870](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220111221.png) 

- 使用`docker tag hello-world:latest gongcqq/my-hello-world:1.0.0`命令给hello-world镜像打个标签，生成一个属于自己的专属镜像；

![image-20210220112437882](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220112439.png) 

- 使用`docker push gongcqq/my-hello-world:1.0.0`命令将刚才生成的新镜像推送到远程的公共仓库；

![image-20210220112815097](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220112817.png) 

- 浏览器方式登录DockerHub进行查看，发现镜像已经推送成功了，也可以点进去查看镜像详情；

![image-20210220112937643](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220113232.png) 

![image-20210220113225973](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220113300.png) 

- 如果想要退出登录的话，直接使用`docker logout`命令即可；

![image-20210220114317076](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220114319.png) 

- 我们也可以使用`docker pull gongcqq/my-hello-world:1.0.0`命令来拉取之前推送到公共仓库的镜像。

![image-20210220114639118](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220114641.png) 

#### 7.2 私有仓库的使用

公共仓库DockerHub为我们提供了很多官方镜像和个人上传的镜像，我们可以下载机构或个人提供的镜像，也可以上传我们自己本地的镜像，不过公共仓库有如下缺点：

- 由于网络原因，从DockerHub下载和上传镜像速度可能会比较慢；
- 在生产上使用的docker镜像可能包含我们的代码、配置信息等，这些我们是只允许内部人员获取的，如果上传到公共仓库，安全性得不到保障。

为了解决以上问题，docker官方提供了一个叫做`registry`的镜像，该镜像可以为我们搭建本地私有仓库。在内部搭建的私有仓库可以使内网人员下载、上传都非常快速，不受外网宽带等因素的影响，只有内网人员可以下载我们的镜像，安全性也可以得到保障，并且私有仓库也支持配置仓库认证功能。

##### 7.2.1 拉取用于创建私有仓库的镜像

**命令**：`docker pull registry`

![image-20210220120345955](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220120351.png) 

##### 7.2.2 修改配置文件

修改`daemon.json`文件：

```bash
vim /etc/docker/daemon.json
```

添加以下内容，用于让docker信任私有仓库地址，添加后保存退出。

```json
{
  "insecure-registries":["192.168.68.12:5000"]
}
```

![image-20210220122601046](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220122603.png)  

重新加载配置信息，并重启docker服务。

```bash
#重新加载配置文件
sudo systemctl daemon-reload
#重新启动docker
sudo systemctl restart docker
```

##### 7.2.3 创建私有仓库容器

**运行容器：**

```bash
docker run -di --name registry -p 5000:5000 \
-v /root/mydata/docker_registry:/var/lib/registry registry
```

![image-20210220123712142](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220123716.png) 

打开浏览器输入：http://192.168.68.12:5000/v2/_catalog 看到`{"repositories":[]}`表示私有仓库搭建成功并且内容为空。

##### 7.2.4 推送镜像至私有仓库

```bash
#根据官方的hello-world生成一个专属镜像
docker tag hello-world:latest 192.168.68.12:5000/test-hello-world:1.0.0
#将生成的新镜像推送到私有仓库
docker push 192.168.68.12:5000/test-hello-world:1.0.0
```

![image-20210220124741827](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220124743.png) 

推送命令执行完后，浏览器再次访问刚才那个[地址](http://192.168.68.12:5000/v2/_catalog)可以发现，repositories下已经多了一个`test-hello-world`，说明本地镜像已经成功推送到了私有仓库。

![image-20210220130208066](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220130211.png) 

由于运行容器的时候我们做了目录挂载，所以也可以到宿主机对应的`/root/mydata/docker_registry`路径下看有没有推送到私有仓库上的镜像。

![image-20210220132031813](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220132035.png) 

##### 7.2.5 从私有仓库拉取镜像

```bash
#直接使用docker pull命令进行拉取即可
docker pull 192.168.68.12:5000/test-hello-world:1.0.0
```

![image-20210220130821347](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220130823.png) 

##### 7.2.6 配置私有仓库认证

之前创建的私有仓库容器是不带认证功能的，这里要演示认证功能的话，就需要重新创建一个容器。为了防止误导，演示认证功能前我会把之前创建的私有仓库容器所有内容删除掉。

###### 7.2.6.1 生成自签名证书

**创建证书存储目录：**

```bash
mkdir -p /root/mydata/registry/certs
```

**生成自签名证书的命令：**

```bash
openssl req -newkey rsa:2048 -nodes -sha256 -keyout /root/mydata/registry/certs/domain.key -x509 -days 365 -out /root/mydata/registry/certs/domain.crt
```

- `openssl req`：创建证书签名请求等功能；
- `-newkey`：创建CSR证书签名文件和RSA私钥文件；
- `rsa:2048`：指定创建的RSA私钥长度为2048；
- `-nodes`：对私钥不进行加密；
- `-sha256`：使用SHA256算法；
- `-keyout`：用于指定创建私钥文件的名称及位置；
- `-x509`：自签发证书格式；
- `-days`：用于指定证书有效期(默认以天为单位)；
- `-out`：用于指定CSR输出文件的名称及位置。

执行生成自签名证书的命令后会需要填写一些证书信息，别的都可以随便填，但是`Common Name`这里不能乱填，这里填写的是私有仓库的地址。

```bash
[root@centos mydata]# openssl req -newkey rsa:2048 -nodes -sha256 -keyout /root/mydata/registry/certs/domain.key -x509 -days 365 -out /root/mydata/registry/certs/domain.crt
Generating a 2048 bit RSA private key
.....................................................................+++
..+++
writing new private key to '/root/mydata/registry/certs/domain.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:ZJ
Locality Name (eg, city) [Default City]:HZ
Organization Name (eg, company) [Default Company Ltd]:test
Organizational Unit Name (eg, section) []:testhelloworld
Common Name (eg, your name or your server's hostname) []:192.168.68.12
Email Address []:gongcqq@163.com
[root@centos mydata]# 
```

![image-20210220143500036](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220143502.png)  

###### 7.2.6.2 生成鉴权密码文件

```bash
#创建存储鉴权密码文件的目录
mkdir -p /root/mydata/registry/auth
#安装httpd，如果有的话就不用安装了
yum install -y httpd
#生成鉴权密码文件(下面的root是用户名，1234是密码)
htpasswd -Bbn root 1234 > /root/mydata/registry/auth/htpasswd
```

![image-20210220144202065](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220144216.png) 

> htpasswd是apache http的基本认证文件，使用htpasswd命令可以生成鉴权密码文件。

###### 7.2.6.3 创建带认证功能的私有仓库容器

**运行容器：**

```bash
docker run -di --name registry -p 5000:5000 \
-v /root/mydata/docker_registry:/var/lib/registry \
-v /root/mydata/registry/certs:/certs \
-v /root/mydata/registry/auth:/auth \
-e "REGISTRY_AUTH=htpasswd" \
-e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \
-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
-e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
registry
```

![image-20210220151810307](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220151812.png) 

###### 7.2.6.3 验证私有仓库容器的认证功能

可以通过以下步骤进行验证：

- 现在这个私有仓库容器运行后，没加认证功能前的那个[地址](http://192.168.68.12:5000/v2/_catalog)已经不能访问了(符合带认证功能的私有仓库的特点)；
- 使用`docker push`命令上传镜像到私有仓库也上传不上去了，而且报错信息是**no basic auth credentials**(没有基本身份验证凭据)；

![image-20210220152402964](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220153446.png) 

- 登录之后再试试镜像是否可以上传。这里使用`docker login 192.168.68.12:5000`命令进行登录，登录的时候要带上私有仓库的地址和端口，如果直接使用`docker login`命令登录的话，就登录到公共仓库了；

![image-20210220153133685](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220153135.png) 

- 上一步已经登录成功了，再次尝试上传镜像，发现可以上传成功，说明认证功能确实生效了；

![image-20210220153901768](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220153932.png) 

- 我们也可以到挂载目录下查看镜像是否上传成功，有我们上传的镜像，说明确实是没问题的；

![image-20210220154540182](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220154543.png) 

- 如果我们想要退出账号，可以使用`docker logout 192.168.68.12:5000`命令。退出账号后，就无法再往私有仓库上传镜像文件了。

![image-20210220161321399](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220184524.png) 

#### 7.3 harbor仓库的使用

私有镜像仓库的搭建还可以通过Harbor实现，Harbor是由VMware公司开源的企业级Docker Registry管理项目，它包括权限管理(RBAC)、LDAP、日志审核、管理界面、自我注册、镜像复制和中文支持等功能。

##### 7.3.1 下载

```shell
#先创建一个目录，用于存放下载后的压缩包
mkdir -p /root/docker
#进入到创建好的目录
cd /root/docker
#下载harbor压缩包
wget https://github.com/goharbor/harbor/releases/download/v2.0.6/harbor-offline-installer-v2.0.6.tgz
```

![image-20210222223441698](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222223718.png) 

##### 7.3.2 解压

```shell
tar -zxvf harbor-offline-installer-v2.0.6.tgz
```

![image-20210222223709456](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222223726.png) 

##### 7.3.3 重命名harbor.yml.tmpl

```shell
#进入解压后的目录
cd /root/docker/harbor
#进行文件重命名
mv harbor.yml.tmpl harbor.yml
```

![image-20210222224107241](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222224109.png) 

##### 7.3.4 修改harbor.yml文件

```shell
vim harbor.yml
```

主要修改了如下几项内容，以下是修改前后的对比。

- **修改前：**

![image-20210222230955582](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222231010.png) 

- **修改后：**

![image-20210222231340706](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222231343.png) 

##### 7.3.5 修改daemon.json文件

```shell
vim /etc/docker/daemon.json
```

在文件中加入以下内容并保存退出：

```json
{"insecure-registries":["192.168.68.12:8085"]}
```

**注意**：修改完daemon.json文件后记得使用`systemctl restart docker`命令重启下docker。

##### 7.3.6 启动harbor

```shell
#执行以下命令的前提是已经进入到”/root/docker/harbor“目录下了
./install.sh
```

![image-20210222233430946](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222233433.png) 

![image-20210222233808895](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222233811.png) 

> **注意**：在启动harbor之前，必须安装并启动docker，还要安装好docker-compose，关于docker-compose的下载安装，下面会有介绍。

##### 7.3.7 登录harbor界面

浏览器输入之前在harbor.yml文件中设置的IP和端口进行登录即可，登录的用户名是`admin`，密码就是在harbor.yml文件中设置的密码，没设置的话，默认是`Harbor12345`。

![image-20210222234313114](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222234316.png) 

![image-20210222234409695](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222234413.png) 

##### 7.3.8 上传镜像到harbor

登录到harbor界面后，会有一个默认的`library`项目，我们就不用这个默认的啦，自己新建一个进行测试。

- 新建项目；

![image-20210222234731124](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210222234802.png) 

- 上传镜像到harbor仓库；

```shell
#从公共仓库拉取一个测试使用的镜像
docker pull busybox
#给镜像打个标签
docker tag busybox 192.168.68.12:8085/gongsl/busybox:1.0
#登录到harbor
docker login 192.168.68.12:8085
#上传镜像到harbor仓库
docker push 192.168.68.12:8085/gongsl/busybox:1.0
```

- 进入到harbor界面查看是否上传成功(由以下截图可知，镜像已经上传成功)。

![image-20210223000012679](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210223000227.png) 

### 8.Docker的网络

#### 8.1 默认网络

安装好Docker之后，会默认创建三种网络，可以使用`docker network ls`命令进行查看。

```bash
[root@centos ~]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
7c74f6e25ca6   bridge    bridge    local
5ff2819b1e79   host      host      local
3c2bd7b7cc2c   none      null      local
```

在学习网络模式之前，先了解一下docker中几种常见网络模式的含义：

| 网络模式  | 简介                                                         |
| --------- | ------------------------------------------------------------ |
| bridge    | 为每个容器分配、设置IP等，并将容器连接到一个`docker0`虚拟网桥，默认情况下使用该模式。 |
| host      | 容器不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 |
| none      | 容器有独立的网络名称空间，但并没有对其进行任何网络设置。     |
| container | 新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等。 |

##### 8.1.1 bridge网络模式

在该模式中，Docker守护进程创建了一个虚拟以太网桥`docker0`，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。

默认情况下，守护进程会创建一对对等虚拟设备接口`veth pair`，将其中一个接口设置为容器的`eth0`接口(容器的网卡)，另一个接口放置在宿主机的命名空间中，以类似`vethxxx`这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。

比如我运行一个基于`busybox`镜像构建的容器`bbox01`，查看`ip addr`：

> busybox被称为嵌入式Linux的瑞士军刀，整合了很多小的unix下的通用功能到一个小的可执行文件中。

![image-20210220165943530](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220165951.png) 

然后宿主机通过`ip addr`查看信息如下：

![image-20210220170034751](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170039.png) 

通过以上的比较可以发现，证实了之前所说的：守护进程会创建一对对等虚拟设备接口 `veth pair`，将其中一个接口设置为容器的 `eth0` 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 `vethxxx` 这样的名字命名。

同时，守护进程还会从网桥 `docker0` 的私有地址空间中分配一个IP地址和子网给该容器，并设置`docker0`的IP地址为容器的默认网关。也可以安装 `yum install -y bridge-utils` 以后，通过 `brctl show` 命令查看网桥信息。

![image-20210220170227120](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170229.png) 

对于每个容器的IP地址和Gateway信息，我们可以通过`docker inspect 容器名称|ID`进行查看，在`NetworkSettings`节点中可以看到详细信息。

![image-20210220170403405](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170406.png) 

我们可以通过 `docker network inspect bridge` 查看所有 `bridge` 网络模式下的容器，在 `Containers` 节点中可以看到容器名称。

![image-20210220170449073](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170451.png) 

> 关于 `bridge` 网络模式的使用，只需要在创建容器时通过参数 `--net bridge` 或者 `--network bridge` 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。

![image-20210220170600629](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170603.png) 

`Bridge`桥接模式的实现步骤主要如下：

- Docker Daemon利用`veth pair`技术，在宿主机上创建一对对等虚拟网络接口设备，假设为veth0和veth1。而veth pair技术的特性可以保证无论哪一个veth接收到网络报文，都会将报文传输给另一方。
- Docker Daemon将veth0附加到Docker Daemon创建的docker0网桥上。保证宿主机的网络报文可以发往veth0；
- Docker Daemon将veth1添加到Docker Container所属的namespace下，并被改名为eth0。如此一来，宿主机的网络报文若发往veth0，则立即会被Container的eth0接收，实现宿主机到Docker Container网络的联通性；同时也保证Docker Container单独使用eth0，实现容器网络环境的隔离性。

##### 8.1.2 host网络模式

- host网络模式需要在使用`docker run`命令创建容器时通过参数`--net host`或者`--network host`指定；
- 采用host网络模式的 Docker Container，可以直接使用宿主机的IP地址与外界进行通信，若宿主机的eth0是一个公有IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行NAT转换；
- host网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。

![image-20210220172651653](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172654.png) 

比如我基于`host`网络模式创建了一个基于`busybox`镜像构建的容器`bbox02`，查看`ip addr`：

![image-20210220171714666](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220171730.png) 

然后宿主机通过`ip addr`查看信息如下：

![image-20210220171820751](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220171822.png) 

可以发现，返回的信息一模一样。我们也可以通过`docker network inspect host`查看所有`host`网络模式下的容器，在`Containers`节点中可以看到容器名称。

![image-20210220172007088](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172013.png) 

##### 8.1.3 none网络模式

- `none`网络模式是指禁用网络功能，只有lo接口(local的简写)，代表127.0.0.1，即localhost本地环回接口。可以在创建容器时通过参数`--net none`或者`--network none`指定使用该模式；
- `none`网络模式即不为Docker Container创建任何的网络环境，容器内部就只能使用loopback网络设备，不会再有其他的网络资源。可以说none模式为Docke Container做了极少的网络设定，但是俗话说得好“少即是多”，在没有网络配置的情况下，作为Docker开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了Docker设计理念的开放。

比如使用`none`网络模式创建一个基于`busybox`镜像构建的容器`bbox03`，查看`ip addr`：

![image-20210220172429451](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172436.png) 

我们可以通过`docker network inspect none`查看所有`none`网络模式下的容器，在`Containers`节点中可以看到容器名称。

![image-20210220172529999](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172535.png) 

##### 8.1.4 container网络模式

- Container网络模式是Docker中一种较为特别的网络的模式。在创建容器时通过参数`--net container:已运行的容器名称|ID`或者`--network container:已运行的容器名称|ID`指定；
- 处于这个模式下的Docker容器会共享一个网络栈，这样两个容器之间可以使用localhost高效快速通信。

![905bc2](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174012.jpg) 

**`Container`网络模式即新创建的容器不会创建自己的网卡、配置自己的IP，而是和一个指定的容器共享IP、端口范围等**。两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。

比如我基于容器`bbox01`创建了`container`网络模式的容器`bbox04`，查看`ip addr`：

![image-20210220174315134](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174318.png) 

容器`bbox01`的`ip addr`信息如下：

![image-20210220174356258](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174358.png) 

宿主机的`ip addr`信息如下：

![image-20210220174425548](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174428.png) 

通过以上测试可以发现，Docker守护进程只创建了一对对等虚拟设备接口用于连接bbox01容器和宿主机，而bbox04容器则直接使用了bbox01容器的网卡信息。

这个时候如果将bbox01容器停止，会发现bbox04容器就只剩下lo接口了。

![image-20210220174519549](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174523.png) 

然后bbox01容器重启以后，bbox04容器也重启一下，就又可以获取到网卡信息了。

![image-20210220174600177](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174602.png) 

#### 8.2 自定义网络

虽然Docker提供的默认网络使用比较简单，但是为了保证各容器中应用的安全性，在实际开发中更推荐使用自定义的网络进行容器管理，以及启用容器名称到IP地址的自动DNS解析。

> 从Docker 1.10版本开始，docker daemon实现了一个内嵌的DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用`--name`为容器命名即可。
>
> 但是使用Docker DNS有个限制：**只能在user-defined网络中使用**。也就是说，默认的bridge网络是无法使用DNS的，所以我们就需要自定义网络。

##### 8.2.1 创建网络

我们可以通过`docker network create`命令创建自定义网络模式，通过命令使用详情发现，可以通过`-d`指定网络模式且默认是`bridge`网络模式。

![image-20210220181039241](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220181041.png) 

那么如果我们创建一个基于`bridge`网络模式的自定义网络模式`custom_network`的话，完整命令就是下面这样：

```bash
docker network create custom_network
```

可以通过`docker network ls`命令查看网络模式：

![image-20210220181346101](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220181350.png) 

通过自定义网络模式`custom_network`创建容器：

```bash
docker run -di --name bbox01 --net custom_network busybox
```

![image-20210220181711320](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220181713.png) 

通过`docker inspect 容器名称|ID`查看容器的网络信息，在`NetworkSettings`节点中可以看到详细信息。

![image-20210220182239790](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220182241.png) 

##### 8.2.2 连接网络

通过`docker network connect 网络名称 容器名称`为容器连接新的网络模式，比如：

```bash
docker network connect bridge bbox01
```

通过`docker inspect 容器名称|ID`再次查看容器的网络信息，发现多增加了默认的`bridge`。

![image-20210220184440656](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220184457.png) 

##### 8.2.3 断开网络

通过`docker network disconnect 网络名称 容器名称`命令断开网络，比如：

```bash
docker network disconnect custom_network bbox01
```

通过`docker inspect 容器名称|ID`再次查看容器的网络信息，发现只剩下默认的`bridge`了。

![image-20210220185053224](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220185055.png) 

##### 8.2.4 移除网络

可以通过`docker network rm 网络名称`命令移除自定义网络模式，比如：

```bash
docker network rm custom_network
```

移除网络后再使用`docker network ls`命令查看，发现custom_network网络模式已经不存在了，说明移除成功了。

![image-20210220185447288](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220185451.png) 


> **注意**：如果通过某个自定义网络模式创建了容器，则该网络模式无法删除。

#### 8.3 容器间的网络通信

**通过容器IP进行容器间的网络通信：**

接下来通过所学的知识实现容器间的网络通信。首先明确一点，`容器之间要互相通信，必须要有属于同一个网络的网卡`。

我们先创建两个基于默认的`bridge`网络模式的容器：

```bash
docker run -di --name default_bbox01 busybox
docker run -di --name default_bbox02 busybox
```

通过`docker network inspect bridge`查看两容器的具体IP信息：

![image-20210220191328514](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220191332.png) 

然后测试两容器间是否可以进行网络通信：

![image-20210220192510396](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220192514.png) 

![image-20210220192835923](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220192839.png) 

经过测试，从结果得知两个属于同一个网络的容器是可以进行网络通信的，但是IP地址可能是不固定的，有被更改的情况发生，那容器内所有通信的IP地址也需要进行更改，能否使用容器名称进行网络通信？继续测试。

![image-20210220195337494](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220195343.png) 

由上图可知，使用容器名称进行网络通信是不行的，接下来就是实现通过容器名称进行通信。

**使用容器名称进行容器间的网络通信：**

- 先基于`bridge`网络模式创建自定义网络`custom_network`，命令如下：

```bash
docker network create custom_network
```

- 然后创建两个基于自定义网络模式的容器，命令如下：

```bash
docker run -di --name custom_bbox01 --net custom_network busybox
docker run -di --name custom_bbox02 --net custom_network busybox
```

- 通过`docker network inspect custom_network`查看两容器的具体IP信息：

![image-20210220200740370](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220200742.png) 

- 然后测试两容器间是否可以进行网络通信，分别使用**容器IP**和**容器名称**进行网络通信测试，发现都可以通信成功。

![image-20210220201404783](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220201434.png) 

> **结论**：两个属于同一个自定义网络的容器是可以进行网络通信的，不仅可以通过容器IP进行网络通信还可以使用容器名称进行网络通信。

如果此时我们希望`bridge`网络下的容器可以和`custom_network`网络下的容器进行网络通信的话，只要让`bridge`网络下的容器连接到自定义的`custom_network`网络模式即可，比如：

```bash
#先基于默认的bridge网络模式创建一个容器
docker run -di --name default_bbox01 busybox
#然后将这个容器连接到自定义的custom_network网络中
docker network connect custom_network default_bbox01
```

![image-20210220203518964](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220204710.png) 

![image-20210220204707720](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220204720.png) 

### 9.Docker Compose

#### 9.1 Compose简介

Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，我们可以通过YAML文件来配置应用程序的服务。然后，只需要一个命令，就可以从配置中创建并启动所有服务。

使用Compose基本上有三个步骤:

- 用`Dockerfile`定义应用程序的环境，这样它就可以在任何地方运行；
- 在`docker-compose.yml`中定义组成应用程序的服务，这样它们就可以在一个孤立的环境中一起运行；
- 使用`docker-compose up`命令启动Compose并运行我们的整个应用程序。

下面是一个`docker-compose.yml`案例：

```yaml
version: "3.9"  # optional since v1.27.0
services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/code
      - logvolume01:/var/log
    links:
      - redis
  redis:
    image: redis
volumes:
  logvolume01: {}
```

#### 9.2 Compose安装

##### 9.2.1 下载

运行以下命令下载当前稳定版本的Docker Compose：

```bash
sudo curl -L "https://github.com/docker/compose/releases/download/1.28.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```

由于Docker Compose存放在GitHub上，所以网速可能较慢。我们也可以通过执行下面的命令，高速安装Compose。该加速通道由 [DaoCloud](http://get.daocloud.io/#install-compose) 提供：

```shell
curl -L https://get.daocloud.io/docker/compose/releases/download/1.28.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
```

我们也可以通过修改URL中的版本，自定义下载所需要的版本文件。

##### 9.2.2 授权

安装完成以后，查看指定目录，发现该文件没有可执行权限，所以需要进行授权操作。

![image-20210221121439182](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221121656.png) 

```shell
#将可执行权限应用于该二进制文件
chmod +x /usr/local/bin/docker-compose
```

![image-20210221121624643](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221121708.png) 

##### 9.2.3 测试

```shell
docker-compose --version
```

![image-20210221122734084](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221122739.png) 

##### 9.2.4 卸载

卸载`Compose`非常简单，直接删除二进制文件即可。

```shell
sudo rm /usr/local/bin/docker-compose
```

#### 9.3 Compose入门案例

##### 9.3.1 不带Dockerfile文件的案例

- 创建目录：`mkdir -p /usr/local/docker-nginx`；

- 切换至指定目录：`cd /usr/local/docker-nginx/`；

- 编写docker-compose.yml文件：`vim docker-compose.yml`；

文件内容如下：

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  nginx: # 服务名称
    image: nginx:1.19.6 # 创建容器时所需的镜像，不带标签的话，默认是latest
    container_name: mynginx # 容器名称，默认为"工程名称_服务条目名称_序号"
    ports: # 宿主机与容器的端口映射关系
      - "80:80" # 左边宿主机端口:右边容器端口
    networks: # 配置容器连接的网络，引用顶级 networks 下的条目
      - nginx-net

# 定义网络，可以多个。如果不声明，默认会创建一个网络名称为"工程名称_default"的 bridge 网络
networks:
  nginx-net: # 一个具体网络的条目名称
    name: nginx-net # 网络名称，默认为"工程名称_网络条目名称"
    driver: bridge # 网络模式，默认为 bridge
```

- 使用`docker-compose up`命令创建并启动所有服务；

```shell
# 前台启动
docker-compose up
# 后台启动
docker-compose up -d
```

![image-20210221135825734](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221135841.png) 

然后我们也可以在浏览器通过`IP:80`进行访问验证，出现下图就说明nginx运行是没有问题的。

![20210221140137](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221140437.png)  

- 可以使用`docker-compose down`命令停止并删除容器、网络。

![image-20210221141125611](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221141127.png) 

##### 9.3.2 带Dockerfile文件的案例

- 创建目录：`mkdir -p /usr/local/docker-tomcat`；
- 切换至指定目录：`cd /usr/local/docker-tomcat`；
- 编写Dockerfile文件：`vim Dockerfile`；

文件内容如下：

```dockerfile
FROM centos:7
LABEL author="gongsl"
RUN mkdir -p /usr/local/java && mkdir -p /usr/local/tomcat
ADD jdk-8u231-linux-x64.tar.gz /usr/local/java
ADD apache-tomcat-8.5.47.tar.gz /usr/local/tomcat
ENV MYPATH /usr/local
WORKDIR $MYPATH
ENV JAVA_HOME /usr/local/java/jdk1.8.0_231
ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool.jar
ENV CATALINA_HOME /usr/local/tomcat/apache-tomcat-8.5.47
ENV CATALINA_BASE /usr/local/tomcat/apache-tomcat-8.5.47
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
EXPOSE 8080
CMD ["/usr/local/tomcat/apache-tomcat-8.5.47/bin/catalina.sh","run"]
```

- 编写docker-compose.yml文件：`vim docker-compose.yml`；

文件内容如下：

```yaml
version: "3.8"
services:
  mycentos:
    build: . #这个点是相对路径，要Dockerfile文件及其所需的压缩包与docker-compose.yml在一个路径下才行
    image: mycentos:1.0.0 #这个是创建的镜像的名称和标签
    container_name: mycentos7
    ports:
      - "8080:8080"
    networks:
      - tomcat-net

networks:
  tomcat-net:
    name: tomcat-net
    driver: bridge
```

- 将所需的jdk和tomcat的压缩包放到`/usr/local/docker-tomcat`目录下，该目录结构如下所示；

![image-20210221172410659](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221172412.png) 

- 使用`docker-compose up -d`命令创建并后台启动所有服务，然后使用`curl`命令进行验证，能够返回tomcat的页面信息，说明tomcat启动成功了；

![image-20210221172323259](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221172325.png) 

- 最后可以使用`docker-compose down`命令停止并删除容器、网络。

#### 9.4 docker-compose.yml文件详解

Docker Compose允许用户通过`docker-compose.yml`文件来定义一组相关联的容器为一个工程`（project）`。一个工程包含多个服务`（service）`，每个服务中定义了创建容器时所需的镜像、参数、依赖等。

> 工程名若无特殊指定，即为`docker-compose.yml`文件所在目录的名称。

Docker Compose模板文件我们需要关注的顶级配置有`version`、`services`、`networks`、`volumes`几个部分，除`version`外，其他几个顶级配置下还有很多下级配置，后面也会详细介绍，先来看看这几个顶级配置都什么意思：

- `version`：描述Compose文件的版本信息，当前最新版本为`3.8`，对应的Docker版本为`19.03.0+`；
- `services`：定义服务，可以多个，每个服务中定义了创建容器时所需的镜像、参数、依赖等；
- `networks`：定义网络，可以多个，根据DNS server让相同网络中的容器可以直接通过容器名称进行通信；
- `volumes`：数据卷，用于实现目录挂载。

##### 9.4.1 version

描述Compose文件的版本信息，当前最新版本为`3.8`，对应的Docker版本为`19.03.0+`。关于每个版本的详细信息请参考[官网](https://docs.docker.com/compose/compose-file/compose-versioning/)。以下为Compose文件的版本信息所对应的Docker版本：

| Compose file format | Docker Engine release |
| :------------------ | :-------------------- |
| 3.8                 | 19.03.0+              |
| 3.7                 | 18.06.0+              |
| 3.6                 | 18.02.0+              |
| 3.5                 | 17.12.0+              |
| 3.4                 | 17.09.0+              |
| 3.3                 | 17.06.0+              |
| 3.2                 | 17.04.0+              |
| 3.1                 | 1.13.1+               |
| 3.0                 | 1.13.0+               |
| 2.4                 | 17.12.0+              |
| 2.3                 | 17.06.0+              |
| 2.2                 | 1.13.0+               |
| 2.1                 | 1.12.0+               |
| 2.0                 | 1.10.0+               |
| 1.0                 | 1.9.1.+               |

##### 9.4.2 services

刚才我们提到 `docker-compose.yml` 文件中包含很多下级配置项，下面就把一些常用的配置项详细了解一下，先从顶级配置`services`开始。

这个`services`是用来定义服务的，可以多个，每个服务中定义了创建容器时所需的镜像、参数、依赖等，就像将命令行参数传递给`docker run`一样。同样，网络和数据卷的定义也是一样的。

比如，我们通过`docker run`命令构建一个 MySQL 应用容器的命令如下：

```shell
docker run -di --name mysql8 -p 3306:3306 -v /mydata/docker_mysql/conf:/etc/mysql/conf.d -v /mydata/docker_mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234 mysql:8
```

使用`docker-compose.yml`以后则可以这样定义：

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  mysql: # 服务名称
    image: mysql:8 # 创建容器时所需的镜像
    container_name: mysql8 # 容器名称，默认为"工程名称_服务条目名称_序号"
    ports: # 宿主机与容器的端口映射关系
      - "3306:3306" # 左边宿主机端口:右边容器端口
    environment: # 创建容器时所需的环境变量
      MYSQL_ROOT_PASSWORD: 1234
    volumes:
      - "/mydata/docker_mysql/conf:/etc/mysql/conf.d"
      - "/mydata/docker_mysql/data:/var/lib/mysql"
```

然后通过`dokcer-compose`相关命令即可完成容器的创建，停止或删除等一系列操作。

###### 9.4.2.1 image

用于指定创建容器时所需的`镜像名称标签`或者`镜像ID`。如果镜像在本地不存在，会去远程拉取，比如：

```yaml
services:
  web:
    image: hello-world
```

###### 9.4.2.2 build

除了可以基于指定的镜像构建容器，还可以基于`Dockerfile`文件构建，在使用`docker-compose up`命令时会执行构建任务。通过**build**配置项可以指定`Dockerfile`所在文件夹的路径。Compose将会利用`Dockerfile`自动构建镜像，然后使用镜像启动服务容器。**build**配置项可以使用绝对路径，也可以使用相对路径:

```yaml
# 绝对路径，在该路径下基于名称为Dockerfile的文件构建镜像
version: "3.8"
services:
  mycentos:
    build: /usr/local/docker-centos
    container_name: mycentos7

# 相对路径，相对当前docker-compose.yml文件所在目录，基于名称为Dockerfile的文件构建镜像
version: "3.8"
services:
  mycentos:
    build: .
    container_name: mycentos7
```

在`build`配置项下面还可以使用`context`配置项和`dockerfile`配置项。

假设Compose是基于Dockerfile文件构建容器，而Dockerfile文件的文件名不是**Dockerfile**，而是**Dockerfile1**的话，那就可以使用下面这种方式：

```yaml
build:
  context: . #context配置项用于指定路径，这里用的是相对路径
  dockerfile: Dockerfile1 #dockerfile配置项用于指定Dockerfile文件的文件名
```

###### 9.4.2.3 container_name

Compose创建的容器默认生成的名称格式为：`工程名称_服务条目名称_序号`。如果要自定义名称，使用`container_name`声明即可，比如：

```yaml
services:
  mycentos:
    build: .
    container_name: mycentos7 # 容器名称，默认为"工程名称_服务条目名称_序号"
```

> 因为Docker容器名称必须是唯一的，所以如果指定了自定义名称，就不能将服务扩展至多个容器。这样做可能会导致错误。

###### 9.4.2.4 关于序号

序号是干什么用的呢，看下面这个例子就懂了，`docker-compose.yml`文件内容如下：

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  helloworld: # 服务名称
    image: hello-world
```

然后通过`--scale`指定`helloworld`服务一次性启动3个。

```shell
docker-compose up -d --scale helloworld=3
```

通过下图可以看到有3个容器被创建，容器名称最后的**序号**是从1开始累加的，这就是序号的作用。所以如果指定了自定义名称，就不能将服务扩展至多个容器。

![image-20210221201149977](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221201152.png) 

###### 9.4.2.5 depends_on

使用 Compose 最大的好处就是敲最少的命令做更多的事情，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没有启动数据库容器的情况下启动了 Web 应用容器，应用容器会因为找不到数据库而退出。`depends_on` 就是用来解决容器依赖、启动先后问题的配置项。

```yaml
version: "3.8"
services:
  web:
    build: .
    depends_on:
      - db
      - redis
  redis:
    image: redis
  db:
    image: mysql
```

上述yaml文件定义的容器会先启动`db`和`redis`两个服务，最后才启动`web`服务。

###### 9.4.2.6 ports

容器对外暴露的端口，格式：`左边宿主机端口:右边容器端口`。

```yaml
ports:
  - "80:80"
  - "8080:8080"
```

###### 9.4.2.7 expose

容器暴露的端口不映射到宿主机，只允许能被连接的服务访问。

```yaml
expose:
  - "80"
  - "8080"
```

###### 9.4.2.8 restart

指的是容器的重启策略，简单的理解就是Docker重启以后容器要不要一起启动：

- `no`：默认的重启策略，在任何情况下都不会重启容器；
- `on-failure`：容器非正常退出时，比如退出状态为`非0`(异常退出)，才会重启容器；
- `always`：容器总是重新启动，即使容器被手动停止了，当Docker重启时容器也还是会一起启动；
- `unless-stopped`：容器总是重新启动，除非容器被停止(手动或其他方式)，那么Docker重启时容器则不会启动。

案例如下：

```yaml
services:
  nginx:
    image: nginx
    container_name: mynginx
    ports:
      - "80:80"
    restart: always
```

###### 9.4.2.9 environment

添加环境变量。可以使用数组也可以使用字典。布尔相关的值（true、false、yes、no）都需要用引号括起来，以确保YML解析器不会将它们转换为真或假。

```yaml
environment:
  RACK_ENV: development
  SHOW: 'true'
  SESSION_SECRET:
```

或者以下格式：

```yaml
environment:
  - RACK_ENV=development
  - SHOW=true
  - SESSION_SECRET
```

###### 9.4.2.10 env_file

从文件中获取环境变量，可以指定一个或多个文件，其优先级低于environment指定的环境变量。

```yaml
env_file:
  - /opt/runtime_opts.env # 绝对路径
  - ./common.env # 相对路径，相对当前 docker-compose.yml 文件所在目录
  - ./apps/web.env # 相对路径，相对当前 docker-compose.yml 文件所在目录
```

> 注意：env文件(比如web.env)中的每一行需采用 `键=值` 格式。以 `#` 开头的行会被视为注释并被忽略。空行也会被忽略。

###### 9.4.2.11 command

覆盖容器启动后默认执行的命令。

```yaml
command: echo "helloworld"
```

也可以是一个列表:

```yaml
command: ["echo", "helloworld"]
```

###### 9.4.2.12 volumes

数据卷，用于实现目录挂载，支持**指定目录挂载**、**匿名挂载**、**具名挂载**。

- 指定目录挂载的格式为：`左边宿主机目录:右边容器目录`，或者`左边宿主机目录:右边容器目录:读写权限`；
- 匿名挂载格式为：`容器目录即可`，或者`容器目录即可:读写权限`；
- 具名挂载格式为：`数据卷条目名称:容器目录`，或者`数据卷条目名称:容器目录:读写权限`。

案例如下：

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  mysql: # 服务名称
    image: mysql:8 # 创建容器时所需的镜像
    container_name: mysql8 # 容器名称，默认为"工程名称_服务条目名称_序号"
    ports: # 宿主机与容器的端口映射关系
      - "3306:3306" # 左边宿主机端口:右边容器端口
    environment: # 创建容器时所需的环境变量
      MYSQL_ROOT_PASSWORD: 1234
    volumes:
      # 绝对路径
      - "/mydata/docker_mysql/data:/var/lib/mysql"
      # 相对路径，相对当前 docker-compose.yml 文件所在目录
      - "./conf:/etc/mysql/conf.d"
      # 匿名挂载，匿名挂载只需要写容器目录即可，容器外对应的目录会在 /var/lib/docker/volume 中生成
      - "/var/lib/mysql"
      # 具名挂载，就是给数据卷起了个名字，容器外对应的目录会在 /var/lib/docker/volume 中生成
      - "mysql-data-volume:/var/lib/mysql"

# 定义数据卷，可以多个
volumes:
  mysql-data-volume: # 一个具体数据卷的条目名称
    name: mysql-data-volume # 数据卷名称，默认为"工程名称_数据卷条目名称"
```

###### 9.4.2.13 network_mode

设置网络模式，类似 `docker run` 时添加的参数 `--net host` 或者 `--network host` 的用法。

```yaml
network_mode: "bridge"
network_mode: "host"
network_mode: "none"
network_mode: "service:[service name]"
network_mode: "container:[container name/id]"
```

###### 9.4.2.14 networks

配置容器连接的网络，引用顶级networks下的条目。

```yaml
# 定义服务，可以多个
services:
  nginx: # 服务名称
    networks: # 配置容器连接的网络，引用顶级 networks 下的条目
      - nginx-net # 一个具体网络的条目名称

# 定义网络，可以多个。如果不声明，默认会创建一个网络名称为"工程名称_default"的 bridge 网络
networks:
  nginx-net: # 一个具体网络的条目名称
    name: nginx-net # 网络名称，默认为"工程名称_网络条目名称"
    driver: bridge # 网络模式，默认为 bridge
```

###### 9.4.2.15 aliases

网络上此服务的别名。同一网络上的其他容器可以使用服务名或此别名连接到服务容器。同一服务在不同的网络上可以具有不同的别名。

```yaml
# 定义服务，可以多个
services:
  nginx: # 服务名称
    networks: # 配置容器连接的网络，引用顶级 networks 下的条目
      nginx-net: # 一个具体网络的条目名称
        aliases: # 服务别名，可以多个
          - nginx1 # 同一网络上的其他容器可以使用服务名或此别名连接到服务容器

# 定义网络，可以多个。如果不声明，默认会创建一个网络名称为"工程名称_default"的 bridge 网络
networks:
  nginx-net: # 一个具体网络的条目名称
    name: nginx-net # 网络名称，默认为"工程名称_网络条目名称"
    driver: bridge # 网络模式，默认为 bridge
```

##### 9.4.3 volumes

这个是顶级配置`volumes`，不是顶级配置`services`下的`volumes`。

以下方式的数据卷声明创建卷时会使用默认的名称：`"工程名称_数据卷条目名称"`。

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  mysql:
    image: mysql:8
    container_name: mysql8
    ports:
      - "3306:3306"
    environment
      MYSQL_ROOT_PASSWORD: 1234
    volumes:
      # 具名挂载，就是给数据卷起了个名字，容器外对应的目录会在 /var/lib/docker/volume 中生成
      - "mysql-data-volume:/var/lib/mysql"

# 定义数据卷，可以多个
volumes:
  mysql-data-volume: # 一个具体数据卷的条目名称
```

![image-20210221211537219](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221211539.png) 

以下方式的数据卷声明创建卷时会使用自定义的名称。

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  mysql:
    image: mysql:8
    container_name: mysql8
    ports:
      - "3306:3306"
    environment
      MYSQL_ROOT_PASSWORD: 1234
    volumes:
      # 具名挂载，就是给数据卷起了个名字，容器外对应的目录会在 /var/lib/docker/volume 中生成
      - "mysql-data-volume:/var/lib/mysql"

# 定义数据卷，可以多个
volumes:
  mysql-data-volume: # 一个具体数据卷的条目名称
    name: mysql-data-volume # 数据卷名称，默认为"工程名称_数据卷条目名称"
```

##### 9.4.4 networks

这个是顶级配置`networks`，不是顶级配置`services`下的`networks`。

如果不声明网络，每个工程默认会创建一个网络名称为`"工程名称_default"`的`bridge`网络。

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  nginx:
    image: nginx
    container_name: mynginx
    ports:
      - "80:80"

# 定义网络，可以多个。如果不声明，默认会创建一个网络名称为"工程名称_default"的 bridge 网络
#networks:
```

![image-20210221212516291](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221212518.png) 

以下方式的网络声明创建网络时会使用默认的名称：`"工程名称_网络条目名称"`，网络模式默认为`bridge`。

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  nginx:
    image: nginx
    container_name: mynginx
    ports:
      - "80:80"
    networks: # 配置容器连接的网络，引用顶级 networks 下的条目
      nginx-net:

# 定义网络，可以多个
networks:
  nginx-net: # 一个具体网络的条目名称
```

![image-20210221214646302](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221214651.png) 

以下方式的网络声明创建网络时会使用自定义的名称，还可以通过 `driver` 选择网络模式，默认为 `bridge`。

```yaml
# 描述 Compose 文件的版本信息
version: "3.8"
# 定义服务，可以多个
services:
  nginx:
    image: nginx
    container_name: mynginx
    ports:
      - "80:80"
    networks: # 配置容器连接的网络，引用顶级 networks 下的条目
      nginx-net:

# 定义网络，可以多个
networks:
  nginx-net: # 一个具体网络的条目名称
    name: nginx-net # 网络名称，默认为"工程名称_网络条目名称"
    driver: bridge # 网络模式，默认为 bridge
```

![image-20210221214713340](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221214715.png) 

#### 9.5 Compose常用命令

**用法：**

```shell
docker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]
```

**部分命令选项如下：**

- `-f，--file`：指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定，指定多个yml；
- `-p, --project-name`：指定工程名称，默认使用 `docker-compose.yml` 文件所在目录的名称；
- `-v`：打印版本并退出；
- `--log-level`：定义日志等级（DEBUG, INFO, WARNING, ERROR, CRITICAL）。

##### 9.5.1 docker-compose config

`docker-compose config -q` 验证`docker-compose.yml`文件。当配置正确时，不输出任何内容，当配置错误时，输出错误信息。

##### 9.5.2 docker-compose pull

`docker-compose pull` 拉取服务依赖的镜像。

```shell
# 拉取工程中所有服务依赖的镜像
docker-compose pull
# 拉取工程中 nginx 服务依赖的镜像
docker-compose pull nginx
# 拉取镜像过程中不打印拉取进度信息
docker-compose pull -q
```

##### 9.5.3 docker-compose up

`docker-compose up` 创建并启动所有服务的容器。指定多个 yml 加 `-f` 选项。以守护进程模式运行加 `-d` 选项。

```shell
# 前台启动
docker-compose up
# 后台启动
docker-compose up -d
# -f 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定，指定多个 yml
docker-compose -f docker-compose.yml up -d 
```

##### 9.5.4 docker-compose logs

`docker-compose logs` 查看服务容器的输出日志。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 `--no-color` 来关闭颜色。

```shell
# 输出日志，不同的服务输出使用不同的颜色来区分
docker-compose logs
# 跟踪日志输出
docker-compose logs -f
# 关闭颜色
docker-compose logs --no-color
```

##### 9.5.5 docker-compose ps

`docker-compose ps` 列出工程中所有服务的容器。

```shell
# 列出工程中所有服务的容器
docker-compose ps
# 列出工程中指定服务的容器
docker-compose ps nginx
```

##### 9.5.6 docker-compose run

`docker-compose run` 在指定服务容器上执行一个命令。

```shell
# 在工程中指定服务的容器上执行 echo "helloworld"
docker-compose run nginx echo "helloworld"
```

##### 9.5.7 docker-compose exec

`docker-compose exec` 进入服务容器。

```shell
# 进入工程中指定服务的容器
docker-compose exec nginx bash
# 当一个服务拥有多个容器时，可通过 --index 参数进入到该服务下的任何容器
docker-compose exec --index=1 nginx bash
```

##### 9.5.8 docker-compose pause

`docker-compose pause` 暂停服务容器。

```shell
# 暂停工程中所有服务的容器
docker-compose pause
# 暂停工程中指定服务的容器
docker-compose pause nginx
```

##### 9.5.9 docker-compose unpause

`docker-compose unpause` 恢复服务容器。

```shell
# 恢复工程中所有服务的容器
docker-compose unpause
# 恢复工程中指定服务的容器
docker-compose unpause nginx
```

##### 9.5.10 docker-compose restart

`docker-compose restart` 重启服务容器。

```shell
# 重启工程中所有服务的容器
docker-compose restart
# 重启工程中指定服务的容器
docker-compose restart nginx
```

##### 9.5.11 docker-compose start

`docker-compose start` 启动服务容器。

```shell
# 启动工程中所有服务的容器
docker-compose start
# 启动工程中指定服务的容器
docker-compose start nginx
```

##### 9.5.12 docker-compose stop

`docker-compose stop` 停止服务容器。

```shell
# 停止工程中所有服务的容器
docker-compose stop
# 停止工程中指定服务的容器
docker-compose stop nginx
```

##### 9.5.13 docker-compose kill

`docker-compose kill` 通过发送 `SIGKILL` 信号停止指定服务的容器。

```shell
# 通过发送 SIGKILL 信号停止工程中指定服务的容器
docker-compose kill nginx
```

##### 9.5.14 docker-compose rm

`docker-compose rm` 删除服务（停止状态）容器。

```shell
# 删除所有（停止状态）服务的容器
docker-compose rm
# 先停止所有服务的容器，再删除所有服务的容器
docker-compose rm -s
# 不询问是否删除，直接删除
docker-compose rm -f
# 删除服务容器挂载的数据卷
docker-compose rm -v
# 删除工程中指定服务的容器
docker-compose rm -sv nginx
```

##### 9.5.15 docker-compose down

`docker-compose down`停止并删除所有服务的容器、网络、镜像、数据卷。

```shell
# 停止并删除工程中所有服务的容器、网络
docker-compose down
# 停止并删除工程中所有服务的容器、网络、镜像
docker-compose down --rmi all
# 停止并删除工程中所有服务的容器、网络、数据卷
docker-compose down -v
```

##### 9.5.16 ~~docker-compose create~~

`docker-compose create` 为服务创建容器，已不推荐使用。推荐使用 `docker-compose up` 来实现该功能。

![image-20210221220928016](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221220953.png) 

![image-20210221220948346](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221220957.png) 

##### 9.5.17 ~~docker-compose scale~~

`docker-compose scale` 设置指定服务运行的容器个数，已不推荐使用。

![image-20210221221213080](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221221300.png) 

![image-20210221221248321](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221221308.png) 

推荐使用 `--scale service=num` 的参数来设置数量。

```shell
# 通过 --scale 指定 helloworld 服务一次性启动 3 个
docker-compose up -d --scale helloworld=3
```

##### 9.5.18 docker-compose images

`docker-compose images` 打印服务容器所对应的镜像。

```shell
# 打印所有服务的容器所对应的镜像
docker-compose images
# 打印指定服务的容器所对应的镜像
docker-compose images nginx
```

##### 9.5.19 docker-compose port

`docker-compose port` 打印指定服务容器的某个端口所映射的宿主机端口。

```shell
[root@localhost docker-nginx]# docker-compose port nginx 80
0.0.0.0:80
```

##### 9.5.20 docker-compose top

`docker-compose top` 显示正在运行的进程。

```shell
# 显示工程中所有服务的容器正在运行的进程
docker-compose top
# 显示工程中指定服务的容器正在运行的进程
docker-compose top nginx
```

![image-20210221221712221](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210221221715.png) 

