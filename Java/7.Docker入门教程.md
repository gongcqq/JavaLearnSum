### 1.在CentOS上安装docker

如果之前安装过旧版本的docker，记得要先卸载，命令如下：

```bash
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```

#### 1.1 设置yum源

安装`yum-utils`软件包(提供`yum-config-manager`程序)并设置yum源为阿里云以便方便下载Docker Engine：

```bash
#安装yum-utils
sudo yum install -y yum-utils

#设置yum源为阿里云
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

#### 1.2 Docker的安装

安装最新版的Docker Engine和容器：

```bash
sudo yum install docker-ce docker-ce-cli containerd.io
```

安装时如果提示接受GPG密钥，请验证指纹是否匹配`060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`，如果匹配，继续安装即可。这个是用于检测安装包是否被篡改的，没有被篡改的话就说明我们安装的是安全的。

![image-20210215122150780](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210215122707.png) 

#### 1.3 Docker的启动与停止

```bash
#启动docker
sudo systemctl start docker

#停止docker
sudo systemctl stop docker

#重启docker
sudo systemctl restart docker

#设置开机启动
sudo systemctl enable docker

#查看docker状态
sudo systemctl status docker

#查看docker内容器的运行状态
sudo docker stats

#查看docker概要信息
sudo docker info

#查看docker帮助文档
sudo docker --help
```

#### 1.4 查看docker版本信息

```bash
[root@centos ~]# docker -v
Docker version 20.10.3, build 48d30b5
[root@centos ~]# docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:32:37 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
[root@centos ~]# 
```

#### 1.5 验证docker是否正确安装

```bash
[root@centos ~]# sudo systemctl start docker
[root@centos ~]# sudo docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

[root@centos ~]# 
```

**通过运行hello-world映像，验证Docker引擎是否正确安装。出现`Hello from Docker!`表示已经正确安装。**

#### 1.6 Docker的卸载

- 卸载Docker Engine、CLI和Containerd包：

```bash
sudo yum remove docker-ce docker-ce-cli containerd.io
```

- 删除镜像、容器、配置文件等内容：

```bash
sudo rm -rf /var/lib/docker
```

### 2.配置镜像加速

Docker从Docker Hub拉取镜像时，由于是从国外获取，所以速度较慢，我们可以通过配置国内镜像源的方式来提高拉取速度，这里主要介绍中国科学技术大学(USTC)和网易的开源镜像源。

- 编辑`daemon.json`文件：

```bash
vim /etc/docker/daemon.json
```

- 在`daemon.json`文件中输入以下内容并保存：

```json
{
  "registry-mirrors":["http://hub-mirror.c.163.com","https://docker.mirrors.ustc.edu.cn"]
}
```

- 重新加载配置文件并重启docker服务：

```bash
#重新加载配置文件
sudo systemctl daemon-reload

#重新启动docker
sudo systemctl restart docker
```

### 3.镜像相关命令

#### 3.1 查看镜像(docker images)

**用法：**

```bash
docker images [OPTIONS] [REPOSITORY[:TAG]]
```

`OPTIONS`就是下面表格中的内容，`REPOSITORY`是镜像的名称，`TAG`是镜像的标签。

**Options**

| 名称            | 默认值 | 描述                           |
| :-------------- | :----- | :--------------------------- |
| `--all , -a`    |        | 列出本地所有的镜像 |
| `--digests`     |        | 显示镜像的摘要信息     |
| `--filter , -f` |        | 根据提供的条件过滤输出 |
| `--format`      |        | 对镜像进行格式化展示 |
| `--no-trunc`    |        | 不截断输出(指的是会展示详细信息) |
| `--quiet , -q`  |        | 只显示镜像ID |

以下为了查看方便，所以我先使用`docker pull`命令拉取了几个镜像下来。

##### 3.1.1 查看所有镜像

使用`docker images`命令可以查看所有镜像，如下所示：

```bash
[root@centos ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
redis         5         e35748fd6a72   4 weeks ago     98.4MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
```

- `REPOSITORY`：镜像在仓库中的名称。
- `TAG`：镜像标签。
- `IMAGE ID`：镜像ID。
- `CREATED`：这个是镜像的创建日期，不是获取镜像的日期。
- `SIZE`：镜像大小。

这些镜像都存储在docker宿主机的`/var/lib/docker`目录下。

##### 3.1.2 查看指定名称的镜像

假如想要查看名称为redis的镜像，可以使用`docker images redis`命令，如下所示：

```bash
[root@centos ~]# docker images redis
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

根据名称查镜像，支持使用*号进行模糊匹配，如下所示：

```bash
[root@centos ~]# docker images red*
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

##### 3.1.3 查看指定名称及标签的镜像

比如使用`docker images redis:5`命令，就表示查出名称是**redis**，标签名是**5**的镜像，如下所示：

```bash
[root@centos ~]# docker images redis:5
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

我们也可以只根据标签查镜像，比如想要查标签名是**latest**的所有镜像，可以使用`docker images *:latest`命令，查询结果如下所示：

```bash
[root@centos ~]# docker images *:latest
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
```

##### 3.1.4 查看标签为空的镜像

可以使用`docker images -f "dangling=true"`命令列出**TAG**那一列值为空的镜像，如果dangling为false的话，就是列出**TAG**那一列值不为空的镜像。效果展示如下：

```bash
[root@centos ~]# docker images -f "dangling=true"
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<none>              <none>              450e15c7459f        10 hours ago        177MB
<none>              <none>              96ae66cb0553        16 hours ago        283MB
```

##### 3.1.5 只展示镜像ID

这里使用的是`docker images -q`命令，假设我们只想展示redis镜像的镜像id，效果如下：

```bash
[root@centos ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
busybox       latest    b97242f89c8a   4 weeks ago     1.23MB
redis         5         e35748fd6a72   4 weeks ago     98.4MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
[root@centos ~]# docker images redis
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
[root@centos ~]# docker images -q redis
eb0ab2d55fdf
e35748fd6a72
```

##### 3.1.6 自定义镜像的展示效果

这里需要用到`docker images --format`命令，该命令后跟的是自定义的输出模板，可以有如下占位符：

| 占位符          | 描述                             |
| --------------- | -------------------------------- |
| `.ID`           | 镜像ID                           |
| `.Repository`   | 镜像名称                         |
| `.Tag`          | 镜像标签                         |
| `.Digest`       | 镜像摘要                         |
| `.CreatedSince` | 镜像被创建至今已经过去了多长时间 |
| `.CreatedAt`    | 镜像被创建的具体时间             |
| `.Size`         | 镜像大小                         |

- 带表头展示镜像ID和名称：

```bash
[root@centos ~]# docker images --format "table {{.ID}}\t{{.Repository}}"
IMAGE ID       REPOSITORY
bf4709e77b18   tomcat
eb0ab2d55fdf   redis
b97242f89c8a   busybox
e35748fd6a72   redis
bf756fb1ae65   hello-world
```

- 不带表头展示镜像ID和名称：

```bash
[root@centos ~]# docker images --format "{{.ID}}\t{{.Repository}}"
bf4709e77b18    tomcat
eb0ab2d55fdf    redis
b97242f89c8a    busybox
e35748fd6a72    redis
bf756fb1ae65    hello-world
```

- 不带表头展示镜像名称、镜像标签和镜像大小：

```bash
[root@centos ~]# docker images --format "{{.Repository}}--->{{.Tag}}--->{{.Size}}"
tomcat--->latest--->667MB
redis--->latest--->104MB
busybox--->latest--->1.23MB
redis--->5--->98.4MB
hello-world--->latest--->13.3kB
```

- 不带表头展示镜像名称和时间：

```bash
[root@centos ~]# docker images --format "{{.Repository}}\t{{.CreatedAt}}\t{{.CreatedSince}}"
tomcat  2021-02-10 16:30:33 +0800 CST   5 days ago
redis   2021-02-10 01:03:48 +0800 CST   5 days ago
busybox 2021-01-13 17:25:26 +0800 CST   4 weeks ago
redis   2021-01-13 03:00:16 +0800 CST   4 weeks ago
hello-world     2020-01-03 09:21:37 +0800 CST   13 months ago
```

#### 3.2 搜索镜像(docker search)

##### 3.2.1 用法

```bash
docker search [OPTIONS] TERM
```

##### 3.2.2 描述说明

`docker search`用于从[Docker Hub](https://hub.docker.com)中搜索指定的镜像。

##### 3.2.3 选项

| 名称            | 默认值 | 描述                   |
| --------------- | ------ | ---------------------- |
| `--filter , -f` |        | 根据提供的条件过滤输出 |
| `--format`      |        | 对镜像进行格式化展示   |
| `--limit`       | 25     | 搜索结果的最大数量     |
| `--no-trunc`    |        | 不截断输出             |

##### 3.2.4 案例

###### 3.2.4.1 通过名称搜索镜像

假设我们想从docker Hub中搜索名称包含redis的镜像，可以使用`docker search redis`命令，如下所示：

![image-20210216193854357](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216195058.png) 

- `NAME`：镜像在仓库中的名称。

- `DESCRIPTION`：镜像的描述信息。
- `STARS`：镜像的收藏数。
- `OFFICIAL`：是否为docker官方发布的镜像。
- `AUTOMATED`：是否为自动化构建的镜像。

###### 3.2.4.2 限制搜索结果的展示数量

我们在搜索镜像时，默认情况下，会展示25条搜索结果，如果我们想要改变展示数量的话，可以使用`--limit`。比如我们只想展示5条记录，可以使用`docker search --limit 5 redis`命令，如下所示：

![image-20210216195906707](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216200003.png) 

###### 3.2.4.3 根据条件过滤展示搜索结果

我们可以使用`-f`or`--filter`进行条件过滤，过滤条件使用的是`key=value`这种键值对的形式，可以有多个过滤条件。

支持的过滤条件如下：

- `stars`：数字类型，表示镜像拥有的收藏数量。
- `is-automated`：布尔类型，表示是否为自动化构建的镜像。
- `is-official`：布尔类型，表示是否为官方发布的镜像。

**STARS**

搜索名称包含redis并且收藏数不小于15的镜像，可以使用`docker search -f stars=15 redis`命令。

![image-20210216202421991](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216202441.png) 

**IS-AUTOMATED**

搜索名称包含redis并且是自动化构建的镜像，可以使用`docker search -f is-automated=true redis`命令。

![image-20210216203156607](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216203159.png) 

**IS-OFFICIAL**

搜索名称包含redis并且是官方发布的镜像，可以使用`docker search -f is-official=true redis`命令。

![image-20210216203558030](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216203601.png) 

**组合过滤**

搜索名称包含redis并且是自动化构建的镜像，可以用`docker search -f is-automated=true -f stars=15 redis`命令。

![image-20210216204800097](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216204802.png) 

###### 3.2.4.4 自定义展示镜像的搜索结果

可以使用`--format`选项对搜索结果进行格式化输出，可以有如下占位符：

| 占位符         | 描述                   |
| -------------- | ---------------------- |
| `.Name`        | 镜像名称               |
| `.Description` | 镜像描述               |
| `.StarCount`   | 镜像收藏数             |
| `.IsOfficial`  | 是否为官方发布的镜像   |
| `.IsAutomated` | 是否为自动化构建的镜像 |

- 可以使用`docker search --format "table {{.Name}}\t{{.StarCount}}" redis`命令搜索名称包含redis，并且带表头只显示镜像名称和收藏数的镜像。

![image-20210216210251429](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216210253.png) 

- 可以使用`docker search --format "{{.Name}}" redis`命令搜索名称包含redis，并且不带表头只显示镜像名称的镜像。

![image-20210216210621283](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216213813.png) 

###### 3.2.4.5 展示搜索结果的详细信息

我们在搜索镜像的时候可以发现，描述信息并没有完全展示，如果我们想要完全展示的话，就需要用到`--no-trunc`选项，比如我们使用`docker search --no-trunc redis`命令搜索redis，可以发现，描述信息已经被全部展示了。

![image-20210217123205172](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123207.png) 

#### 3.3 拉取镜像(docker pull)

##### 3.3.1 根据名称拉取镜像

假设我们想要拉取nginx镜像，可以使用`docker pull nginx`命令，该命令拉取的镜像的标签默认是latest。

![image-20210216213756947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216213759.png) 

##### 3.3.2 根据名称和标签拉取镜像

我们也可以指定标签来拉取镜像，比如使用`docker pull nginx:1.19.6`命令拉取指定标签的镜像。

![image-20210216214204028](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216214206.png) 

#### 3.4 删除镜像(docker rmi)

##### 3.4.1 不加标签删除

不加标签默认会删除标签为latest的镜像，比如使用`docker rmi nginx`命令删除nginx镜像。

![image-20210216220851333](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216220854.png) 

##### 3.4.2 指定标签删除

比如使用`docker rmi nginx:mainline`命令删除标签为mainline的镜像。

![image-20210216221645629](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216221647.png) 

##### 3.4.3 根据镜像id删除

比如使用`docker rmi b9e1dc12387a`命令删除该id对应的镜像。

![image-20210217095107558](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217095115.png) 

##### 3.4.4 强制删除镜像

我们可以使用`--force`或者`-f`强制删除一个镜像，比如使用`docker rmi -f f6d0b4767a6c`命令强制删除该id对应的镜像。

![image-20210217095612682](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217095618.png) 

##### 3.4.5 删除所有镜像

可以使用`docker rmi -f $(docker images -aq)`命令删除本地所有镜像。

![image-20210217114301947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217114305.png) 

### 4.容器相关命令

#### 4.1 查看容器(docker ps)

**用法：**

```bash
docker ps [OPTIONS]
```

**Options**

| 名称            | 默认值 | 描述                                                         |
| --------------- | ------ | ------------------------------------------------------------ |
| `--all , -a`    |        | 显示所有容器(不使用该参数的话，默认只会显示正在运行中的容器) |
| `--filter , -f` |        | 根据提供的条件过滤输出                                       |
| `--format`      |        | 对容器进行格式化展示                                         |
| `--last , -n`   | -1     | 显示最后创建的容器(包括所有状态)                             |
| `--latest , -l` |        | 显示最近一次创建的容器(包括所有状态)                         |
| `--no-trunc`    |        | 不截断输出                                                   |
| `--quiet , -q`  |        | 只显示容器id                                                 |
| `--size , -s`   |        | 显示文件总大小                                               |

##### 4.1.1 查看所有容器

可以使用`docker ps -a`命令查看所有容器，包括正在运行的和已经停止运行的。

![image-20210217121258115](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217121301.png) 

##### 4.1.2 查看正在运行中的容器

使用`docker ps`命令可以查看所有正在运行中的容器，已经停止的容器，不会展示出来。

![image-20210217121502796](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123755.png) 

##### 4.1.3 展示容器的详细信息

比如可以使用`docker ps --no-trunc`命令展示正在运行中的容器的详细信息。

![image-20210217123712412](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123759.png) 

由上图可知，默认情况下**CONTAINER ID**和**COMMAND**这两列下的内容都被进行了截取，而只有在使用了`--no-trunc`选项之后这两列下的内容才完全展示出来。

##### 4.1.4 容器的磁盘大小展示

可以使用`docker ps -s`命令展示容器大小，展示的结果中会有两个数值，一个是容器真实增加的大小，一个是整个容器的虚拟大小，**容器虚拟大小 = 容器真实增加的大小 + 容器镜像的大小**。

![image-20210217124744087](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217124748.png) 

##### 4.1.5 根据条件过滤容器

我们可以使用`-f`or`--filter`进行条件过滤，过滤条件使用的是`key=value`这种键值对的形式，可以有多个过滤条件。

支持的过滤条件如下：

- `id`：容器的id。
- `name`：容器的名称。
- `label`：表示键或键值对的任意字符串。
- `exited`：表示容器退出的状态码，只有在使用`-a`这个选项时该条件才会生效。
- `status`：容器的状态(`created`,`restarting`,`running`,`removing`,`paused`,`exited`,`dead`)。
- `ancestor`：过滤从指定镜像创建的容器。
- `before` or `since`：过滤在给定的容器ID或名称之前或之后创建的容器。
- `volume`：过滤挂载有指定数据卷的容器。
- `network`：过滤连接到指定网络的容器。
- `publish` or `expose`：过滤发布或公开给定端口的容器。。
- `health`：根据容器的健康检查状态过滤容器(`starting`,`healthy`,`unhealthy`,`none`)。
- `isolation`：Windows daemon使用(`default`,`process`,`hyperv`)。
- `is-task`：是否是一个服务的task(`true` or `false`)。

###### 4.1.5.1 根据容器id或容器名称进行过滤

使用`docker ps -af "id=b64edfe27b8b"`命令或者`docker ps -af "name=bold_bouman"`命令就是根据容器id及容器名称进行过滤的方式。

![image-20210217172323762](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217173138.png) 

###### 4.1.5.2 根据容器退出的状态码进行过滤

比如只想展示退出的状态码是0的容器，可以使用`docker ps -af "exited=0"`命令。

![image-20210217173136555](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217173319.png) 

###### 4.1.5.3 根据容器的状态进行过滤

假设我们只想展示正在运行的容器，这时候就可以使用`docker ps -af status=running`命令。

![image-20210217173639022](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174126.png) 

###### 4.1.5.4 根据镜像过滤容器

假设我们只想展示tomcat这个镜像创建的容器，可以使用`docker ps -af ancestor=tomcat`命令。

![image-20210217174122193](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174640.png) 

除了可以使用镜像名称过滤外，也可以使用镜像id来过滤该镜像对应的容器。这种方式需要我们先获取到镜像的id，然后再根据id过滤即可，可以使用`docker ps -af ancestor=$(docker images -q tomcat)`命令。

![image-20210217174633731](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174646.png) 

##### 4.1.6 格式化展示容器

可以使用`--format`选项对容器进行格式化结果展示，可以有如下占位符：

| 占位符        | 描述                                       |
| :------------ | :----------------------------------------- |
| `.ID`         | 容器id                                     |
| `.Image`      | 镜像名称                                   |
| `.Command`    | 启动命令                                   |
| `.CreatedAt`  | 容器创建的时间                             |
| `.RunningFor` | 容器被创建至今已经过去了多长时间           |
| `.Ports`      | 端口信息                                   |
| `.State`      | 容器状态(比如`created`,`running`,`exited`) |
| `.Status`     | 带有持续时间和运行状况的状态               |
| `.Size`       | 容器磁盘大小                               |
| `.Names`      | 容器名称                                   |
| `.Labels`     | 分配给容器的所有标签                       |
| `.Label`      | 指定的标签值                               |
| `.Mounts`     | 容器中挂载的卷的名称                       |
| `.Networks`   | 连接到容器的网络名称                       |

使用`docker ps -a --format "table {{.ID}}\t{{.Image}}\t{{.CreatedAt}}\t{{.RunningFor}}\t{{.State}}\t{{.Status}}\t{{.Names}}"`命令进行格式化演示，如下所示：

![image-20210217182003114](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217182011.png) 

##### 4.1.7 显示最近创建的容器

如果我们想要展示最近一次或者前几次创建的容器，可以使用`-l`和`-n`选项来实现，比如使用`docker ps -l`命令就是展示最近一次创建的容器，使用`docker ps -n 3`命令则是展示前3次创建的容器。

![image-20210217185123880](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217185125.png) 

#### 4.2 运行容器(docker run)

**用法：**

```bash
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

**常用选项：**

| 名称             | 默认值 | 描述                                             |
| :--------------- | :----- | :----------------------------------------------- |
| `-d`             |        | 后台运行容器，并返回容器id，也即启动守护式容器   |
| `--name`         |        | 为容器指定一个名称                               |
| `-i`             |        | 以交互模式运行容器，通常与`-t`同时使用           |
| `-t`             |        | 为容器重新分配一个伪输入终端，通常与`-i`同时使用 |
| `-p`             |        | 指定端口映射，格式为：**宿主机端口:容器端口**    |
| `-P`             |        | 随机端口映射，容器内部端口随机映射到主机的端口   |
| `--rm`           |        | 当容器退出时自动移除该容器                       |
| `--privileged`   |        | 给这个容器扩展权限                               |
| `--workdir , -w` |        | 指定容器的工作目录                               |
| `--volume , -v`  |        | 绑定挂载卷                                       |
| `--env , -e`     |        | 设置环境变量                                     |

##### 4.2.1 前台运行容器

假设直接使用`docker run nginx`命令运行nginx，这种就属于前台运行，前台运行会占用我们的窗口。

![image-20210217202517929](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217203000.png) 

为了验证容器是否运行成功，可以另开一个窗口进行查看。由下图可知，容器确实运行成功了。

![image-20210217202710813](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217202942.png) 

##### 4.2.2 后台运行容器

如果想要后台运行容器，需要用到`-d`选项。比如可以使用`docker run -d tomcat`命令后台运行tomcat容器。

![image-20210217211959212](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217212001.png) 

##### 4.2.3 给需要运行的容器指定名称

我们可以使用`docker run --name mytomcat -d tomcat`命令通过后台的方式运行一个tomcat容器，并将该容器命名为mytomcat。

![image-20210217213909480](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217213916.png) 

##### 4.2.4 容器端口映射

容器中启动的应用，外部方式默认情况下是无法访问到的，这时候就可以通过端口映射的方式和宿主机进行关联，比如可以使用`-P`选项随机映射到宿主机的某个端口上。使用`docker run --name mynginx -P -d nginx`命令运行nginx容器就是指把运行的容器对应的80端口映射到宿主机的49153端口上，这时外部通过宿主机的49153端口就可以访问到容器中运行的nginx了。

![image-20210217214554883](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217220158.png) 

除了随机映射外，我们还可以通过`-p`选项指定端口映射。如下图所示，外部通过宿主机的12345端口就可以访问到容器中使用80端口运行的nginx了。使用的命令是` docker run --name nginxtest -p 12345:80 -d nginx`。

![image-20210217220153801](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217220205.png) 

##### 4.2.5 运行并进入容器

我们可以使用`-i`和`-t`选项在启动容器后就进入容器与容器进行交互。比如使用`docker run -it centos:7`命令就会启动并进入到容器中，下图中的`ls`命令就是在centos容器中使用的。

![image-20210217221342809](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217221903.png)

##### 4.2.6 进入容器的指定目录

假设我们想在运行容器后就直接进入到`/etc/yum`目录中，那么可以使用`docker run -w /etc/yum -it centos:7`命令来实现，如果该目录不存在，则会在容器中自动新建该目录。

![image-20210218095253265](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218095258.png) 

我们也可以直接进入容器的指定目录下执行指定的命令后再退出容器，比如我们想要在容器的`/etc/yum`目录下执行`ls`命令后再退出容器，可以使用`docker run -w /etc/yum -it centos:7 ls`命令。

![image-20210218100027654](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218100037.png) 

#### 4.3 退出容器

```bash
exit  # 使用-it选项运行并进入centos容器后，使用该命令退出容器后，同时也会停止容器
Ctrl + P + Q  # 退出不停止容器
```

#### 4.4 删除容器(docker rm)

与删除镜像的用法差不多，如果想要强制删除的话，需要用到`-f`选项，也可以通过容器id进行全量删除。

- 根据容器名称删除(比如：`docker rm amazing_jang`)

![image-20210218102908307](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218102910.png) 

- 根据容器id删除(比如：`docker rm 844c7ea979a4`)

![image-20210218103127487](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218103143.png) 

- 强制删除容器(比如：`docker rm -f def0deead9e5`)

使用`-f`选项可以删除正在运行中的容器。

![image-20210218103558726](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218103600.png) 

- 全量删除容器(比如：`docker rm $(docker ps -aq)`)

![image-20210218104535412](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218104538.png) 

- 删除多个容器(比如：`docker rm 9309fcf92cd6 ee765a728229`)

![image-20210218182229334](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218182231.png) 

#### 4.5 进入容器(docker exec)

我们可以通过容器名称或者容器id来进入容器，进入容器的命令后面可以跟`sh`也可以跟`bash`，比如我们想要进入一个正在运行的nginx容器中，可以使用`docker exec -it 8abd33e52701 sh`命令，8abd33e52701是容器的id，也可以使用`docker exec -it mynginx bash`命令，mynginx是容器的名称。

![image-20210218112401907](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218112408.png) 

#### 4.6 容器的停止和启动

我们可以使用`docker stop 容器名称|容器id`命令来停止容器，使用`docker start 容器名称|容器id`命令来启动容器。

![image-20210218115455420](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218115457.png) 

>  如果想要重启容器的话，就用`docker restart`命令。

#### 4.7 容器和宿主机之间的文件拷贝

我们可以将宿主机上的文件拷贝到容器中，也可以将容器中的文件拷贝到宿主机上。

- **宿主机--->容器：**

```bash
docker cp 宿主机的文件或目录 容器名称或id:容器目录
```

假设我们想将宿主机的`/root/nginx/linux-nginx-1.16.1.tar.gz`文件拷贝到容器的`/home`路径下，可以使用下图中的命令，当我们进入到容器的`/home`路径下时，发现确实有`linux-nginx-1.16.1.tar.gz`文件，说明拷贝成功了。

![image-20210218121407834](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218121410.png) 

- **容器--->宿主机：**

```bash
docker cp 容器名称或id:容器的文件或目录 宿主机的目录
```

比如使用`docker cp mynginx:/lib/init/vars.sh /root/test`命令将容器中的`/lib/init/vars.sh`文件拷贝到宿主机的`/root/test`目录下。由下图可知，已经拷贝成功了。

![image-20210218123608436](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218123610.png) 

#### 4.8 目录挂载(容器数据卷操作)

我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器，而且这个操作是双向绑定的，也就是说，容器内的操作也会影响到宿主机，可以实现备份功能。

使用目录挂载的话，当容器被删除的时候，宿主机与容器映射的目录下的内容并不会被删除。如果多个容器挂载了同一个目录，当其中一个容器被删除的时候，其他容器的该目录下的内容并不会受到影响。

> 容器与宿主机之间的数据卷属于引用的关系，数据卷是从外界挂载到容器内部中的，所以可以脱离容器的生命周期而独立存在，正是由于数据卷的生命周期并不等同于容器的生命周期，在容器退出或者删除以后，数据卷才不会受到影响。
>
> 目录挂载操作可能会出现权限不足的提示。这是因为CentOS7中的安全模块SELinux把权限禁掉了，在docker run时可以通过`--privileged=true`给该容器加权限来解决挂载的目录没有权限的问题。

##### 4.8.1 指定目录挂载

如果想要在运行容器的时候使用目录挂载，需要使用`-v`选项，该选项后跟的目录的格式为:`宿主机目录:容器目录`。也可以使用`docker run -v 宿主机目录:容器目录 -v 宿主机目录2:容器目录2 镜像名`这种格式进行多目录挂载。

假设我们想把宿主机的`/root/test`路径和容器的`/home/gsl`路径(没有该路径的话会自动创建)进行映射，那么我们可以在运行容器的时候使用`docker run --name mynginx -d -v /root/test:/home/gsl nginx`命令实现。然后我们进入到容器的`/home/gsl`目录下会发现，之前宿主机的`/root/test`目录下的vars.sh文件，在容器的`/home/gsl`目录下也存在，这就说明已经完成了目录挂载，这时不管对哪一个目录进行操作，都会完成数据同步。

![image-20210218153900305](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218153903.png) 

如果我们想要知道宿主机和容器之间的这个目录映射关系，可以使用`docker inspect 容器名称|容器id`命令查看，比如使用`docker inspect mynginx|grep -A9 "Mounts"`命令。

![image-20210218160018559](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218160154.png) 

##### 4.8.2 匿名目录挂载

匿名挂载不需要我们在运行容器时再指定宿主机的目录，只要指定容器的目录即可，然后宿主机上对应的目录都会自动生成到`/var/lib/docker/volumes`路径下。比如使用`docker run --name mynginx -d -v /usr/local/data nginx`。

![image-20210218164411072](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218164415.png) 

##### 4.8.3 具名目录挂载

具名挂载就是给数据卷起一个名字，容器外对应的目录会在`/var/lib/docker/volumes`路径中生成。比如我们给宿主机上的数据卷起名为host_data，使用`docker run --name mynginx01 -d -v host_data:/usr/local/data nginx`命令即可。

![image-20210218172143590](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218172145.png) 

##### 4.8.4 只读/读写

```bash
# 只读。只能通过修改宿主机内容实现对容器的数据管理，不能在容器中修改映射到容器的目录下的文件。
docker run -v /宿主机目录:容器目录:ro 镜像名
# 读写。默认就是读写，也就是说进行目录挂载后，宿主机和容器都能对映射目录下的文件进行修改。
docker run -v /宿主机目录:容器目录:rw 镜像名
```

##### 4.8.5 继承(volumes-from)

假设我们已经运行了一个使用了目录挂载的容器A，然后我们还想运行一个带目录挂载的容器B，并且希望容器B使用挂载对应宿主机的目录和容器中映射的目录和容器A都一样，这时候就可以使用`--volumes-from`选项来实现。命令如下：

```bash
# 运行mynginx容器
docker run -d --name mynginx -v /root/test:/usr/local/data nginx
# 运行mynginx01容器，并继承mynginx容器的目录挂载
docker run -d --name mynginx01 --volumes-from mynginx nginx
# 查看mynginx容器的目录挂载信息
docker inspect mynginx|grep -A9 "Mounts"
# 查看mynginx01容器的目录挂载信息
docker inspect mynginx01|grep -A9 "Mounts"
```

![image-20210218175903870](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218175906.png) 

##### 4.8.6 查看数据卷的基本信息

可以使用`docker volume inspect 数据卷名称`来查看数据卷的基本信息，比如之前创建了一个名字叫host_data的数据卷，那就可以使用`docker volume inspect host_data`命令查看这个数据卷的基本信息。

![image-20210218181625687](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218181628.png) 

##### 4.8.7 查看容器IP信息

可以使用`docker inspect`命令查看容器的IP信息，比如使用`docker inspect mynginx|grep -A16 "Networks"`命令查看mynginx容器的IP信息。

![image-20210218182755742](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218182758.png) 

#### 4.9 提交镜像(docker commit)

我们可以使用`docker commit`命令把自己更改过的容器创建成一个新的镜像。

**用法：**

```bash
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
```

**选项：**

| 名称             | 默认值 | 描述                               |
| ---------------- | ------ | ---------------------------------- |
| `--author , -a`  |        | 该选项用于添加镜像提交人的信息     |
| `--change , -c`  |        | 对创建的映像应用Dockerfile指令     |
| `--message , -m` |        | 该选项用于添加提交镜像时的描述信息 |
| `--pause , -p`   | true   | 在镜像的提交期间暂停容器           |

**命令举例：**

```bash
# "gongsl"是作者，"installed nginx"是描述信息，"mycentos"是生成的镜像的名称，"1.0.0"是生成的镜像的标签
docker commit -a="gongsl" -m="installed nginx" 容器id|容器名称 mycentos:1.0.0
```

当我们根据容器创建了一个新的镜像后，我们使用`docker images`命令是可以展示出这个新的镜像的。

![image-20210218201801415](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218201803.png) 

**实操演示：**

下面我就实操演示一下，如何在一个运行的centos容器中安装nginx并生成一个新的镜像。

![演示](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218213901.gif) 

### 5.Dockerfile的用法

#### 5.1 Dockerfile简介

Docker可以通过读取Dockerfile中的指令来自动构建镜像。Dockerfile是一种文本文档，它包含用户可以在命令行上调用的所有命令来组装镜像。使用docker构建，用户可以创建一个自动构建，连续执行几个命令行指令。

我们可以使用`docker build`命令来构建镜像。该命令根据Dockerfile和上下文构建镜像。构建的上下文是位于指定位置、路径或URL的一组文件。路径是本地文件系统上的一个目录。URL是一个Git存储库位置。

构建是由Docker守护进程运行的，而不是由CLI运行。构建过程所做的第一件事是将整个上下文(递归地)发送给守护进程。在大多数情况下，最好从一个空目录开始作为上下文，并将Dockerfile保存在该目录中。只添加构建Dockerfile所需的文件。不要使用你的根目录`/`作为路径，因为它会将你的硬盘驱动器的整个内容传输到Docker守护进程。

#### 5.2 Dockerfile的常用指令

##### 5.2.1 FROM

`FROM`指令一般用于初始化一个新的构建阶段，并为后续指令设置基本镜像。因此，一个有效的Dockerfile必须以FROM指令开始。镜像可以是任何有效的镜像，一般从公共存储库中提取镜像尤其容易。

**语法**：`FROM <image>:<tag>`

指明构建的新镜像是来自于哪个基础镜像，如果没有选择tag，那么默认值为latest。

**案例**：

```bash
FROM centos:7
```

> 如果不以任何镜像为基础，那么可以写成`FROM scratch`。scratch镜像是一个空镜像，如果我们想要从零开始构建一个属于自己的镜像，就可以使用scratch镜像，不过一般我们没必要这么做。

##### 5.2.2 LABEL

**语法**：`LABEL <key>=<value> <key>=<value> <key>=<value> ...`

该指令后跟的是键值对的形式，可以只有一个键值对，也可以有多个。我们可以使用该指令给镜像添加一些像描述信息，版本号，作者等信息。

**案例**：

```bash
LABEL author="gongsl" version="1.0" description="This is a description"
```

##### 5.2.3 RUN

**语法**：`RUN <command>`

该指令后跟的是构建镜像时需要运行的shell命令，一个Dockerfile中可以包含多个RUN指令。

**案例**：

比如在构建的新镜像中我们想要安装一个vim编辑器，可以使用如下命令：

```bash
RUN yum -y install vim
```

##### 5.2.4 ADD

**语法**：`ADD <src>... <dest>`

该指令可以将文件或目录拷贝到镜像中。上面的src可以是一个本地普通文件或压缩文件，如果是压缩文件的话，会自动进行解压。还可以是一个url，如果是url的话，那么ADD指令就类似于linux中的wget命令，会自动下载并解压。

**案例**：

```bash
ADD jdk-8u231-linux-x64.tar.gz /usr/local/java
```

> `jdk-8u231-linux-x64.tar.gz`指的是宿主机当前目录下的压缩文件，`/usr/local/java`指的是镜像里面的目录，如果该目录不存在，会自动进行创建。

##### 5.2.5 COPY

**语法**：`ADD <src>... <dest>`

该指令主要是拷贝文件或目录到镜像中，用法同ADD类似，不过这个指令就是单纯的拷贝，不支持自动下载和解压。

**案例**：

```bash
COPY readme.txt /usr/local
```

##### 5.2.6 EXPOSE

**语法**：`EXPOSE <port> [<port>/<protocol>...]`

该指令用于暴露容器运行时的监听端口给外部，可以指定端口是监听TCP还是UDP，如果未指定协议，默认是TCP。

**案例**：

```bash
EXPOSE 80 8080/tcp
```

> 这个指令只是暴露容器的端口，如果想要容器和宿主机的端口有映射关系，必须要在使用`docker run`命令运行容器的时候加上`-p`或者`-P`选项。

##### 5.2.7 ENV

**语法**：

- 添加单个：`ENV <key> <value>`

- 添加多个：`ENV <key>=<value> ...`

该指令主要用于设置容器内的环境变量的，可以使用该指令只添加一个，也可以添加多个。

**案例**：

```bash
ENV JAVA_HOME /usr/local/jdk1.8.0_231
```

##### 5.2.8 CMD

**语法**：

- `CMD ["executable","param1","param2"]`(比如：`CMD ["/usr/local/tomcat/bin/catalina.sh","run"]`)
- `CMD ["param1","param2"]`(比如：`CMD ["echo","$JAVA_HOME"]`)
- `CMD command param1 param2`(比如：`CMD echo $JAVA_HOME`)

该指令用于启动容器时需要执行的shell命令。在Dockerfile中只能有一条CMD指令，如果设置了多条CMD指令，只有最后一条会生效。

**案例**：

```bash
CMD ["/usr/local/apache-tomcat-8.5.47/bin/catalina.sh","run"]
```

**注意事项**：

- 如果`docker run`的时候指定了命令，则CMD指令会被替代。比如我们已经创建了一个`centos:7`镜像，然后现在使用了`docker run -it --name mycentos centos:7 echo "helloworld"`命令去运行它，那么CMD指令就会失效，上面案例中的tomcat就不会再启动了，而是输出`helloworld`；
- 这个`CMD`指令和前面说到的`RUN`指令有些类似，不过它们是有本质区别的。RUN指令是在使用`docker build`构建镜像的时候起作用，是构建镜像的一个步骤。好比我们想让镜像构建好后就包含某些命令或目录，就可以使用RUN指令下载命令或者创建目录。而CMD指令是在使用`docker run`启动容器时起作用，是启动容器后默认执行的命令。好比容器一启动就启动容器中的tomcat，或者输出java的环境变量信息等，都要使用CMD指令。

##### 5.2.9 ENTRYPOINT

**语法**：

- `ENTRYPOINT ["executable", "param1", "param2"]`

- `ENTRYPOINT command param1 param2`

该指令和CMD指令用法类似，指令后面跟的也是启动容器时需要执行的shell命令。ENTRYPOINT指令和CMD指令最大的不同就是，它不会被`docker run`命令后指定的命令所覆盖。在Dockerfile中只能有一条ENTRYPOINT指令，如果有多条该指令，只有最后一条会生效。

**案例**：

```bash
ENTRYPOINT echo $JAVA_HOME
```

**注意事项**：

- 如果在Dockerfile中同时出现了`ENTRYPOINT`指令和`CMD`指令,并且CMD指令不是一个完整的可执行的命令的话，那么CMD指令后的内容将会被作为ENTRYPOINT指令的参数；
- 如果在Dockerfile中同时出现了`ENTRYPOINT`指令和`CMD`指令,并且CMD指令是一个完整的可执行的命令的话，那么这两个指令会相互覆盖，谁在最后谁生效。

##### 5.2.10 WORKDIR

**语法**：`WORKDIR /path/to/workdir`

可以使用该指令设置一个工作目录，如果工作目录不存在，会自动创建。WORKDIR指令也可以解析在该指令之前使用ENV指令设置的环境变量。

**案例**：

```bash
# 直接设置一个绝对路径为工作目录
WORKDIR /usr/local

# 解析该指令前ENV指令设置的环境变量
ENV MYPATH /usr/local
WORKDIR $MYPATH
```

> 我们在进入已启动的容器时，默认是进入到`/`根目录下的，如果想要改变这个默认目录，就可以使用`WORKDIR`指令。假设我们使用该指令设置的工作目录是`/usr/local`的话，那么当我们进入容器后默认就会在这个目录下。

##### 5.2.11 VOLUME

**语法**：`VOLUME ["/data"]`

`VOLUME`指令使用指定的名称创建一个挂载点，并将其标记为保存来自本机主机或其他容器的外部挂载卷。一般的使用场景为需要持久化存储数据时。

**案例**：

```bash
# 容器的var/lib/mysql目录会在运行时自动挂载为匿名卷，匿名卷在宿主机的var/lib/docker/volumes目录下
VOLUME ["var/lib/mysql"]
```

> 一般不会在Dockerfile中用到该指令，更常见的是在使用`docker run`运行容器的时候通过`-v`选项指定数据卷。

#### 5.3 Dockerfile实战

> 如果我们想要通过读取Dockerfile中的指令来自动构建镜像，需要用到`docker build`命令。主要介绍下该命令的两个选项，分别是`-f`和`-t`。`-f`选项用于指定要读取的Dockerfile文件，而`-f`选项用于指定生成的镜像名。

接下来我们通过`docker build`命令读取Dockerfile文件的方式在基础镜像`centos:7`中安装jdk和tomcat，并将其制作为一个新的`mycentos:7`镜像。

**Dockerfile文件内容：**

```dockerfile
#指明构建的新镜像是来自于centos:7这个基础镜像
FROM centos:7
#通过镜像标签声明作者信息
LABEL author="gongsl"
#把宿主机的文件拷贝到容器指定目录中
COPY readme.txt /usr/local
#创建自定义目录
RUN mkdir -p /usr/local/java && mkdir -p /usr/local/tomcat
#将压缩包解压,并将解压后的目录拷贝到镜像的对应目录中
ADD jdk-8u231-linux-x64.tar.gz /usr/local/java
ADD apache-tomcat-8.5.47.tar.gz /usr/local/tomcat
#安装vim编辑器
RUN yum -y install vim
#随便配置一个环境变量，以便演示下面的WORKDIR指令
ENV MYPATH /usr/local
#将上一步设置的环境变量的值设置为工作目录
WORKDIR $MYPATH
#配置java和tomcat的环境变量
ENV JAVA_HOME /usr/local/java/jdk1.8.0_231
ENV CLASS_PATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool.jar
ENV CATALINA_HOME /usr/local/tomcat/apache-tomcat-8.5.47
ENV CATALINA_BASE /usr/local/tomcat/apache-tomcat-8.5.47
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
#暴露容器运行时的8080监听端口给外部
EXPOSE 8080
#可以使用下面这种方式在启动容器后就启动tomcat,但是为了目录挂载获取实时日志,暂时就不使用这种方式了
#CMD ["/usr/local/apache-tomcat-8.5.47/bin/catalina.sh","run"]
#使用下面这种方式启动tomcat的话,只要使用了目录挂载,就可以在宿主机上获取tomcat的实时日志
CMD /usr/local/tomcat/apache-tomcat-8.5.47/bin/startup.sh && tail -F /usr/local/tomcat/apache-tomcat-8.5.47/logs/catalina.out
```

**a.jsp文件内容：**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>My JSP</title>
    
        <meta http-equiv="pragma" content="no-cache">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="expires" content="0">    
        <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
        <meta http-equiv="description" content="This is my page">

  </head>
  <body>
    This is a test!
    <% System.out.println("tomcat is running..."); %>
  </body>
</html>
```

**web.xml文件内容：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1">
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
</web-app>
```

**readme.txt文件内容：**

```xml
This is a test document!
```

**构建新镜像前的目录结构：**

![image-20210220212255917](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220212521.png) 


```bash
/root/test/
         |
         |---Dockerfile   #这个就是Dockerfile文件，没有后缀名
         |
         |---logs/   #这个是挂载目录，对应容器中tomcat的logs目录
         |
         |---project/   #这也是一个挂载目录，同时也是最简单的一个小项目，用于测试tomcat运行情况
         |         |
         |         |---a.jsp
         |         |
         |         |---WEB-INF/
         |                   |
         |                   |---web.xml
         |---resource/
                    |
                    |---apache-tomcat-8.5.47.tar.gz
                    |
                    |---jdk-8u231-linux-x64.tar.gz
                    |
                    |---readme.txt   #这个是随便创建的一个文件，是用于测试Dockerfile的COPY指令用的
```

**构建新镜像：**

**命令**：`docker build -f /root/test/Dockerfile -t mycentos:1.0 /root/test/resource/`

> 上面的`/root/test/Dockerfile`是Dockerfile文件的位置，`/root/test/resource/`是Dockerfile文件中用到的软件和文件的位置。比如`COPY readme.txt /usr/local`这条指令需要把readme.txt文件拷贝到容器中，这个文件就是从`/root/test/resource/`目录中获取的。

- **开始构建：**

![image-20210219210518386](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219210520.png) 

- **构建成功：**

![image-20210219213328500](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219213330.png) 

**注意**：像下图这种，Dockerfile文件中用到的软件和文件都和Dockerfile文件在相同的`/root/test`目录下，并且也是在这个目录下使用`docker build`构建新镜像的话，那直接使用`docker build -t mycentos:1.0 .`命令就可以了。

![image-20210219205034411](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219205822.png) 

**运行镜像：**

`docker run -d -p 8080:8080 --name mytest \
-v /root/test/project/:/usr/local/tomcat/apache-tomcat-8.5.47/webapps/project \
-v /root/test/logs/:/usr/local/tomcat/apache-tomcat-8.5.47/logs \
mycentos:1.0`

![image-20210219214057759](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219214100.png) 

由上图可知，镜像已经运行成功了。

接下来可以进入到容器中看下，像[jdk-8u231-linux-x64.tar.gz](https://share.weiyun.com/4AUk6jRw)以及[apache-tomcat-8.5.47.tar.gz](https://gongsl.lanzous.com/i3Q1Llv89ed)的解压文件还有readme.txt文件是否都拷贝到容器中对应的目录中了。

![检查拷贝情况](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219221513.gif) 

通过上面的动图可知，该拷贝的确实已经拷贝成功了。接下来就是查看tomcat的运行效果以及目录挂载效果。由于在运行项目的时候，已经把宿主机的`/root/test/project`目录和容器中tomcat下的`webapps/project`目录做映射了，所以其实已经相当于在容器中的tomcat里部署了一个名为project的项目了。我们可以通过访问该项目下的`a.jsp`文件来观察容器中tomcat的运行情况。

![检查运行情况](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219222807.gif) 

通过上面的动图可知，能够成功访问到项目下的`a.jsp`文件，说明容器中tomcat的运行是没有问题的。然后再检查下日志目录的挂载情况，看容器中tomcat的日志是否实时同步到宿主机对应目录的文件中了。

![检查日志同步情况](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219223452.gif) 

通过上面的动图可知，日志目录挂载也没有问题，日志也能实时同步到宿主机对应目录的文件中。至此，Dockerfile实战部分结束。

### 6.镜像的备份、恢复和迁移

#### 6.1 镜像备份

可以使用`docker save`命令将指定镜像保存成tar归档文件。

**用法**：`docker save [OPTIONS] IMAGE [IMAGE...]`

**选项**：

- `-o`：镜像打包后的归档文件输出的目录。

**案例**：

```bash
# 下面的mycentos:7是要被打包的镜像的名称和标签
docker save -o /root/mycentos7.tar mycentos:1.0
```

![image-20210219225150134](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219225152.png) 

#### 6.2 镜像恢复

可以使用`docker load`命令导入使用docker save命令导出的镜像归档文件。

**用法**：`docker load [OPTIONS]`

**选项**：

- `--input, -i`：指定导入的文件。

- `--quiet, -q`：精简输出信息。

**案例**：

```bash
docker load -i /root/mycentos7.tar
```

![image-20210219230126850](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210219230130.png) 

#### 6.3 镜像迁移

镜像的迁移同时涉及上面两个操作，即备份和恢复。

我们可以将任何一个docker镜像从一台机器迁移到另一台机器。在迁移过程中，首先我们要把容器构建为docker镜像，然后该docker镜像被作为tar包文件保存到本地。此时只需要拷贝或移动该镜像到我们想要的机器上，恢复该镜像并运行容器即可。

当然，除了这种方式之外，我们还可以使用镜像仓库实现镜像的备份、恢复和迁移。

### 7.镜像仓库的使用

#### 7.1 公共仓库的使用

这里的公共仓库指的是[DockerHub](https://hub.docker.com/)，上传到公共仓库的镜像是可以供所有人进行下载使用的。

推送镜像到公共仓库的具体步骤如下：

- 首先到DockerHub中注册一个属于自己的账号(如果页面登录进去的话，发现自己的仓库下是没有任何镜像的)；

![image-20210220105929912](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220105933.png) 

- 然后回到宿主机界面，使用`docker login`命令输入用户名和密码后进行登录；

![image-20210220110639330](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220110736.png) 

- 由于是国外网站，网速较慢，所以这里找一个小点的镜像进行演示，这里就使用`docker pull hello-world`拉取公共仓库的hello-world镜像；

![image-20210220111218870](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220111221.png) 

- 使用`docker tag hello-world:latest gongcqq/my-hello-world:1.0.0`命令给hello-world镜像打个标签，生成一个属于自己的专属镜像；

![image-20210220112437882](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220112439.png) 

- 使用`docker push gongcqq/my-hello-world:1.0.0`命令将刚才生成的新镜像推送到远程的公共仓库；

![image-20210220112815097](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220112817.png) 

- 浏览器方式登录DockerHub进行查看，发现镜像已经推送成功了，也可以点进去查看镜像详情；

![image-20210220112937643](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220113232.png) 

![image-20210220113225973](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220113300.png) 

- 如果想要退出登录的话，直接使用`docker logout`命令即可；

![image-20210220114317076](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220114319.png) 

- 我们也可以使用`docker pull gongcqq/my-hello-world:1.0.0`命令来拉取之前推送到公共仓库的镜像。

![image-20210220114639118](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220114641.png) 

#### 7.2 私有仓库的使用

公共仓库DockerHub为我们提供了很多官方镜像和个人上传的镜像，我们可以下载机构或个人提供的镜像，也可以上传我们自己本地的镜像，不过公共仓库有如下缺点：

- 由于网络原因，从DockerHub下载和上传镜像速度可能会比较慢；
- 在生产上使用的docker镜像可能包含我们的代码、配置信息等，这些我们是只允许内部人员获取的，如果上传到公共仓库，安全性得不到保障。

为了解决以上问题，docker官方提供了一个叫做`registry`的镜像，该镜像可以为我们搭建本地私有仓库。在内部搭建的私有仓库可以使内网人员下载、上传都非常快速，不受外网宽带等因素的影响，只有内网人员可以下载我们的镜像，安全性也可以得到保障，并且私有仓库也支持配置仓库认证功能。

##### 7.2.1 拉取用于创建私有仓库的镜像

**命令**：`docker pull registry`

![image-20210220120345955](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220120351.png) 

##### 7.2.2 修改配置文件

修改`daemon.json`文件：

```bash
vim /etc/docker/daemon.json
```

添加以下内容，用于让docker信任私有仓库地址，添加后保存退出。

```json
{
  "insecure-registries":["192.168.68.12:5000"]
}
```

![image-20210220122601046](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220122603.png)  

重新加载配置信息，并重启docker服务。

```bash
#重新加载配置文件
sudo systemctl daemon-reload
#重新启动docker
sudo systemctl restart docker
```

##### 7.2.3 创建私有仓库容器

**运行容器：**

```bash
docker run -di --name registry -p 5000:5000 \
-v /root/mydata/docker_registry:/var/lib/registry registry
```

![image-20210220123712142](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220123716.png) 

打开浏览器输入：http://192.168.68.12:5000/v2/_catalog 看到`{"repositories":[]}`表示私有仓库搭建成功并且内容为空。

##### 7.2.4 推送镜像至私有仓库

```bash
#根据官方的hello-world生成一个专属镜像
docker tag hello-world:latest 192.168.68.12:5000/test-hello-world:1.0.0
#将生成的新镜像推送到私有仓库
docker push 192.168.68.12:5000/test-hello-world:1.0.0
```

![image-20210220124741827](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220124743.png) 

推送命令执行完后，浏览器再次访问刚才那个[地址](http://192.168.68.12:5000/v2/_catalog)可以发现，repositories下已经多了一个`test-hello-world`，说明本地镜像已经成功推送到了私有仓库。

![image-20210220130208066](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220130211.png) 

由于运行容器的时候我们做了目录挂载，所以也可以到宿主机对应的`/root/mydata/docker_registry`路径下看有没有推送到私有仓库上的镜像。

![image-20210220132031813](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220132035.png) 

##### 7.2.5 从私有仓库拉取镜像

```bash
#直接使用docker pull命令进行拉取即可
docker pull 192.168.68.12:5000/test-hello-world:1.0.0
```

![image-20210220130821347](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220130823.png) 

##### 7.2.6 配置私有仓库认证

之前创建的私有仓库容器是不带认证功能的，这里要演示认证功能的话，就需要重新创建一个容器。为了防止误导，演示认证功能前我会把之前创建的私有仓库容器所有内容删除掉。

###### 7.2.6.1 生成自签名证书

**创建证书存储目录：**

```bash
mkdir -p /root/mydata/registry/certs
```

**生成自签名证书的命令：**

```bash
openssl req -newkey rsa:2048 -nodes -sha256 -keyout /root/mydata/registry/certs/domain.key -x509 -days 365 -out /root/mydata/registry/certs/domain.crt
```

- `openssl req`：创建证书签名请求等功能；
- `-newkey`：创建CSR证书签名文件和RSA私钥文件；
- `rsa:2048`：指定创建的RSA私钥长度为2048；
- `-nodes`：对私钥不进行加密；
- `-sha256`：使用SHA256算法；
- `-keyout`：用于指定创建私钥文件的名称及位置；
- `-x509`：自签发证书格式；
- `-days`：用于指定证书有效期(默认以天为单位)；
- `-out`：用于指定CSR输出文件的名称及位置。

执行生成自签名证书的命令后会需要填写一些证书信息，别的都可以随便填，但是`Common Name`这里不能乱填，这里填写的是私有仓库的地址。

```bash
[root@centos mydata]# openssl req -newkey rsa:2048 -nodes -sha256 -keyout /root/mydata/registry/certs/domain.key -x509 -days 365 -out /root/mydata/registry/certs/domain.crt
Generating a 2048 bit RSA private key
.....................................................................+++
..+++
writing new private key to '/root/mydata/registry/certs/domain.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:ZJ
Locality Name (eg, city) [Default City]:HZ
Organization Name (eg, company) [Default Company Ltd]:test
Organizational Unit Name (eg, section) []:testhelloworld
Common Name (eg, your name or your server's hostname) []:192.168.68.12
Email Address []:gongcqq@163.com
[root@centos mydata]# 
```

![image-20210220143500036](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220143502.png)  

###### 7.2.6.2 生成鉴权密码文件

```bash
#创建存储鉴权密码文件的目录
mkdir -p /root/mydata/registry/auth
#安装httpd，如果有的话就不用安装了
yum install -y httpd
#生成鉴权密码文件(下面的root是用户名，1234是密码)
htpasswd -Bbn root 1234 > /root/mydata/registry/auth/htpasswd
```

![image-20210220144202065](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220144216.png) 

> htpasswd是apache http的基本认证文件，使用htpasswd命令可以生成鉴权密码文件。

###### 7.2.6.3 创建带认证功能的私有仓库容器

**运行容器：**

```bash
docker run -di --name registry -p 5000:5000 \
-v /root/mydata/docker_registry:/var/lib/registry \
-v /root/mydata/registry/certs:/certs \
-v /root/mydata/registry/auth:/auth \
-e "REGISTRY_AUTH=htpasswd" \
-e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \
-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
-e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
registry
```

![image-20210220151810307](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220151812.png) 

###### 7.2.6.3 验证私有仓库容器的认证功能

可以通过以下步骤进行验证：

- 现在这个私有仓库容器运行后，没加认证功能前的那个[地址](http://192.168.68.12:5000/v2/_catalog)已经不能访问了(符合带认证功能的私有仓库的特点)；
- 使用`docker push`命令上传镜像到私有仓库也上传不上去了，而且报错信息是**no basic auth credentials**(没有基本身份验证凭据)；

![image-20210220152402964](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220153446.png) 

- 登录之后再试试镜像是否可以上传。这里使用`docker login 192.168.68.12:5000`命令进行登录，登录的时候要带上私有仓库的地址和端口，如果直接使用`docker login`命令登录的话，就登录到公共仓库了；

![image-20210220153133685](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220153135.png) 

- 上一步已经登录成功了，再次尝试上传镜像，发现可以上传成功，说明认证功能确实生效了；

![image-20210220153901768](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220153932.png) 

- 我们也可以到挂载目录下查看镜像是否上传成功，有我们上传的镜像，说明确实是没问题的；

![image-20210220154540182](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220154543.png) 

- 如果我们想要退出账号，可以使用`docker logout 192.168.68.12:5000`命令。退出账号后，就无法再往私有仓库上传镜像文件了。

![image-20210220161321399](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220184524.png) 

> 私有镜像仓库的搭建还可以通过Harbor实现，Harbor是由VMware公司开源的企业级Docker Registry管理项目，它包括权限管理(RBAC)、LDAP、日志审核、管理界面、自我注册、镜像复制和中文支持等功能。

### 8.Docker的网络

#### 8.1 默认网络

安装好Docker之后，会默认创建三种网络，可以使用`docker network ls`命令进行查看。

```bash
[root@centos ~]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
7c74f6e25ca6   bridge    bridge    local
5ff2819b1e79   host      host      local
3c2bd7b7cc2c   none      null      local
```

在学习网络模式之前，先了解一下docker中几种常见网络模式的含义：

| 网络模式  | 简介                                                         |
| --------- | ------------------------------------------------------------ |
| bridge    | 为每个容器分配、设置IP等，并将容器连接到一个`docker0`虚拟网桥，默认情况下使用该模式。 |
| host      | 容器不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 |
| none      | 容器有独立的网络名称空间，但并没有对其进行任何网络设置。     |
| container | 新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等。 |

##### 8.1.1 bridge网络模式

在该模式中，Docker守护进程创建了一个虚拟以太网桥`docker0`，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。

默认情况下，守护进程会创建一对对等虚拟设备接口`veth pair`，将其中一个接口设置为容器的`eth0`接口(容器的网卡)，另一个接口放置在宿主机的命名空间中，以类似`vethxxx`这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。

比如我运行一个基于`busybox`镜像构建的容器`bbox01`，查看`ip addr`：

> busybox被称为嵌入式Linux的瑞士军刀，整合了很多小的unix下的通用功能到一个小的可执行文件中。

![image-20210220165943530](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220165951.png) 

然后宿主机通过`ip addr`查看信息如下：

![image-20210220170034751](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170039.png) 

通过以上的比较可以发现，证实了之前所说的：守护进程会创建一对对等虚拟设备接口 `veth pair`，将其中一个接口设置为容器的 `eth0` 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 `vethxxx` 这样的名字命名。

同时，守护进程还会从网桥 `docker0` 的私有地址空间中分配一个IP地址和子网给该容器，并设置`docker0`的IP地址为容器的默认网关。也可以安装 `yum install -y bridge-utils` 以后，通过 `brctl show` 命令查看网桥信息。

![image-20210220170227120](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170229.png) 

对于每个容器的IP地址和Gateway信息，我们可以通过`docker inspect 容器名称|ID`进行查看，在`NetworkSettings`节点中可以看到详细信息。

![image-20210220170403405](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170406.png) 

我们可以通过 `docker network inspect bridge` 查看所有 `bridge` 网络模式下的容器，在 `Containers` 节点中可以看到容器名称。

![image-20210220170449073](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170451.png) 

> 关于 `bridge` 网络模式的使用，只需要在创建容器时通过参数 `--net bridge` 或者 `--network bridge` 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。

![image-20210220170600629](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220170603.png) 

`Bridge`桥接模式的实现步骤主要如下：

- Docker Daemon利用`veth pair`技术，在宿主机上创建一对对等虚拟网络接口设备，假设为veth0和veth1。而veth pair技术的特性可以保证无论哪一个veth接收到网络报文，都会将报文传输给另一方。
- Docker Daemon将veth0附加到Docker Daemon创建的docker0网桥上。保证宿主机的网络报文可以发往veth0；
- Docker Daemon将veth1添加到Docker Container所属的namespace下，并被改名为eth0。如此一来，宿主机的网络报文若发往veth0，则立即会被Container的eth0接收，实现宿主机到Docker Container网络的联通性；同时也保证Docker Container单独使用eth0，实现容器网络环境的隔离性。

##### 8.1.2 host网络模式

- host网络模式需要在使用`docker run`命令创建容器时通过参数`--net host`或者`--network host`指定；
- 采用host网络模式的 Docker Container，可以直接使用宿主机的IP地址与外界进行通信，若宿主机的eth0是一个公有IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行NAT转换；
- host网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。

![image-20210220172651653](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172654.png) 

比如我基于`host`网络模式创建了一个基于`busybox`镜像构建的容器`bbox02`，查看`ip addr`：

![image-20210220171714666](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220171730.png) 

然后宿主机通过`ip addr`查看信息如下：

![image-20210220171820751](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220171822.png) 

可以发现，返回的信息一模一样。我们也可以通过`docker network inspect host`查看所有`host`网络模式下的容器，在`Containers`节点中可以看到容器名称。

![image-20210220172007088](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172013.png) 

##### 8.1.3 none网络模式

- `none`网络模式是指禁用网络功能，只有lo接口(local的简写)，代表127.0.0.1，即localhost本地环回接口。可以在创建容器时通过参数`--net none`或者`--network none`指定使用该模式；
- `none`网络模式即不为Docker Container创建任何的网络环境，容器内部就只能使用loopback网络设备，不会再有其他的网络资源。可以说none模式为Docke Container做了极少的网络设定，但是俗话说得好“少即是多”，在没有网络配置的情况下，作为Docker开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了Docker设计理念的开放。

比如使用`none`网络模式创建一个基于`busybox`镜像构建的容器`bbox03`，查看`ip addr`：

![image-20210220172429451](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172436.png) 

我们可以通过`docker network inspect none`查看所有`none`网络模式下的容器，在`Containers`节点中可以看到容器名称。

![image-20210220172529999](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220172535.png) 

##### 8.1.4 container网络模式

- Container网络模式是Docker中一种较为特别的网络的模式。在创建容器时通过参数`--net container:已运行的容器名称|ID`或者`--network container:已运行的容器名称|ID`指定；
- 处于这个模式下的Docker容器会共享一个网络栈，这样两个容器之间可以使用localhost高效快速通信。

![905bc2](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174012.jpg) 

**`Container`网络模式即新创建的容器不会创建自己的网卡、配置自己的IP，而是和一个指定的容器共享IP、端口范围等**。两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。

比如我基于容器`bbox01`创建了`container`网络模式的容器`bbox04`，查看`ip addr`：

![image-20210220174315134](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174318.png) 

容器`bbox01`的`ip addr`信息如下：

![image-20210220174356258](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174358.png) 

宿主机的`ip addr`信息如下：

![image-20210220174425548](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174428.png) 

通过以上测试可以发现，Docker守护进程只创建了一对对等虚拟设备接口用于连接bbox01容器和宿主机，而bbox04容器则直接使用了bbox01容器的网卡信息。

这个时候如果将bbox01容器停止，会发现bbox04容器就只剩下lo接口了。

![image-20210220174519549](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174523.png) 

然后bbox01容器重启以后，bbox04容器也重启一下，就又可以获取到网卡信息了。

![image-20210220174600177](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220174602.png) 

#### 8.2 自定义网络

虽然Docker提供的默认网络使用比较简单，但是为了保证各容器中应用的安全性，在实际开发中更推荐使用自定义的网络进行容器管理，以及启用容器名称到IP地址的自动DNS解析。

> 从Docker 1.10版本开始，docker daemon实现了一个内嵌的DNS server，使容器可以直接通过容器名称通信。方法很简单，只要在创建容器时使用`--name`为容器命名即可。
>
> 但是使用Docker DNS有个限制：**只能在user-defined网络中使用**。也就是说，默认的bridge网络是无法使用DNS的，所以我们就需要自定义网络。

##### 8.2.1 创建网络

我们可以通过`docker network create`命令创建自定义网络模式，通过命令使用详情发现，可以通过`-d`指定网络模式且默认是`bridge`网络模式。

![image-20210220181039241](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220181041.png) 

那么如果我们创建一个基于`bridge`网络模式的自定义网络模式`custom_network`的话，完整命令就是下面这样：

```bash
docker network create custom_network
```

可以通过`docker network ls`命令查看网络模式：

![image-20210220181346101](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220181350.png) 

通过自定义网络模式`custom_network`创建容器：

```bash
docker run -di --name bbox01 --net custom_network busybox
```

![image-20210220181711320](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220181713.png) 

通过`docker inspect 容器名称|ID`查看容器的网络信息，在`NetworkSettings`节点中可以看到详细信息。

![image-20210220182239790](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220182241.png) 

##### 8.2.2 连接网络

通过`docker network connect 网络名称 容器名称`为容器连接新的网络模式，比如：

```bash
docker network connect bridge bbox01
```

通过`docker inspect 容器名称|ID`再次查看容器的网络信息，发现多增加了默认的`bridge`。

![image-20210220184440656](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220184457.png) 

##### 8.2.3 断开网络

通过`docker network disconnect 网络名称 容器名称`命令断开网络，比如：

```bash
docker network disconnect custom_network bbox01
```

通过`docker inspect 容器名称|ID`再次查看容器的网络信息，发现只剩下默认的`bridge`了。

![image-20210220185053224](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220185055.png) 

##### 8.2.4 移除网络

可以通过`docker network rm 网络名称`命令移除自定义网络模式，比如：

```bash
docker network rm custom_network
```

移除网络后再使用`docker network ls`命令查看，发现custom_network网络模式已经不存在了，说明移除成功了。

![image-20210220185447288](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220185451.png) 


> **注意**：如果通过某个自定义网络模式创建了容器，则该网络模式无法删除。

#### 8.3 容器间的网络通信

**通过容器IP进行容器间的网络通信：**

接下来通过所学的知识实现容器间的网络通信。首先明确一点，`容器之间要互相通信，必须要有属于同一个网络的网卡`。

我们先创建两个基于默认的`bridge`网络模式的容器：

```bash
docker run -di --name default_bbox01 busybox
docker run -di --name default_bbox02 busybox
```

通过`docker network inspect bridge`查看两容器的具体IP信息：

![image-20210220191328514](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220191332.png) 

然后测试两容器间是否可以进行网络通信：

![image-20210220192510396](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220192514.png) 

![image-20210220192835923](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220192839.png) 

经过测试，从结果得知两个属于同一个网络的容器是可以进行网络通信的，但是IP地址可能是不固定的，有被更改的情况发生，那容器内所有通信的IP地址也需要进行更改，能否使用容器名称进行网络通信？继续测试。

![image-20210220195337494](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220195343.png) 

由上图可知，使用容器名称进行网络通信是不行的，接下来就是实现通过容器名称进行通信。

**使用容器名称进行容器间的网络通信：**

- 先基于`bridge`网络模式创建自定义网络`custom_network`，命令如下：

```bash
docker network create custom_network
```

- 然后创建两个基于自定义网络模式的容器，命令如下：

```bash
docker run -di --name custom_bbox01 --net custom_network busybox
docker run -di --name custom_bbox02 --net custom_network busybox
```

- 通过`docker network inspect custom_network`查看两容器的具体IP信息：

![image-20210220200740370](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220200742.png) 

- 然后测试两容器间是否可以进行网络通信，分别使用**容器IP**和**容器名称**进行网络通信测试，发现都可以通信成功。

![image-20210220201404783](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220201434.png) 

> **结论**：两个属于同一个自定义网络的容器是可以进行网络通信的，不仅可以通过容器IP进行网络通信还可以使用容器名称进行网络通信。

如果此时我们希望`bridge`网络下的容器可以和`custom_network`网络下的容器进行网络通信的话，只要让`bridge`网络下的容器连接到自定义的`custom_network`网络模式即可，比如：

```bash
#先基于默认的bridge网络模式创建一个容器
docker run -di --name default_bbox01 busybox
#然后将这个容器连接到自定义的custom_network网络中
docker network connect custom_network default_bbox01
```

![image-20210220203518964](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220204710.png) 

![image-20210220204707720](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210220204720.png) 

### 9.Docker Compose

#### 9.1 Compose简介































































