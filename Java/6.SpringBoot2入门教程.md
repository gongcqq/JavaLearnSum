### 1.编写一个HelloWorld

#### 1.1 版本问题

`SpringBoot2要求jdk至少要是1.8或者以上版本，maven至少3.3以上版本。`

#### 1.2 新建一个maven项目

![1](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235915.jpg) 

![2](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235927.jpg) 

![3](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108234926.jpg) 

![4](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235941.jpg) 

![5](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235949.png) 

#### 1.3 配置maven的settings.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">

  <localRepository>E:\self-study\mvn_repository</localRepository>

  <mirrors>
     <mirror>
        <id>nexus-aliyun</id>
        <name>aliyun maven</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public</url>
        <mirrorOf>central</mirrorOf>
     </mirror>
  </mirrors>

  <profiles>
    <profile>
        <id>jdk-1.8</id>
        <activation>
          <activeByDefault>true</activeByDefault>
          <jdk>1.8</jdk>
        </activation>
        <properties>
          <maven.compiler.source>1.8</maven.compiler.source>
          <maven.compiler.target>1.8</maven.compiler.target>
          <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
        </properties>
    </profile>
  </profiles>
</settings>
```

#### 1.4 pom.xml文件中引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.gongsl</groupId>
    <artifactId>SpringBootProject</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.7.RELEASE</version>
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

    <!--spring-boot-maven-plugin可以为我们创建一个可执行的jar-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

#### 1.5 创建启动类

```java
package com.gongsl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class,args);
    }
}
```

`启动类中的run方法是有返回值的，返回值就是IOC容器。`

#### 1.6 编写业务代码

```java
package com.gongsl.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: gongsl
 * @Date: 2021-01-08 18:19
 */
@RestController
public class HelloController {

    @RequestMapping("/hello")
    public String home(){
        return "Hello SpringBoot2!";
    }
}
```

#### 1.7 运行测试

执行`MainApplication`类的`main`方法，然后浏览器地址栏输入 http://localhost:8080/hello 进行访问即可。

#### 1.8 修改端口启动

在maven项目的`src\main\resources`目录下新增`application.properties`配置文件，然后在文件中新增以下内容：

```properties
server.port=8081
```

这时端口就已经被修改成**8081**了，然后重新运行启动类的`main`方法，最后在浏览器地址栏输入 http://localhost:8081/hello 进行访问即可。

#### 1.9 通过cmd窗口启动项目

如果我们在pom.xml文件中加了`spring-boot-maven-plugin`这个依赖的话，那么使用maven打成的包就是一个可执行的jar包。我们可以在cmd窗口中进行演示，这里需要用到`java -jar`命令，如下所示：

![演示](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210109000012.gif) 

#### 1.10 注意事项

1. 如果浏览器地址栏访问url出现问题，首先检查是不是`MainApplication`启动类的位置有问题。该类一定要放在最外侧，要保证能够扫描到所有的controller,因为SpringBoot会自动加载启动类所在包下以及其子包下的所有组件；
2. 如果我们不想把启动类放在最外侧，或者想要自定义被扫描的包及其下的controller类的话，也是可以实现的，只需要在启动类的`@SpringBootApplication`注解中增加`scanBasePackages`参数即可，比如扫描`com.gongsl`包下的所有内容，就配置为`@SpringBootApplication(scanBasePackages = "com.gongsl")`即可；
3. 上面`HelloController`类上用的是`@RestController`注解，这个注解就是`@Controller`和`@ResponseBody`的组合注解；
4. 如果想知道`application.properties`配置文件中可以写哪些东西，那么我们可以参考[官方文档](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties)。

### 2.SpringBoot简介

#### 2.1 为什么使用SpringBoot

- SpringBoot能快速创建出生产级别的Spring应用。

#### 2.2 SpringBoot的优点

- 可以创建独立的Spring应用；
- 内嵌了web服务器；
- 自动starter依赖，简化了构建配置；
- 自动配置Spring以及第三方功能；
- 提供生产级别的监控、健康检查及外部化配置；
- 无代码生成、无需编写XML文件等。

`SpringBoot是整合Spring技术栈的一站式框架，也是简化Spring技术栈的快速开发脚手架。`

#### 2.3 SpringBoot的缺点

- 人称版本帝，迭代快，需要时刻关注变化；
- 封装太深，内部原理复杂，不容易精通。

#### 2.4 SpringBoot的时代背景

##### 2.4.1 微服务

- 微服务是一种架构风格；
- 微服务是一个应用拆分为一组小型服务；
- 每个服务运行在自己的进程内，也就是可独立部署和升级；
- 服务之间使用轻量级HTTP进行交互；
- 服务围绕业务功能拆分；
- 服务可以由全自动部署机制独立部署；
- 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术。

##### 2.4.2 分布式

###### 2.4.2.1 分布式的困难

- 远程调用

- 服务发现

- 负载均衡

- 服务容错

- 配置管理

- 服务监控

- 链路追踪

- 日志管理

- 任务调度

- ......

###### 2.4.2.2 分布式的解决方案

- SpringBoot + SpringCloud

##### 2.4.3 云原生

###### 2.4.3.1 上云的困难

- 服务自愈

- 弹性伸缩

- 服务隔离

- 自动化部署

- 灰度发布

- 流量治理

- ......

###### 2.4.3.2 上云的解决方案

- Cloud Native

#### 2.5 SpringBoot的特点

##### 2.5.1 依赖管理

###### 2.5.1.1 父项目做依赖管理

```xml
<!-- 通过spring-boot-starter-parent这个父项目做依赖管理 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.7.RELEASE</version>
</parent>

<!-- spring-boot-starter-parent这个父项目中还有下面这个父项目 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.7.RELEASE</version>
</parent>
```

`spring-boot-dependencies`这个父项目中几乎声明了所有开发中常用的依赖的版本号,这个就是自动版本仲裁机制。

###### 2.5.1.2 导入starter作为场景启动器

- 我们以后在pom.xml文件中会见到很多`spring-boot-starter-*`这种配置，这个就是场景启动器，后面的*号就代表了某种场景；
- 只要引入了某个场景的starter，这个场景的所有常规需要的依赖都会被自动引入；
- 如果我们想知道SpringBoot支持哪些场景的starter，可以到[官方文档](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/using-spring-boot.html#using-boot-starter)中进行查阅；
- 像`*-spring-boot-starter`这种starter一般都是第三方为我们提供的简化开发的场景启动器；
- 所有场景启动器最底层的依赖就是下面这个。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <version>2.3.7.RELEASE</version>
    <scope>compile</scope>
</dependency>
```

###### 2.5.1.3 自动版本仲裁

- 自动版本仲裁功能可以让我们无需关注版本号，因为在`spring-boot-dependencies`这个父项目中，所有涉及的依赖的版本号都已经配置在了`properties`标签下了，所以我们引入依赖时默认可以不写版本号；
- 不过引入非版本仲裁的jar包时，要写版本号。

###### 2.5.1.4 能够修改默认版本号 

我们也可以修改默认版本号。首先要在`spring-boot-dependencies`这个父项目中查看需要修改版本号的依赖的标签名是什么，比如mysql版本号对应的标签名就是`mysql.version`，假设我们想修改mysql的版本号为`5.1.43`，那就直接在项目的pom.xml文件中加入如下内容即可。

```xml
<properties>
    <mysql.version>5.1.43</mysql.version>
</properties>
```

##### 2.5.2 自动配置

假设就以`spring-boot-starter-web`这个依赖为例。

- 只要引入了上面那个web依赖，SpringBoot就会为我们自动引入tomcat依赖，自动给我们配置好tomcat；
- 同样会引入SpringMVC的全套组件，并自动配好SpringMVC的常用功能；
- 还会自动配好Web常见功能，比如字符编码问题等，并帮我们配置好了所有web开发的常见场景；
- SpringBoot也会为我们配置一个默认的包扫描路径，不用再手动进行包扫描的配置；
- SpringBoot为我们提供的各种配置都会赋予一个默认值
  - 默认配置最终都是映射到某个类上，如：MultipartProperties；
  - 配置文件的值最终会绑定某个类上，这个类会在容器中创建对象。
- SpringBoot是按需加载所有自动配置项，我们引入了哪些场景，这个场景的自动配置才会开启；
- SpringBoot所有的自动配置功能都在`spring-boot-autoconfigure`包里面，比如`spring-boot-autoconfigure-2.3.7.RELEASE.jar`包。

### 3.常用注解的使用

#### 3.1 @bean注解和@Configuration注解

##### 3.1.1 前置准备

###### 3.1.1.1 引入依赖

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

这里引入lombok依赖时不用加版本号，因为SpringBoot的自动版本仲裁功能已经为我们设置好了对应的版本号，我们可以在`spring-boot-dependencies`这个父项目中根据`lombok.version`标签查看到对应的版本号是什么。

###### 3.1.1.2 增加两个实体类

```java
package com.gongsl.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.ToString;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:27
 */
@Data
@ToString
@AllArgsConstructor
public class User {
    private String name;
    private Integer age;
    private String gender;
}
```

```java
package com.gongsl.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.ToString;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:33
 */
@Data
@ToString
@AllArgsConstructor
public class Pet {
    private String name;
}
```

###### 3.1.1.3 新增配置类

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration
public class MyConfig {

    @Bean
    public User userTest(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

##### 3.1.2 @bean、@Configuration的用法

- 之前Spring想要将某个组件放到IOC容器中，一般会在一个xml配置文件中进行配置，而SpringBoot不再使用配置文件，而是使用配置类，我们可以新建一个类，比如`MyConfig`类，然后只要我们在这个类上加上`@Configuration`注解，那这个类就是**配置类**，这个类等同于之前我们使用的配置文件；
- 以前在配置文件中，我们可以使用`bean`标签来给容器添加组件，现在我们在配置类中的方法上使用`@Bean`注解可以完成同样的效果；
- 以上面的`userTest`方法为例，该方法使用了`@bean`注解，就表示向容器中添加了一个组件，方法名就是组件id，方法的返回类型就是组件的类型，方法的返回值就是组件在容器中的实例；
- 如果我们不希望方法名作为容器中组件的id的话，也可以自定义，比如把上面配置类中`userTest`方法的`@bean`注解改成`@Bean("user")`，就把组件id改为"user"了，我们可以在启动类中进行验证，如下所示：

**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration
public class MyConfig {

    @Bean("user")
    public User userTest(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

**启动类：**

```java
package com.gongsl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        //获取所有组件id的名称
        String[] beanNames = run.getBeanDefinitionNames();
        for (String name : beanNames) {
            if("user".equals(name) || "petCat".equals(name)){
                System.out.print(name+" ");
            }
        }
    }
}

//运行结果：user petCat
```

- 配置类中使用`@bean`注解在方法上给容器注册的组件，默认是单实例的。由于是单实例，所以容器中同一个实例无论怎么获取，获取多少次，都是一样的，验证如下：

```java
package com.gongsl;

import com.gongsl.bean.Pet;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        Pet pet1 = run.getBean(Pet.class);
        Pet pet2 = run.getBean(Pet.class);
        System.out.println(pet1==pet2);//运行结果：true

        //通过组件id更精确地获取
        Pet petCat1 = run.getBean("petCat", Pet.class);
        Pet petCat2 = run.getBean("petCat", Pet.class);
        System.out.println(petCat1==petCat2);//运行结果：true
    }
}
```

- 配置类本身也是容器中的一个组件。如果不是的话，当我们从容器中获取的时候是会报错的，验证如下：

```java
package com.gongsl;

import com.gongsl.config.MyConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        MyConfig bean = run.getBean(MyConfig.class);
        System.out.println(bean);
    }
}

//运行结果：com.gongsl.config.MyConfig$$EnhancerBySpringCGLIB$$33e871dd@55f45b92
```

##### 3.1.3 proxyBeanMethods属性的用法

1. 和SpringBoot1相比，SpringBoot2中的`@Configuration`注解新增了一个`proxyBeanMethods`属性(这个属性是Spring5.2版本以后才有的，SpringBoot2中Spring的版本就是5.2)，该属性的默认值是true；
2. 外部无论对配置类中已经使用`@bean`注解注册到容器中的组件方法调用多少次，获取到的都是已经注册到容器中的单实例对象，之所以出现这种情况，就是因为配置类的`@Configuration`注解中`proxyBeanMethods`属性的默认值是true的原因；
3. 当配置类的`@Configuration`注解中`proxyBeanMethods`属性为true时，如果我们直接从容器中获取配置类，可以发现，获取到的结果是`com.gongsl.config.MyConfig$$EnhancerBySpringCGLIB$$33e871dd@55f45b92`。从结果中的`EnhancerBySpringCGLIB`可以发现，`MyConfig`类并不是一个普通的配置类，而是一个被SpringCGLIB增强了的代理对象；
4. 当`proxyBeanMethods`属性为true时，如果我们调用配置类中使用过`@bean`注解的方法，比如`petCat()`方法，那么SpringBoot总会检查该方法是否已经被注册到容器中，如果发现容器中有该方法返回的组件，那么就直接从容器中获取，这时候无论我们调用多少次`petCat()`方法，返回的Pet对象都是同一个，即之前放入容器中的那一个；
5. 如果`proxyBeanMethods`属性为false，那么当我们调用`petCat()`方法时，SpringBoot就不会再检查该方法是否已经被注册到容器中，自然也就不会再从容器中获取组件，而是直接调用该方法，由于`petCat()`方法中的逻辑就是创建一个Pet对象，所以这时每调用一次`petCat()`方法就会创建一个新的Pet对象，这样每次调用`petCat()`方法返回的Pet对象就都不相同了，代码验证如下：

**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration(proxyBeanMethods = false)
public class MyConfig {

    @Bean("user")
    public User userTest(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

**启动类：**

```java
package com.gongsl;

import com.gongsl.bean.Pet;
import com.gongsl.config.MyConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        MyConfig bean = run.getBean(MyConfig.class);
        System.out.println(bean);//运行结果：com.gongsl.config.MyConfig@437ebf59

        Pet pet1 = bean.petCat();
        Pet pet2 = bean.petCat();
        System.out.println(pet1==pet2);//运行结果：false
    }
}
```

当配置类中的`proxyBeanMethods`属性为false时，我们可以发现，pet1和pet2并不是同一个对象，而且从容器中获取的配置类也不带`EnhancerBySpringCGLIB`了，而变成了`com.gongsl.config.MyConfig@437ebf59`。如果我们把配置类中的`proxyBeanMethods`属性设置成true的话，上面pet1和pet2就会是同一个对象，运行结果也自然就是true了。

6. test



























































