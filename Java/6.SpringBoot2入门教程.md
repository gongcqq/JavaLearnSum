### 1.编写一个HelloWorld

#### 1.1 版本问题

`SpringBoot2要求jdk至少要是1.8或者以上版本，maven至少3.3以上版本。`

#### 1.2 新建一个maven项目

![1](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235915.jpg) 

![2](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235927.jpg) 

![3](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108234926.jpg) 

![4](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235941.jpg) 

![image-20210108224915841](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235949.png) 

#### 1.3 配置maven的settings.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">

  <localRepository>E:\self-study\mvn_repository</localRepository>

  <mirrors>
     <mirror>
        <id>nexus-aliyun</id>
        <name>aliyun maven</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public</url>
        <mirrorOf>central</mirrorOf>
     </mirror>
  </mirrors>

  <profiles>
    <profile>
        <id>jdk-1.8</id>
        <activation>
          <activeByDefault>true</activeByDefault>
          <jdk>1.8</jdk>
        </activation>
        <properties>
          <maven.compiler.source>1.8</maven.compiler.source>
          <maven.compiler.target>1.8</maven.compiler.target>
          <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
        </properties>
    </profile>
  </profiles>
</settings>
```

#### 1.4 pom.xml文件中引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.gongsl</groupId>
    <artifactId>SpringBootProject</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.7.RELEASE</version>
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

    <!--spring-boot-maven-plugin可以为我们创建一个可执行的jar-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

#### 1.5 创建启动类

```java
package com.gongsl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class,args);
    }
}
```

#### 1.6 编写业务代码

```java
package com.gongsl.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: gongsl
 * @Date: 2021-01-08 18:19
 */
@RestController
public class HelloController {

    @RequestMapping("/hello")
    public String home(){
        return "Hello SpringBoot2!";
    }
}
```

#### 1.7 运行测试

执行`MainApplication`类的`main`方法，然后浏览器地址栏输入 http://localhost:8080/hello 进行访问即可。

#### 1.8 修改端口启动

在maven项目的`src\main\resources`目录下新增`application.properties`配置文件，然后在文件中新增以下内容：

```properties
server.port=8081
```

这时端口就已经被修改成**8081**了，然后重新运行启动类的`main`方法，最后在浏览器地址栏输入 http://localhost:8081/hello 进行访问即可。

#### 1.9 通过cmd窗口启动项目

如果我们在pom.xml文件中加了`spring-boot-maven-plugin`这个依赖的话，那么使用maven打成的包就是一个可执行的jar包。我们可以在cmd窗口中进行演示，这里需要用到`java -jar`命令，如下所示：

![演示](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210109000012.gif) 

#### 1.10 注意事项

1. 如果浏览器地址栏访问url出现问题，首先检查是不是`MainApplication`启动类的位置有问题。该类一定要放在最外侧，要保证能够扫描到所有的controller,因为SpringBoot会自动加载启动类所在包下以及其子包下的所有组件；
2. 如果我们不想把启动类放在最外侧，或者想要自定义被扫描的包及其下的controller类的话，也是可以实现的，只需要在启动类的`@SpringBootApplication`注解中增加`scanBasePackages`参数即可，比如扫描`com.gongsl`包下的所有内容，就配置为`@SpringBootApplication(scanBasePackages = "com.gongsl")`即可；
3. 上面`HelloController`类上用的是`@RestController`注解，这个注解就是`@Controller`和`@ResponseBody`的组合注解；
4. 如果想知道`application.properties`配置文件中可以写哪些东西，那么我们可以参考[官方文档](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties)。

### 2.SpringBoot简介

#### 2.1 为什么使用SpringBoot

- SpringBoot能快速创建出生产级别的Spring应用。

#### 2.2 SpringBoot的优点

- 可以创建独立的Spring应用；
- 内嵌了web服务器；
- 自动starter依赖，简化了构建配置；
- 自动配置Spring以及第三方功能；
- 提供生产级别的监控、健康检查及外部化配置；
- 无代码生成、无需编写XML文件等。

`SpringBoot是整合Spring技术栈的一站式框架，也是简化Spring技术栈的快速开发脚手架。`

#### 2.3 SpringBoot的缺点

- 人称版本帝，迭代快，需要时刻关注变化；
- 封装太深，内部原理复杂，不容易精通。

#### 2.4 SpringBoot的时代背景

##### 2.4.1 微服务

- 微服务是一种架构风格；
- 微服务是一个应用拆分为一组小型服务；
- 每个服务运行在自己的进程内，也就是可独立部署和升级；
- 服务之间使用轻量级HTTP进行交互；
- 服务围绕业务功能拆分；
- 服务可以由全自动部署机制独立部署；
- 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术。

##### 2.4.2 分布式

###### 2.4.2.1 分布式的困难

- 远程调用

- 服务发现

- 负载均衡

- 服务容错

- 配置管理

- 服务监控

- 链路追踪

- 日志管理

- 任务调度

- ......

###### 2.4.2.2 分布式的解决方案

- SpringBoot + SpringCloud

##### 2.4.3 云原生

###### 2.4.3.1 上云的困难

- 服务自愈

- 弹性伸缩

- 服务隔离

- 自动化部署

- 灰度发布

- 流量治理

- ......

###### 2.4.3.2 上云的解决方案

- Cloud Native

#### 2.5 SpringBoot的特点

##### 2.5.1 依赖管理

###### 2.5.1.1 父项目做依赖管理

```xml
<!-- 通过spring-boot-starter-parent这个父项目做依赖管理 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.7.RELEASE</version>
</parent>

<!-- spring-boot-starter-parent这个父项目中还有下面这个父项目 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.7.RELEASE</version>
</parent>
```

`spring-boot-dependencies`这个父项目中几乎声明了所有开发中常用的依赖的版本号,这个就是自动版本仲裁机制。

###### 2.5.1.2 导入starter作为场景启动器

- 我们以后在pom.xml文件中会见到很多`spring-boot-starter-*`这种配置，这个就是场景启动器，后面的*号就代表了某种场景；
- 只要引入了某个场景的starter，这个场景的所有常规需要的依赖都会被自动引入；
- 如果我们想知道SpringBoot支持哪些场景的starter，可以到[官方文档](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/using-spring-boot.html#using-boot-starter)中进行查阅；
- 像`*-spring-boot-starter`这种starter一般都是第三方为我们提供的简化开发的场景启动器；
- 所有场景启动器最底层的依赖就是下面这个。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <version>2.3.7.RELEASE</version>
    <scope>compile</scope>
</dependency>
```

###### 2.5.1.3 自动版本仲裁

- 自动版本仲裁功能可以让我们无需关注版本号，因为在`spring-boot-dependencies`这个父项目中，所有涉及的依赖的版本号都已经配置在了`properties`标签下了，所以我们引入依赖时默认可以不写版本号；
- 不过引入非版本仲裁的jar包时，要写版本号。

###### 2.5.1.4 能够修改默认版本号 

我们也可以修改默认版本号。首先要在`spring-boot-dependencies`这个父项目中查看需要修改版本号的依赖的标签名是什么，比如mysql版本号对应的标签名就是`mysql.version`，假设我们想修改mysql的版本号为`5.1.43`，那就直接在项目的pom.xml文件中加入如下内容即可。

```xml
<properties>
    <mysql.version>5.1.43</mysql.version>
</properties>
```

##### 2.5.2 自动配置

假设就以`spring-boot-starter-web`这个依赖为例。

- 只要引入了上面那个web依赖，SpringBoot就会为我们自动引入tomcat依赖，自动给我们配置好tomcat；
- 同样会引入SpringMVC的全套组件，并自动配好SpringMVC的常用功能；
- 还会自动配好Web常见功能，比如字符编码问题等，并帮我们配置好了所有web开发的常见场景；
- SpringBoot也会为我们配置一个默认的包扫描路径，不用再手动进行包扫描的配置；
- SpringBoot为我们提供的各种配置都会赋予一个默认值
  - 默认配置最终都是映射到某个类上，如：MultipartProperties；
  - 配置文件的值最终会绑定某个类上，这个类会在容器中创建对象。
- SpringBoot是按需加载所有自动配置项，我们引入了哪些场景，这个场景的自动配置才会开启；
- SpringBoot所有的自动配置功能都在`spring-boot-autoconfigure`包里面，比如`spring-boot-autoconfigure-2.3.7.RELEASE.jar`包。









