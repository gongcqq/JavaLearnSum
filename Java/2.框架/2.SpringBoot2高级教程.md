### 1.SpringBoot入门案例

#### 1.1 快速创建SpringBoot工程

下面就通过`Spring Initializr`联网创建一个SpringBoot项目，步骤如下：

![第一步](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322191936.jpg) 

![第二步](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322191946.jpg) 

![image-20220322112335916](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192004.png) 

默认创建的SpringBoot工程中会有一些用不到的文件，直接删掉就行。然后配置文件我们一般使用yaml文件，修改后的目录结构如下：

![image-20220322112738473](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192013.png) 

以上是使用IDEA联网创建SpringBoot项目的，如果网速不好，也可以直接使用官网的[Spring Initializr](https://start.spring.io/)创建项目并下载，如下所示：

![image-20220322114938519](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192019.png) 

如果我们担心Spring官网访问较慢，也可以在IDEA中创建Spring Initializr时，使用阿里云的[Server URL](https://start.aliyun.com/)快速创建一个和官网一样的SpringBoot项目，如下所示：

![Snipaste_2022-03-22_12-42-28](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192025.jpg) 

![Snipaste_2022-03-22_12-47-51](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192031.jpg) 

> **说明**：使用阿里云的地址创建SpringBoot项目，在选择依赖时，会多出来很多阿里的产品，也会出现中文，这些都是正常现象。

#### 1.2 关于REST风格

![image-20220322153612530](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192038.png) 

![image-20220322153952901](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192049.png) 

### 2.SpringBoot的配置

#### 2.1 配置项的查找

众所周知，SpringBoot默认可以使用`application.properties`、`application.yaml`、`application.yml`作为配置文件，但是配置文件中的配置项有很多，虽然我们在配置文件中打出关键字后会有提示，但是如果我们连关键字都不清楚，那么又该如何配置呢？下面就介绍下如何在Spring官网查找SpringBoot的所有配置项，如下所示：

1. 首先进入[Spring官网](https://spring.io/)并选择SpringBoot：

   ![image-20220322161609360](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192059.png) 

2. 随便选择某个版本的SpringBoot，并点击右侧的`Reference Doc.`：

   ![image-20220322161814282](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192104.png) 

3. 进入新页面后，滑动到页面最后面，并点击`Application Properties`：

   ![image-20220322162228891](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192113.png) 

4. 然后就可以看到SpringBoot的所有配置项了，如下所示：

   ![image-20220322163041968](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192122.png)  

> **说明**：我们也可以直接点击[SpringBoot配置项](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties)快速查看SpringBoot的所有配置项。

#### 2.2 配置文件的优先级

SpringBoot默认可以使用`application.properties`、`application.yaml`、`application.yml`这三种配置文件，并且这三个配置文件是可以共存的，如果共存，并且都配置相同的配置项的话，优先级如下所示：

```properties
application.properties > application.yml > application.yaml
```

> **说明**：由于application.properties的优先级最高，假设三个配置文件共存，并且存在相同的配置项，那么最终生效的就是application.properties文件中的配置。如果三个配置文件中没有相同的配置项，那么三个配置文件中的所有配置项都会生效。生产环境下，一般只会存在一个配置文件，推荐使用application.yml作为配置文件。

当存在多个配置文件时，会出现在配置文件中打出配置项关键字后不显示提醒的情况，对于这种现象，解决办法如下：

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192136.png" alt="image-20220322181412366" style="zoom:95%;" /> 

![image-20220322191802712](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220322192142.png) 

#### 2.3 配置文件内容的读取

##### 2.3.1 读取配置文件的单个属性

为了演示方便，这里对application.yml配置文件增加如下内容：

```yaml
gongsl: "Hello World"
test:
  open: true
  price: 12.8
  # 我们可以使用~表示null
  isnull: ~
  user:
    - name: Tom
      age: 18
    - name: Jerry
      age: 22
  language:
    - Java
    - Go
    - Python
  subject:
    math: 86
    english: 75
    chinese: 92
```

测试类中的内容及运行结果如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Value("${gongsl}")
    private String str;

    @Value("${test.open}")
    private Boolean aBoolean;

    @Value("${test.price}")
    private float aFloat;

    @Value("${test.isnull}")
    private String strTest;

    @Value("${test.isnull}")
    private Integer object;

    @Value("${test.language[0]}")
    private String language;

    @Value("${test.user[0].name}")
    private String name;

    @Value("${test.subject.math}")
    private Integer math;

    /**
     * 对于配置文件中不存在的属性，使用默认值
     */
    @Value("${test.nothing:default}")
    private String nothing;

    @Test
    public void testMethod() {
        System.out.println("str = " + str);// 运行结果：str = Hello World
        System.out.println("aBoolean = " + aBoolean);// 运行结果：aBoolean = true
        System.out.println("aFloat = " + aFloat);// 运行结果：aFloat = 12.8
        System.out.println("strTest = " + strTest);// 运行结果：strTest =
        System.out.println("object = " + object);// 运行结果：object = null
        System.out.println("language = " + language);// 运行结果：language = Java
        System.out.println("name = " + name);// 运行结果：name = Tom
        System.out.println("math = " + math);// 运行结果：math = 86
        System.out.println("nothing = " + nothing);// 运行结果：nothing = default
    }
}
```

##### 2.3.2 读取配置文件的部分属性

这里主要是使用`@ConfigurationProperties`注解的方式。application.yml配置文件的内容和上面读取单个属性时的保持一致，然后新增如下几个实体类：

```java
package com.gsl;

import lombok.Data;

@Data
public class User {
    private String name;
    private Integer age;
}
```

```java
package com.gsl;

import lombok.Data;

@Data
public class Subject {
    private Integer math;
    private Integer english;
    private Integer chinese;
}
```

```java
package com.gsl;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import java.util.List;

/**
 * @Author: gongsl
 * @Date: 2022-03-28 18:19
 */
@Data
@Component
@ConfigurationProperties(prefix = "test")
public class MyTest {
    private Boolean open;
    private float price;
    private List<User> user;
    private List<String> language;
    private Subject subject;
}
```

然后通过`@Autowired`注解注入MyTest类进行测试即可，测试类如下所示：

```java
package com.gsl;

import com.alibaba.fastjson.JSON;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Autowired
    private MyTest myTest;

    @Test
    public void testMethod() {
        String string = JSON.toJSONString(myTest);
        System.out.println(string);
    }
}
```

通过debug的方式可以看到MyTest类中各个属性值内容如下：

![image-20220328184840998](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402153711.png) 

将MyTest类转成json串后如下所示：

```json
{"language":["Java","Go","Python"],"open":true,"price":12.8,"subject":{"chinese":92,"english":75,"math":86},"user":[{"age":18,"name":"Tom"},{"age":22,"name":"Jerry"}]}
```

##### 2.3.3 读取配置文件的全部属性

默认情况下，application.yml配置文件中的全部内容都会被封装在`org.springframework.core.env.Environment`类中，所以只要我们注入该类，就可以获取配置文件中的任何属性值了。默认有两种使用Environment类的方式，下面将依次进行介绍。

###### 2.3.3.1 使用注解注入

第一种是使用`@Autowired`注解进行注入，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.core.env.Environment;

@SpringBootTest
class ApplicationTests {

    @Autowired
    private Environment env;

    @Test
    public void testMethod() {
        String language = env.getProperty("test.language[0]");
        System.out.println("language = " + language);// 运行结果：language = Java
        Boolean property = env.getProperty("test.open", Boolean.class);
        System.out.println("result = " + property);// 运行结果：result = true
    }
}
```

###### 2.3.3.2 实现指定接口

另一种是实现`org.springframework.context.EnvironmentAware`接口，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.EnvironmentAware;
import org.springframework.core.env.Environment;

@SpringBootTest
class ApplicationTests implements EnvironmentAware {

    private Environment env;

    @Test
    public void testMethod() {
        String language = env.getProperty("test.language[0]");
        System.out.println("language = " + language);// 运行结果：language = Java
        Boolean property = env.getProperty("test.open", Boolean.class);
        System.out.println("result = " + property);// 运行结果：result = true
    }

    @Override
    public void setEnvironment(Environment environment) {
        env = environment;
    }
}
```

###### 2.3.3.3 最佳实践

为了方便获取配置文件中的属性值，我们一把会封装一个SpringUtils工具类，内容如下所示：

```java
package com.gsl.utils;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

/**
 * @Author: gongsl
 * @Date: 2022-03-28 21:03
 */
@Component
public class SpringUtils implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext context) throws BeansException {
        if (applicationContext == null) {
            applicationContext = context;
        }
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    /**
     * 根据name获取bean
     * @param name
     * @return
     */
    public static Object getBean(String name) {
        return getApplicationContext().getBean(name);
    }

    /**
     * 根据类型获取bean
     * @param clazz
     * @return
     */
    public static <T> T getBean(Class<T> clazz) {
        return getApplicationContext().getBean(clazz);
    }

    public static <T> T getBean(String name, Class<T> clazz) {
        return getApplicationContext().getBean(name, clazz);
    }

    /**
     * 根据配置文件的属性获取对应属性值
     * @param name
     * @return
     */
    public static String getProperty(String name) {
        return getApplicationContext().getEnvironment().getProperty(name);
    }

    /**
     * 获取不到属性值时使用默认值
     * @param name
     * @param defaultValue
     * @return
     */
    public static String getProperty(String name, String defaultValue) {
        return getApplicationContext().getEnvironment().getProperty(name, defaultValue);
    }

    public static <T> T getProperty(String name, Class<T> clazz) {
        return getApplicationContext().getEnvironment().getProperty(name, clazz);
    }
}
```

然后在测试类中，直接使用工具类就可以了，如下所示：

```java
package com.gsl;

import com.gsl.utils.SpringUtils;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Test
    public void testMethod() {
        String property = SpringUtils.getProperty("test.subject.math");
        System.out.println("property = " + property);// 运行结果：property = 86
    }
}
```

##### 2.3.4 配置文件中的变量引用

在配置文件中，可能存在某些属性的某些部分是一样的，比如下面这样：

```yaml
logsDir: C:\Windows\Logs
tempDir: C:\Windows\Temp
```

这种情况下，我们就可以考虑抽取出相同的部分，然后再进行变量引用，如下所示：

```yaml
baseDir: C:\Windows
logsDir: ${baseDir}\Logs
tempDir: ${baseDir}\Temp
```

测试类中获取对应属性值的方式以及运行结果如下所示：

```java
package com.gsl;

import com.gsl.utils.SpringUtils;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Test
    public void testMethod() {
        String logsDir = SpringUtils.getProperty("logsDir");
        System.out.println("logsDir = " + logsDir);// 运行结果：logsDir = C:\Windows\Logs
        String tempDir = SpringUtils.getProperty("tempDir");
        System.out.println("tempDir = " + tempDir);// 运行结果：tempDir = C:\Windows\Temp
    }
}
```

##### 2.3.5 关于@Value注解的多种用法

为了下面的演示方便，这里给application.yml配置文件准备了以下数据：

```yaml
gsl:
  name: Mark
  friends: Tom,Jerry,Lucy
  user: "{'name':'Mark','age':27}"
```

> **说明**：可以点击[value-annotations](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-value-annotations)访问官网查看`@Value`注解的详细用法，或者点击[SpEL](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions)查看SpEL表达式的详细用法。

###### 2.3.5.1 获取属性值

这个是最常规的一种用法，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Value("${gsl.name}")
    private String name;

    @Test
    public void testMethod() {
        System.out.println("name = " + name);// 运行结果：name = Mark
    }
}
```

我们在获取配置文件中的内容时，如果执行的属性不存在，也可以设置默认的属性值，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Value("${gsl.other:defaultValue}")
    private String other;

    @Test
    public void testMethod() {
        System.out.println("other = " + other);// 运行结果：other = defaultValue
    }
}
```

> **说明**：使用`@Value`注解设置默认值时，只有配置文件中取不到对应属性的属性值才会使用默认值；如果配置文件中没有对应属性，注解中又没设置默认值，那么运行会报错。

###### 2.3.5.2 设置固定值

这种方式不会从配置文件中读取值，而是直接使用`@Value`注解中的值，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Value("男")
    private String gender;

    @Test
    public void testMethod() {
        System.out.println("gender = " + gender);// 运行结果：gender = 男
    }
}
```

###### 2.3.5.3 调用对象方法

上面在使用`@Value`注解时，有用到==$==符号，这里会介绍到==#==的用法。`@Value("#{}")`表示用来获取bean的属性，或者调用bean的某个方法，当然也可以表示常量。

<font color="aquamarine blue">调用字符串对象的方法：</font>

配置文件中的`gsl.friends`属性值是一个以逗号分隔的多个人名的字符串，下面通过逗号进行截取，把这些人名都放入到一个集合中，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import java.util.List;

@SpringBootTest
class ApplicationTests {

    @Value("#{'${gsl.friends}'.split(',')}")
    private List<String> friends;

    @Test
    public void testMethod() {
        System.out.println("friends = " + friends);// 运行结果：friends = [Tom, Jerry, Lucy]
    }
}
```

<font color="aquamarine blue">调用其他对象的方法：</font>

我们也可以直接调用其他某些对象中的某些方法，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Value("#{ T(java.util.UUID).randomUUID().toString()}")
    private String uuid;

    @Test
    public void testMethod() {
        System.out.println(uuid);// 运行结果：0fa73ab2-ee6a-4fe0-b43c-7d8ec3cd1bf6
    }
}
```

我们还可以直接调用对象中的方法操作配置文件中的属性值，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import java.util.List;

@SpringBootTest
class ApplicationTests {

    @Value("#{ T(org.apache.commons.lang.StringUtils).split('${gsl.friends}',',')}")
    private List<String> friends;

    @Test
    public void testMethod() {
        System.out.println("friends = " + friends);// 运行结果：friends = [Tom, Jerry, Lucy]
    }
}
```

###### 2.3.5.4 使用容器对象

通过`@Value`注解我们还可以获取到IOC容器中的对象。为了演示方便，下面先创建一个实体类，并结合配置类将该实体类放入到IOC容器中，如下所示：

```java
package com.gsl;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student {
    private String name;
    private Integer age;
}
```

```java
package com.gsl;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ConfigBean {

    @Bean
    public Student student() {
        return new Student("Tom", 28);
    }
}
```

然后直接在测试类中获取容器中对象的信息即可，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Value("#{student.name}")
    private String name;

    @Test
    public void testMethod() {
        System.out.println("name = " + name);// 运行结果：name = Tom
    }
}
```

> **说明**：这里我们也可以设置默认值，比如使用`@Value("#{student.name?:'Lucy'}")`表示获取不到name值时，就使用默认值Lucy代替。

###### 2.3.5.5 自动转换成集合

配置文件的属性值如果是一个json串的话，使用`@Value`注解可以自动转换成Map集合，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;
import java.util.Map;

@SpringBootTest
class ApplicationTests {

    @Value("#{${gsl.user}}")
    private Map<String, Object> map;

    @Test
    public void testMethod() {
        System.out.println("map = " + map);// 运行结果：map = {name=Mark, age=27}
        System.out.println("name = " + map.get("name"));// 运行结果：name = Mark
    }
}
```

###### 2.3.5.6 获取系统参数

使用`@Value`注解还可以获取系统参数，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    @Value("#{systemProperties['os.name']}")
    private String osName;

    @Value("#{systemProperties['java.version']}")
    private String version;

    @Test
    public void testMethod() {
        System.out.println("osName = " + osName);// 运行结果：osName = Windows 10
        System.out.println("version = " + version);// 运行结果：version = 1.8.0_181
    }
}
```

###### 2.3.5.7 方法上的使用

以上介绍的都是`@Value`注解在属性上的使用，其实该注解还能用在成员变量对应的setter方法上，如下所示：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ApplicationTests {

    private static String name;
    private String friends;

    @Value("${gsl.name}")
    public void setName(String name) {
        this.name = name;
    }

    @Value("${gsl.friends}")
    public void setFriends(String friends) {
        this.friends = friends;
    }

    @Test
    public void testMethod() {
        System.out.println("name = " + name);// 运行结果：name = Mark
        System.out.println("friends = " + friends);// 运行结果：friends = Tom,Jerry,Lucy
    }
}
```

> <font color="red">**注意**</font>：`@Value`注解是无法直接给静态成员变量赋值的，这时候就可以将该注解标在该变量的setter方法上，以达到赋值的目的。当然，使用同样的方式对非静态变量赋值也是没问题的。

###### 2.3.5.8 方法参数中的使用

`@Value`注解还能用在方法的参数上，比如构造方法，比如标有`@Autowired`注解的方法，演示如下：

```java
package com.gsl;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;

@SpringBootTest
class ApplicationTests {

    private String name;
    private String friends;
    private ApplicationContext context;

    /**
     * 使用@Value注解对构造方法的参数进行赋值
     * @param friends
     */
    public ApplicationTests(@Value("${gsl.friends}") String friends) {
        this.friends = friends;
    }

    @Autowired
    public void config(ApplicationContext context, @Value("${gsl.name}") String name) {
        this.name = name;
        this.context = context;
    }

    @Test
    public void testMethod() {
        System.out.println("name = " + name);//运行结果：name = Mark
        System.out.println("friends = " + friends);//运行结果：friends = Tom,Jerry,Lucy
        //运行结果：beanCounts = 137
        System.out.println("beanCounts = " + context.getBeanDefinitionCount());
    }
}
```

### 3.SpringBoot的整合

#### 3.1 SpringBoot整合JUnit

当我们新建一个SpringBoot工程后，默认就会导入测试相关的starter，所以默认就整合了JUnit。而且==测试类==(带有`@SpringBootTest`注解的类)所在包和==启动类==(带有`@SpringBootApplication`注解的类)所在包默认是一致的。

这里主要说一个特殊情况。假设测试类和启动类的包名都是`com.gsl`，如果我们将测试类移动到`com.gsl`的子包下是没有任何问题的，比如`com.gsl.test`包；但要是移动到父包下，测试类就会运行报错，比如`com`包。

如果要解决以上问题，则需要在测试类所在的`@SpringBootTest`注解中指定启动类。假设启动类为Application，那么测试类上的写法如下：

```java
@SpringBootTest(classes = Application.class)
```

#### 3.2 SpringBoot整合MyBatis

1. 首先新建一个SpringBoot项目，新建的时候，勾选如下三项：

   ![image-20220329223444406](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402153757.png) 

2. 然后新建一个用于测试的实体类和对应的Dao接口：

   ```java
   package com.example.mybatis.entity;
   
   import lombok.Data;
   
   @Data
   public class Student {
       private Integer id;
       private String name;
       private Integer age;
   }
   ```

   ```java
   package com.example.mybatis.dao;
   
   import com.example.mybatis.entity.Student;
   import org.apache.ibatis.annotations.Mapper;
   import org.apache.ibatis.annotations.Select;
   
   @Mapper
   public interface StudentDao {
       @Select("select * from student where id = #{id}")
       public Student selectById(Integer id);
   }
   ```

3. 接下来再根据实体类创建对应的表，并插入几条测试数据：

   ```sql
   CREATE TABLE `student` (
     `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id',
     `name` varchar(32) DEFAULT NULL COMMENT '姓名',
     `age` int(11) DEFAULT NULL COMMENT '年龄',
     PRIMARY KEY (`id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
   
   insert into student(`name`,`age`) values('Tom',18);
   insert into student(`name`,`age`) values('Mark',25);
   insert into student(`name`,`age`) values('Lucy',22);
   ```

4. 之后在项目的application.yml配置文件中配置数据库的连接信息：

   ```yaml
   spring:
     datasource:
       driver-class-name: com.mysql.cj.jdbc.Driver
       # 这里的test是数据库的库名
       url: jdbc:mysql://localhost:3306/test
       username: root
       password: root
   ```

5. 最后在测试类中测试即可，测试类内容和测试结果如下：

   ```java
   package com.example.mybatis;
   
   import com.example.mybatis.dao.StudentDao;
   import com.example.mybatis.entity.Student;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   
   @SpringBootTest
   class MyBatisApplicationTests {
   
       @Autowired
       private StudentDao studentDao;
   
       @Test
       public void contextLoads() {
           Student student = studentDao.selectById(2);
           System.out.println("student = " + student);
       }
   }
   ```

   ![image-20220330120856189](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402153804.png)  

以上在整合MyBatis的时候，如果SpringBoot的版本较低(比如2.4以下)，那么application.yml中在配置数据库的地址时后面一定要加上时区，否则会报错。时区可以使用UTC或者其他的都行，比如下面这样：

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai
```

其实在实际生产环境中，这个url后面一般会配置很多东西的，比如下面这样：

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&serverTimezone=Asia/Shanghai&useSSL=false
```

> **说明**：至此，就完成了SpringBoot与MyBatis最基础的整合。

#### 3.3 SpringBoot整合MyBatisPlus

把上面整合MyBatis的项目稍作改动，就可以变成整合MyBatisPlus的项目了，所以这里就还以上面的项目为例。

1. 首先将pom文件中之前整合MyBatis的依赖删掉，加入整合MyBatisPlus的依赖，如下所示：

   ```xml
   <!--<dependency>
       <groupId>org.mybatis.spring.boot</groupId>
       <artifactId>mybatis-spring-boot-starter</artifactId>
       <version>2.2.2</version>
   </dependency>-->
   <dependency>
       <groupId>com.baomidou</groupId>
       <artifactId>mybatis-plus-boot-starter</artifactId>
       <version>3.3.0</version>
   </dependency>
   ```

2. 然后修改StudentDao接口的内容，改成下面这样：

   ```java
   package com.example.mybatis.dao;
   
   import com.baomidou.mybatisplus.core.mapper.BaseMapper;
   import com.example.mybatis.entity.Student;
   import org.apache.ibatis.annotations.Mapper;
   
   @Mapper
   public interface StudentDao extends BaseMapper<Student> {
   
   }
   ```

3. 然后就可以直接在测试类中进行测试了，MyBatisPlus默认为我们提供了很多方法，下面就使用下其中的两个，如下所示：

   ```java
   package com.example.mybatis;
   
   import com.example.mybatis.dao.StudentDao;
   import com.example.mybatis.entity.Student;
   import org.junit.jupiter.api.Test;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import java.util.Arrays;
   import java.util.List;
   
   @SpringBootTest
   class MyBatisApplicationTests {
   
       @Autowired
       private StudentDao studentDao;
   
       @Test
       public void contextLoads() {
           //指定id进行查询
           Student student = studentDao.selectById(2);
           System.out.println("student = " + student);
   
           //根据多个id进行批量查询
           List<Student> list = studentDao.selectBatchIds(Arrays.asList(1, 2));
           System.out.println("list = " + list);
       }
   }
   ```

   ![image-20220330122057388](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402153814.png) 

> **说明**：至此，之前SpringBoot整合MyBatis的项目就被改造成整合MyBatisPlus的项目了。

#### 3.4 SpringBoot整合Druid

这里就直接在上面整合MyBatisPlus的项目中加入Druid相关的内容了。首先就是在pom文件中引入相关starter，如下所示：

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.6</version>
</dependency>
```

然后将application.yml配置文件中连接数据库相关的配置改为如下内容：

```yaml
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai
      username: root
      password: root
```

其他地方都不用变动，直接运行测试类的方法即可。一方面观察是否能查到数据，另一方面看控制台是否有Druid相关的日志打印。如下所示：

![image-20220330164428465](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402153822.png) 

#### 3.5 SpringBoot整合Redis

首先新建一个项目，然后在pom文件中导入redis相关starter，如下所示：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

然后在application.yml配置文件中添加相关配置：

```yaml
spring:
  redis:
    host: localhost
    port: 6379
```

本地安装好redis后，直接在测试类中进行测试即可，我们先向redis中添加数据，然后再进行获取，看看是否可以成功获取到之前添加的数据：

```java
package com.example.redis;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.StringRedisTemplate;

@SpringBootTest
class RedisApplicationTests {

    @Autowired
    private StringRedisTemplate redisTemplate;

    // 先运行该方法向redis中添加数据
    @Test
    void testSet() {
        redisTemplate.opsForValue().set("name", "Tom");
        redisTemplate.opsForHash().put("student", "math", "85");
    }

    // 再运行该方法向redis中获取数据
    @Test
    void testGet() {
        Object name = redisTemplate.opsForValue().get("name");
        Object value = redisTemplate.opsForHash().get("student", "math");
        System.out.println("name = " + name);// 运行结果：name = Tom
        System.out.println("value = " + value);// 运行结果：value = 85
    }
}
```

#### 3.6 SpringBoot整合MongoDB

首先在项目的pom文件中导入mongodb相关starter，如下所示：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```

本地[下载](https://downloads.mongodb.com/windows/mongodb-windows-x86_64-enterprise-5.0.6.zip)并启动一个mongodb后，在application.yml配置文件中添加相关配置：

```yaml
spring:
  data:
    mongodb:
      # url用于指定mongodb的地址和库名，端口默认是27017，这里可以省略
      uri: mongodb://localhost/config
```

以上配置文件中的config是mongodb默认就存在的库，下面就在这个库中进行操作演示。为了演示方便，先创建一个用于演示的实体类，如下所示：

```java
package com.example.mongodb.entity;

import lombok.Data;

@Data
public class Student {
    private Integer id;
    private String name;
    private Integer age;
}
```

然后在测试类中进行相关操作，如下所示：

```java
package com.example.mongodb;

import com.example.mongodb.entity.Student;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import java.util.List;

@SpringBootTest
class MongoDbApplicationTests {

    @Autowired
    private MongoTemplate mongoTemplate;

    @Test
    void contextLoads() {
        Student student = new Student();
        student.setId(2);
        student.setName("Tom");
        student.setAge(25);
        // 这一步会在默认的config库下创建一个collection，类似于mysql中的表
        mongoTemplate.save(student);

        // 这一步是查询自动创建的collection的名称
        String collectionName = mongoTemplate.getCollectionName(Student.class);
        System.out.println("collectionName = " + collectionName);

        // 这一步用于查询名为student的collection中的所有数据
        List<Student> list = mongoTemplate.findAll(Student.class);
        System.out.println("list = " + list);
    }
}
```

以上测试类中的运行结果如下所示：

![image-20220402152647612](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402153832.png) 

我们也可以登录mongodb自带客户端工具查看通过代码方式保存到mongodb中的数据，如下所示：

```bash
# 展示所有库
show dbs

# 查看当前所在库
db

# 切换库
use config

# 展示所有的collection
show collections

# 查询指定collection下的所有内容
db.student.find()
```

![image-20220402153522910](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402153836.png) 

#### 3.7 SpringBoot整合ElasticSearch

首先[下载](https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.15.2-windows-x86_64.zip)并双击bin目录下的`elasticsearch.bat`批处理文件启动windows版的ES，启动后浏览器访问如下地址，返回一串json串就说明ES启动成功了。

```http
http://localhost:9200/
```

![image-20220402190021332](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220402190119.png) 

按照常规的SpringBoot整合第三方技术的特点，这里整合ElasticSearch应该是下面这样：

![image-20220404101441292](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220404102946.png) 

但是SpringBoot并没有跟随ElasticSearch的更新速度进行同步更新，所以我们不推荐使用以上的整合方式。ES提供了一个来操作自己的High Level Client，我们就使用这个。首先使用如下方式在pom文件中导入对应的依赖：

```xml
<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
</dependency>
```

然后直接通过硬编码的方式创建对应的客户端，并测试可用性，如下所示：

```java
package com.example.elasticsearch;

import org.apache.http.HttpHost;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.indices.CreateIndexRequest;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import java.io.IOException;

@SpringBootTest
class ElasticSearchApplicationTests {

    @Test
    void createIndex() throws IOException {
        // 创建客户端
        RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create("http://localhost:9200")
        ));
        // 入参中的student是索引的名称
        CreateIndexRequest request = new CreateIndexRequest("student");
        // 创建对应的索引
        client.indices().create(request, RequestOptions.DEFAULT);
        // 关闭客户端
        client.close();
    }
}
```

如果有多个测试方法使用客户端的话，每次都要创建和关闭客户端就会很麻烦，所以上面客户端的创建和关闭我们可以进行抽取，如下所示：

```java
package com.example.elasticsearch;

import org.apache.http.HttpHost;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.indices.CreateIndexRequest;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import java.io.IOException;

@SpringBootTest
class ElasticSearchApplicationTests {

    private RestHighLevelClient client;

    @BeforeEach
    void setUp() {
        // 创建客户端
        client = new RestHighLevelClient(RestClient.builder(
                HttpHost.create("http://localhost:9200")
        ));
    }

    @AfterEach
    void tearDown() throws IOException {
        // 关闭客户端
        client.close();
    }

    @Test
    void createIndex() throws IOException {
        // 入参中的student是索引的名称
        CreateIndexRequest request = new CreateIndexRequest("student");
        // 创建对应的索引
        client.indices().create(request, RequestOptions.DEFAULT);
    }
}
```

运行以上测试方法创建索引后，我们可以在浏览器访问`http://localhost:9200/student`查看索引信息，如下所示：

![image-20220404113050882](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220405121937.png) 

#### 3.8 SpringBoot整合Memcached

首先[下载](http://static.runoob.com/download/memcached-win64-1.4.4-14.zip)并解压Memcached压缩包，之后以管理员身份运行cmd命令提示符。然后进入到解压后的memcached目录中执行以下命令进行安装：

```bash
memcached.exe -d install
```

命令执行完成之后，在任务管理器中会出现以下这个服务：

![image-20220405111730396](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220405121945.png)

接下来可以使用如下命令启动memcached服务： 

```bash
memcached.exe -d start
```

> **说明**：如果我们想要停止memcached服务的话，可以使用`memcached.exe -d stop`命令。

memcached最早期的客户端叫`Memcached Client for Java`，之后又出现了效率更高的`SpyMemcached`，再后来又出现了`Xmemcached`，由于Xmemcached对并发的处理更优秀，所以我们这里就使用这个客户端。

由于SpringBoot默认并没有整合memcached，所以我们找不到对应的starter，就只能使用硬编码的方式实现客户端初始化管理了。

首先在pom文件中导入相关依赖：

```xml
<dependency>
    <groupId>com.googlecode.xmemcached</groupId>
    <artifactId>xmemcached</artifactId>
    <version>2.4.7</version>
</dependency>
```

我们没法直接在application.yml配置文件中找到memcached相关的配置，所以只能硬编码方式去关联了。首先创建一个实体类，如下所示：

```java
package com.example.memcached.bean;

import lombok.Data;
import org.springframework.stereotype.Component;
import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * @Author: gongsl
 * @Date: 2022-04-05 11:34
 */
@Data
@Component
@ConfigurationProperties(prefix = "memcached")
public class XMemcachedProperties {
    /**
     * memcached的服务地址
     */
    private String serverUrl;

    /**
     * 连接池的数量
     */
    private int poolSize;

    /**
     * 默认的操作超时时间
     */
    private int opTimeout;
}
```

> **说明**：这个实体类中的属性都是memcached可配置的参数，参数其实有很多，这里为了演示方便，就只写了三个。

然后在application.yml文件中增加如下配置：

```yaml
memcached:
  # 11211是memcached的默认端口
  serverUrl: localhost:11211
  poolSize: 10
  opTimeout: 3000
```

接下来在配置类中创建客户端工具，如下所示：

```java
package com.example.memcached.config;

import com.example.memcached.bean.XMemcachedProperties;
import net.rubyeye.xmemcached.MemcachedClient;
import net.rubyeye.xmemcached.XMemcachedClientBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import java.io.IOException;

/**
 * @Author: gongsl
 * @Date: 2022-04-05 11:41
 */
@Configuration
public class XMemcachedConfig {

    @Autowired
    private XMemcachedProperties prop;

    @Bean
    public MemcachedClient memcachedClient() throws IOException {
        XMemcachedClientBuilder builder = new XMemcachedClientBuilder(prop.getServerUrl());
        builder.setConnectionPoolSize(prop.getPoolSize());
        builder.setOpTimeout(prop.getOpTimeout());
        MemcachedClient client = builder.build();
        return client;
    }
}
```

最后直接在测试类中通过向memcached中存取数据的方式来验证其是否可用，如下所示：

```java
package com.example.memcached;

import net.rubyeye.xmemcached.MemcachedClient;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MemcachedApplicationTests {

    @Autowired
    private MemcachedClient client;

    @Test
    public void testMemcached() throws Exception {
        // 三个参数分别是：key值，过期时间，value值。过期时间为0表示永不过期
        client.set("smsCode", 0, "356857");

        // 根据指定的key从memcached中获取对应value值
        String smsCode = client.get("smsCode");
        System.out.println("smsCode = " + smsCode);// 运行结果：smsCode = 356857
    }
}
```

#### 3.9 SpringBoot整合Quartz

首先我们需要在pom文件中导入相关starter，如下所示：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-quartz</artifactId>
</dependency>
```

然后定义一个要执行的任务，并继承类，如下所示：

```java
package com.example.task;

import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.springframework.scheduling.quartz.QuartzJobBean;

public class QuartzTask extends QuartzJobBean {
    @Override
    protected void executeInternal(JobExecutionContext con) throws JobExecutionException {
        System.out.println("quartz job run...");
    }
}

```

接下来需要定义工作明细与触发器，并绑定对应关系，这部分代码我们在配置类中书写，如下所示：

```java
package com.example.task.config;

import com.example.task.QuartzTask;
import org.quartz.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class QuartzConfig {

    @Bean
    public JobDetail jobDetail(){
        JobDetail jobDetail = JobBuilder.newJob(QuartzTask.class).storeDurably().build();
        return jobDetail;
    }

    @Bean
    public Trigger jobTrigger(){
        CronScheduleBuilder builder = CronScheduleBuilder.cronSchedule("0/1 * * * * ?");
        return TriggerBuilder.newTrigger().forJob(jobDetail()).withSchedule(builder).build();
    }
}
```

然后我们直接运行主程序的main方法启动工程即可，通过控制台打印可以发现，定时任务已经运行了，如下所示：

![image-20220406181313232](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220406183005.png) 

以上使用Quartz实现定时任务的方式相对来说还是比较麻烦的，我们可以使用`Spring Task`这种更加简单的方式。该方式使用简单且不用额外引入第三方jar包，首先在主程序类中使用`@EnableScheduling`注解开启定时任务，如下所示：

```java
package com.example.task;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class TaskApplication {

    public static void main(String[] args) {
        SpringApplication.run(TaskApplication.class, args);
    }

}
```

然后新建一个类，并使用`@Component`注解将其放到IOC容器中，然后直接在该类中创建需要执行定时任务的方法即可。方法上需要标注`@Scheduled`注解，如下所示：

```java
package com.example.task;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class TestTask {

    @Scheduled(cron = "0/1 * * * * ?")
    public void task(){
        System.out.println(Thread.currentThread().getName() + "：spring running...");
    }
}
```

启动主程序类中的main方法后，控制台打印内容如下：

![image-20220406182616424](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220406183015.png) 

我们如果想要更改定时任务的线程名前缀，可以在application.yml配置文件中进行配置，如下所示：

```yaml
spring:
  task:
    scheduling:
      thread-name-prefix: testTask-
```

更改后的效果如下：

![image-20220406182923885](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220406183019.png) 

#### 3.10 SpringBoot整合JavaMail

##### 3.10.1 简单的邮件发送功能

整合之前先介绍几种协议，如下所示：

- SMTP(Simple Mail Transfer Protocol)：简单邮件传输协议，用于<font color="red">**发送**</font>电子邮件的传输协议；
- POP3(Post Office Protocol - Version 3)：用于<font color="red">**接收**</font>电子邮件的标准协议；
- IMAP(Internet Mail Access Protocol)：互联网消息协议，是POP3的替代协议。

下面开始进行整合，首先在pom文件中引入相关starter，如下所示：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

之后在application.yml配置文件中进行相关配置，如下所示：

```yaml
spring:
  mail:
    # 如果发件邮箱是163的，这里就是smtp.163.com
    host: smtp.qq.com
    # 这个是发件邮箱的用户名
    username: 12345678@qq.com
    # 这个是发件邮箱的密码，这个密码是在我们开启SMTP相关服务后，生成的授权码
    password: oxfgadedjxjbbagi
```

![image-20220406192340585](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220406193044.png) 

然后直接在测试类中发送邮件进行测试即可，代码如下所示：

```java
package com.example.mail;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;

@SpringBootTest
class MailApplicationTests {

    @Autowired
    private JavaMailSender javaMailSender;

    @Test
    public void testMail() {
        SimpleMailMessage mailMessage = new SimpleMailMessage();
        // 这个是发件人
        mailMessage.setFrom("12345678@qq.com");
        // 这个是收件人
        mailMessage.setTo("abcdef@163.com");
        // 这个是邮件的主题
        mailMessage.setSubject("测试使用");
        // 这个是邮件的正文
        mailMessage.setText("这是一个测试邮件...");
        javaMailSender.send(mailMessage);
    }
}
```

运行测试类后，邮件就发送成功了，我这边也成功接收到了邮件，如下所示：

![image-20220406193031251](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220406193038.png) 

发件人也可以使用别名，比如上面用于设置发件人的代码写成如下内容的话，收到邮件的发送人就是`小甜甜`了。

```java
mailMessage.setFrom("12345678@qq.com(小甜甜)");
```

![image-20220406194749108](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220406194806.png) 

##### 3.10.2 复杂的邮件发送功能

上面介绍了如果使用SpringBoot进行简单的邮件发送，下面搞点稍微复杂的，增加超链接和附件功能。其他的都不动，只需要改动测试类中的代码即可，如下所示：

```java
package com.example.mail;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.io.File;

@SpringBootTest
class MailApplicationTests {

    @Autowired
    private JavaMailSender javaMailSender;

    @Test
    public void testMail() throws MessagingException {
        MimeMessage mimeMessage = javaMailSender.createMimeMessage();
        // 第二个参数为true表示支持附件
        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true);
        // 这个是发件人
        helper.setFrom("12345678@qq.com(小甜甜)");
        // 这个是收件人
        helper.setTo("abcdef@163.com");
        // 这个是邮件的主题
        helper.setSubject("测试使用");
        String text = "测试，<a href='https://www.baidu.com/'>百度一下</a>";
        // 这个是邮件的正文，第二个参数为true表示支持html
        helper.setText(text, true);

        // 添加附件
        File file1 = new File("D:\\ftpfile\\Mail-0.0.1-SNAPSHOT.jar");
        File file2 = new File("D:\\ftpfile\\test.jpg");
        helper.addAttachment(file1.getName(), file1);
        helper.addAttachment("测试图片.jpg", file2);
        javaMailSender.send(mimeMessage);
    }
}
```

运行以上代码后就会发送邮件了，邮件内容如下所示：

![image-20220406202121706](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20220406202201.png) 

#### 3.11 









































