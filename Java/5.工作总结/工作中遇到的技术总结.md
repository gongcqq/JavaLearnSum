### 1.技术相关

#### 1.1 计算时间差

我们可以通过如下代码计算两个时间的时间差，并通过可读性高的方式输出：

```java
package com.test;

import cn.hutool.core.date.BetweenFormatter;
import cn.hutool.core.date.DateTime;
import cn.hutool.core.date.DateUtil;
import java.util.Date;

public class defaultTest {
    public static void main(String[] args) {
        DateTime parse = DateUtil.parse("2022-05-19 12:15:26");
        String endTime = DateUtil.formatBetween(parse.toJdkDate(), new Date(), BetweenFormatter.Level.SECOND);
        System.out.println("时间差：" + endTime);
    }
}
```

运行以上代码后，输出结果如下所示：

```properties
时间差：2小时24分50秒
```

> **说明**：可以通过这种方式计算运行时间，比如我们创建了一个容器，希望在前台展示这个容器的运行时间，就可以通过以上代码计算出当前时间和容器创建时间的差值得到运行时间。

#### 1.2 随机生成指定长度的数字或字符串

首先导入对应的依赖：

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.10</version>
</dependency>
```

下面主要介绍RandomStringUtils类的一些常见API的用法：

```java
package com.gongsl.test;

import org.apache.commons.lang3.RandomStringUtils;

public class MyTest {
    public static void main(String[] args) {
        //生成指定长度只包含数字的随机组合字符串
        String random = RandomStringUtils.randomNumeric(20);
        System.out.println(random);//输出结果：95415346401472418138
        //生成指定长度包含大小写字母的随机组合字符串
        String random1 = RandomStringUtils.randomAlphabetic(20);
        System.out.println(random1);//输出结果：vwAbfDCBoACMtceeXJZr
        //生成指定长度包含数字和大小写字母的随机组合字符串
        String random2 = RandomStringUtils.randomAlphanumeric(20);
        System.out.println(random2);//输出结果：SeJK3nx9lBLwe2gwGXTc
        //根据指定字符串生成指定长度的随机组合字符串
        String random3 = RandomStringUtils.random(5, "26wh3SNLT3JKkr3kb5t5");
        System.out.println(random3);//输出结果：w2Tk3
    }
}
```

#### 1.3 使用随机字符替换字符串首字符

具体代码如下所示：

```java
package com.gongsl.test;

import org.apache.commons.lang3.RandomStringUtils;

import java.util.UUID;

public class MyTest {
    public static void main(String[] args) {
        String uuid = UUID.randomUUID().toString().replaceAll("-", "");
        System.out.println(uuid);//输出结果：1f2f3a3dc72146828855b051d2371ef0
        //如果生成的uuid以数字开头，则将开头的数字替换成小写字符
        if (uuid.matches("^[0-9].*")) {
            String startStr = RandomStringUtils.randomAlphabetic(1).toLowerCase();
            uuid = uuid.replaceFirst(uuid.substring(0, 1), startStr);
            System.out.println(uuid);//输出结果：gf2f3a3dc72146828855b051d2371ef0
        }
    }
}
```

#### 1.4 根据集合中字符串的指定内容进行排序

工作中遇到了这样的需求，有很多类似`Cell_20_6`这种类型的字符串集合，需要根据字符串中第二个下划线后面的数字对集合中的字符串进行排序。在这个排序的基础上，再根据字符串中第一个下划线后面的数字进行二次排序，最后再将排序好的集合拼接成字符串输出，下面的代码就是具体的实现逻辑：

```java
package com.gongsl.test;

import java.util.*;
import java.util.stream.Collectors;

public class MyTest {
    public static void main(String[] args) {
        //这个字符串是用来演示排序效果的素材
        String str = "Cell_2_1;Cell_2_2;Cell_2_5;Cell_2_4;Cell_2_3;Cell_6_3;Cell_6_4;Cell_6_5;Cell_6_6;Cell_6_7;Cell_7_0;Cell_7_3;Cell_7_4;Cell_7_5;Cell_7_6;Cell_7_7;Cell_8_0;Cell_8_3;Cell_8_4;Cell_8_5;Cell_8_6;Cell_8_7;Cell_9_0;Cell_9_3;Cell_9_4;Cell_9_5;Cell_9_6;Cell_9_7;Cell_10_0;Cell_10_3;Cell_10_4;Cell_10_5;Cell_10_6;Cell_10_7;Cell_11_0;Cell_11_3;Cell_11_4;Cell_11_5;Cell_11_6;Cell_11_7;Cell_15_3;Cell_15_4;Cell_15_5;Cell_15_6;Cell_15_7;Cell_16_3;Cell_17_3;Cell_18_0;Cell_18_3;Cell_18_4;Cell_18_5;Cell_18_6;Cell_18_7;Cell_19_0;Cell_19_3;Cell_19_4;Cell_19_5;Cell_19_6;Cell_19_7;Cell_20_0;Cell_20_3;Cell_20_4;Cell_20_5;Cell_20_6;Cell_20_7;Cell_21_3;Cell_21_4;Cell_21_5;Cell_21_6;Cell_21_7;Cell_22_0;Cell_22_3;Cell_22_4;Cell_22_5;Cell_22_6;Cell_22_7;Cell_23_3;Cell_23_4;Cell_23_5;Cell_23_6;Cell_23_7;Cell_24_0;Cell_24_3;Cell_24_4;Cell_24_5;Cell_24_6";
        String[] split = str.split(";");
        List<String> list = Arrays.asList(split);
        //循环方式多次打乱集合元素的顺序
        for (int i = 0; i < 20; i++) {
            Collections.shuffle(list);
        }
        String mySort = mySort(list);
        System.out.println(mySort);
    }

    //这个方法会将集合按照指定要求进行二次排序，并将排序结果以字符串形式输出
    public static String mySort(List<String> list) {
        //分组后，集合的key值默认会进行升序排列
        Map<Integer, List<String>> listMap = list.stream()
                .collect(Collectors.groupingBy(e -> Integer.parseInt(e.split("_")[2]), TreeMap::new, Collectors.toList()));
        //然后这一步是将每个key对应的value集合中的字符串进行排序
        listMap.forEach((key, value) -> {
            value = value.stream().sorted(Comparator.comparing((str -> Integer.parseInt(str.split("_")[1]))))
                    .collect(Collectors.toList());
            listMap.put(key, value);
        });
        //排序后，再将所有内容使用分号拼成字符串返回
        String resultStr = listMap.values().stream().map(e -> String.join(";", e))
                .collect(Collectors.joining(";"));
        return resultStr;
    }
}
```

### 2.踩坑相关

#### 2.1 Mybatis的NumberFormatException

今天在写mybatis的动态sql时报了一个NumberFormatException异常，涉及到的sql内容如下：

```sql
<if test="(scbs =='Y') and (cdbs == null || cdbs == '')">
    and exists (select 1 from pt_zbgl_favorite fav where
    fav.lx='BASE.MX' and fav.dm = mx.mx_dm and fav.yxbz='Y')
</if>
```

异常信息如下所示：

```xml
### Error querying database.  Cause: java.lang.NumberFormatException: For input string: "Y"
### Cause: java.lang.NumberFormatException: For input string: "Y"
	at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:150)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141)
	at sun.reflect.GeneratedMethodAccessor455.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433)
	... 90 common frames omitted
```

这个报错的主要原因是，Mybatis的OGNL语法把'Y'认为成了char类型，而scbs字段我们代码设置的是String类型。解决办法就是不要在动态sql中使用`'Y'`，而是使用`"Y"`，然后外层使用单引号即可，如下所示：

```sql
<if test='(scbs =="Y") and (cdbs == null || cdbs == "")'>
```

#### 2.2 使用group_concat函数的类型问题

在mysql数据库中，group_concat函数可以实现将多个值通过指定分隔符拼接成字符串返回。在使用mybatis时，可以在写sql语句时使用该函数将相关数据拼接成字符串，然后封装到java对象的字符串字段中。下面先说下该函数的一些主要用法，然后再说踩的坑。

group_concat函数的完整语法如下：

```sql
group_concat([DISTINCT] 要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator '分隔符'])
```

下面演示一下该函数的效果，准备的数据如下所示：

```sql
mysql> select * from student;
+----+-------+------+
| id | name  | age  |
+----+-------+------+
|  1 | Tom   |   18 |
|  2 | Mark  |   25 |
|  3 | Lucy  |   22 |
|  4 | Jerry |   25 |
+----+-------+------+
4 rows in set (0.00 sec)
```

使用group_concat(name)将符合条件的数据的name字段拼接成字符串，如下所示：

```sql
mysql> select group_concat(name) from student;
+---------------------+
| group_concat(name)  |
+---------------------+
| Tom,Mark,Lucy,Jerry |
+---------------------+
1 row in set (0.00 sec)
```

默认的分隔符是逗号，我们也可以手动指定分隔符，比如使用分号，如下所示：

```sql
mysql> select group_concat(name separator ';') from student;
+----------------------------------+
| group_concat(name separator ';') |
+----------------------------------+
| Tom;Mark;Lucy;Jerry              |
+----------------------------------+
1 row in set (0.00 sec)
```

我们也可以在拼接的时候进行去重操作，如下所示：

```sql
# 这个是去重前的效果
mysql> select group_concat(age) from student;
+-------------------+
| group_concat(age) |
+-------------------+
| 18,25,22,25       |
+-------------------+
1 row in set (0.00 sec)

# 这个是去重后的效果
mysql> select group_concat(distinct age) from student;
+----------------------------+
| group_concat(distinct age) |
+----------------------------+
| 18,25,22                   |
+----------------------------+
1 row in set (0.00 sec)
```

我们甚至可以进行排序，这里以倒序为例，如下所示：

```sql
# order by后面也可以是别的字段，并不是group_concat后面是什么字段，排序就要用什么字段
mysql> select group_concat(age order by age desc) from student;
+-------------------------------------+
| group_concat(age order by age desc) |
+-------------------------------------+
| 25,25,22,18                         |
+-------------------------------------+
1 row in set (0.00 sec)
```

最后来个组合效果，如下所示：

```sql
mysql> select group_concat(distinct age order by age desc separator ';') from student;
+------------------------------------------------------------+
| group_concat(distinct age order by age desc separator ';') |
+------------------------------------------------------------+
| 25;22;18                                                   |
+------------------------------------------------------------+
1 row in set (0.00 sec)
```

用法说完了，下面就说踩坑的地方了。首先group_concat函数拼接后的字符串是有长度限制的(默认是1024个字节)，超长部分默认会被截取掉，而且使用这个函数返回的结果并不一定都是字符串。如果在mybatis的xml配置中写sql的时候使用这个函数，那需要注意对应的Mapper方法的返回值是什么，假设是一个Map集合。由于我们使用group_concat函数的时候，sql中一般都会设置别名，所以这个别名就是集合中的key值，group_concat函数的结果就是集合中的value值。

上面说了，group_concat函数返回的值并不一定都是字符串类型，如果不知道这个坑，那么当我们从Map中取值的时候就有可能出现问题。我遇到的问题是，group_concat函数返回的结果是一个byte[]数组，然后这个数组就存入到了Map集合的value中了。

如果我们总是希望group_concat函数返回的结果就是字符串类型，那可以使用`convert函数`或者`cast函数`去解决这个问题，将group_concat函数的结果转成字符串类型后再进行返回，比如下面这样：

```sql
mysql> select convert(group_concat(name),char) as result from student;
+---------------------+
| result              |
+---------------------+
| Tom,Mark,Lucy,Jerry |
+---------------------+
1 row in set (0.00 sec)

mysql> select cast(group_concat(name) as char) as result from student;
+---------------------+
| result              |
+---------------------+
| Tom,Mark,Lucy,Jerry |
+---------------------+
1 row in set (0.00 sec)
```

> **说明**：使用`convert函数`或者`cast函数`都是可以的，效果都是一样的，它们也没啥大的区别，只是语法不同而已。

#### 2.3 mysql中字段使用text类型仍然不够用

在设计某个需求的数据库表时，有一个字段是专门用来存储大文本内容的，当时mysql中该字段用的是`text`类型，结果冒烟测试环境，存入到这个字段的内容太大，`text`类型已经存不下了，结果出现了报错，后面改成`longtext`类型后才解决这个报错，这里进行一下记录。

平常在工作中，我们也可能会用到`blob`类型，这种类型和`text`类型主要的区别是，`blob`类型能保存二进制数据，比如图片之类的，而`text`类型只能保存字符数据，比如一篇文章之类的。

保存二进制数据或者大文本数据时，可能用到的字段类型以及这些类型的长度限制如下所示：

| 类型       | 最大长度                                      |
| :--------- | :-------------------------------------------- |
| tinytext   | 最大长度为255个字符(2^8^-1)                   |
| text       | 最大长度为65535个字符(2^16^-1)                |
| mediumtext | 最大长度为16777215个字符(2^24^-1)             |
| longtext   | 最大长度为4294967295个字符(2^32^-1)           |
| tinyblob   | 最大长度为255个字符(2^8^-1) 或 最大255B       |
| blob       | 最大长度为65535个字符(2^16^-1) 或 最大65K     |
| mediumblob | 最大长度为16777215个字符(2^24^-1) 或 最大16M  |
| longblob   | 最大长度为4294967295个字符(2^32^-1) 或 最大4G |

#### 2.4 dubbo服务调用失败的情况

dubbo远程调用失败的原因可能会有很多种，这里就先列举一下我遇到的几种情况，后面遇到别的情况再进行补充。

**情况一：**因为超时导致的服务调用失败，可以根据情况调整`超时时间`解决。

**情况二：**服务生产者或者消费者的配置有误导致的失败，需要特别留意`ref、id等属性`是否配置正确。

**情况三：**由于服务生产者和消费者版本不一致导致的远程调用失败，需要注意`version属性`在生产者和消费者两边配置的是否一致。

**情况四：**dubbo服务远程调用的时候，接口里方法上使用了实体类的话，实体类一定要`实现序列化接口`，否则会导致服务调用失败。

#### 2.5 嵌套事务导致的报错

我们在方法上使用`@Transactional`注解进行事务控制时，如果方法中调用关系比较复杂，稍有不慎，就有可能遇到嵌套事务，并报下面这样的错：

```xml
Transaction rolled back because it has been marked as rollback-only
```

同时满足以下条件，就会出现事务嵌套的问题：

- 一个加了`@Transactional`注解的方法A调用了另一个使用`@Autowired`注入的service的方法B；
- 在方法A中使用`try...catch`对方法B进行了异常捕获；
- 方法B中也使用了`@Transactional`注解，并且方法B中有异常的话默认是抛出的；
- 方法A和方法B使用的都是默认的事务传播机制，即`REQUIRED`。

下面使用伪代码进行一个简单的举例说明：

**TestController**：

```java
@Autowired
TestAService testAService;

@GetMapping("/test")
public void test(){
    testAService.testA();
}
```

**TestAServiceImpl**：

```java
@Autowired
TestBService testBService;

@Transactional(rollbackFor = Exception.class)
public void testA(){
    try{
        testBService.testB();
    }catch(Exception e){
        e.printStackTrace();
    }
}
```

**TestBServiceImpl**：

```java
@Autowired
StudentMapper studentMapper;
 
@Transactional(rollbackFor = Exception.class)
public void testB(){
    Student student = new Student();
    student.setName("Tom");
    student.setAge(18);
    studentMapper.updateByPrimaryKey(student);
    System.out.println(1/0);
}
```

**说明**：上述代码就会触发回滚异常的报错。testA方法和testB方法都是使用的默认传播机制`REQUIRED`，该机制表示的意思是，已经存在事务就加入事务，没有就创建事务。这里的两个方法都是受事务控制的，并且处于同一个事务。如果testB方法中发生了异常，由于受事务控制，所以testB的操作应该回滚，但是testA方法又吃掉了testB方法的异常，那testA方法中就没有异常了，所以testA的操作又应该是提交。testA和testB是处于同一个事务中的，这时候程序也不知道到底是该回滚还是该提交了，因为这二者是相互矛盾的。

**解决办法：**

- 如果只是想解决这个嵌套事务的报错，直接去掉其中一个`@Transactional`就可以了；

- 如果两个`@Transactional`注解都不想去掉的话，可以在testA方法捕获异常后使用`throw`关键字将异常抛出，或者使用下面的方法手动处理：

  ```java
  @Transactional(rollbackFor = Exception.class)
  public void testA(){
      try{
          testBService.testB();
      }catch(Exception e){
          e.printStackTrace();
          //增加下面这行代码
          TransactionInterceptor.currentTransactionStatus().setRollbackOnly();
      }
  }
  ```

- 当然，如果两个事务不相关，也可以在testB方法上使用`Propagation.REQUIRES_NEW`传播机制，不过这种方式还是有风险的，所以要结合具体业务看是否可以这么搞。

> **注意**：真正和业务相关联后，出现嵌套事务的调用链绝不会像我上面伪代码中写的这么简单和清晰，往往可能是套了好几层。所以业务代码不熟悉的话，很容易有明明就一个`@Transactional`注解为啥还是报嵌套事务这种错的困惑，其实可能是另一个`@Transactional`注解藏的太深了自己没找到，或者代码中使用了编程式事务处理而不是注解。







