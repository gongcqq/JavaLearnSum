### 1.认识微服务

随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。

#### 1.1 单体架构

`单体架构`：将业务的所有功能集中在一个项目中开发，打成一个包部署。

![image-20210713202807818](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120529.png) 

单体架构的优缺点：

**优点：**

- 架构简单
- 部署成本低

**缺点：**

- 耦合度高(维护困难、升级困难)

#### 1.2 分布式架构

`分布式架构`：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。

![image-20210713203124797](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120537.png) 

分布式架构的优缺点：

**优点：**

- 降低服务耦合
- 有利于服务升级和拓展

**缺点：**

- 服务调用关系错综复杂

分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：

- 服务拆分的粒度如何界定？
- 服务之间如何调用？
- 服务的调用关系如何管理？

所以需要制定一套行之有效的标准来约束分布式架构。

#### 1.3 微服务架构

微服务的架构特征：

- `单一职责`：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责；
- `自治`：团队独立、技术独立、数据独立，独立部署和交付；
- `面向服务`：服务提供统一标准的接口，与语言和技术无关；
- `隔离性强`：服务调用做好隔离、容错、降级，避免出现级联问题。

![image-20210713203753373](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120550.png) 

微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。

因此，可以认为**微服务**是一种经过良好架构设计的**分布式架构方案**。以下是微服务较为完整的架构图：

![微服务技术架构](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225113.jpg) 

但方案该怎么落地？微服务带来的各种问题怎么解决？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案，其中在Java领域最引人注目的就是SpringCloud提供的方案了，SpringCloud其实是一套解决微服务方案的技术整合。

#### 1.4 SpringCloud

[SpringCloud](https://spring.io/projects/spring-cloud)是目前国内使用最广泛的微服务框架，它集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。

其中常见的组件包括：

![image-20210713204155887](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120601.png) 

SpringCloud底层是依赖于SpringBoot的，并且[官网](https://spring.io/projects/spring-cloud)也提供了版本的兼容关系，如下：

| Release Train                                                | Boot Version                          |
| :----------------------------------------------------------- | :------------------------------------ |
| [2020.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes) aka Ilford | 2.4.x, 2.5.x (Starting with 2020.0.3) |
| [Hoxton](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes) | 2.2.x, 2.3.x (Starting with SR5)      |
| [Greenwich](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes) | 2.1.x                                 |
| [Finchley](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes) | 2.0.x                                 |
| [Edgware](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes) | 1.5.x                                 |
| [Dalston](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes) | 1.5.x                                 |

#### 1.5 微服务技术对比

![image-20210903122239457](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903122252.png) 

#### 1.6 总结

- 单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统
- 分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝
- 微服务：一种良好的分布式架构方案
  - 优点：拆分粒度更小、服务更独立、耦合度更低
  - 缺点：架构非常复杂，运维、监控、部署难度提高
- SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件

### 2.服务拆分和远程调用

任何分布式架构都离不开服务的拆分，微服务也是一样。

#### 2.1 服务拆分原则

微服务拆分时要遵循以下几个原则：

- 不同微服务，不要重复开发相同业务；
- 微服务数据独立，不要访问其它微服务的数据库；
- 微服务可以将自己的业务暴露为接口，供其它微服务调用。

![image-20210903162502053](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225130.png) 

#### 2.2 服务拆分示例

这里以微服务项目[cloud-parent](https://gitee.com/gongcqq/others/attach_files/821170/download/cloud-parent.zip)为例演示服务拆分，其结构如下：

![image-20210903214759456](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225153.png) 

`cloud-parent`：父工程，管理依赖。

- `order-service`：订单微服务，负责订单相关业务。
- `user-service`：用户微服务，负责用户相关业务。

要求：

- 订单微服务和用户微服务都必须有各自的数据库，相互独立；
- 订单服务和用户服务都对外暴露Restful的接口；
- 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库。

##### 2.2.1 数据库设计

首先创建两个库，分别为**cloud_order**和**cloud_user**，然后不同库中执行以上`cloud-parent`项目中提供的不同sql脚本即可。

执行脚本后，cloud_user库中的t_user表的初始数据如下：

![image-20210903220430580](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225210.png) 

cloud_order库中的t_order表的初始数据如下：

![image-20210903220539317](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225215.png) 

> **说明**：t_order表中的user_id字段对应t_user表的id字段。

##### 2.2.2 导入微服务工程

首先将以上提供的代码导入到IDEA工程中，然后打开`Run Dashboard`面板，如下所示：

![image-20210903221334282](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225225.png) 

如果IDEA中选不到`Run Dashboard`面板(有的版本的IDEA是`Services`面板)，在项目的`.idea`目录的workspace.xml文件中添加以下内容后重启工程即可：

```xml
<option name="configurationTypes">
  <set>
    <option value="SpringBootApplicationConfigurationType" />
  </set>
</option>
```

![image-20210903222035404](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225235.png) 

生效后的`Run Dashboard`面板如下所示：

![image-20210903222418187](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225240.png) 

> **注意**：项目中用到的java的版本是jdk1.8。

#### 2.3 实现远程调用

订单模块的项目中是在启动类中使用`RestTemplate`类实现远程调用的，首先是使用如下代码将该类注入到Spring容器：

```java
@Bean
public RestTemplate restTemplate(){
    return new RestTemplate();
}
```

然后当订单模块的Service层获取订单信息的时候，使用如下方法通过远程调用将用户信息填充到Order对象中返回：

```java
@Override
public Order queryOrderById(Long orderId) {
    //1.查询订单
    Order order = orderMapper.findById(orderId);
    //2.利用RestTemplate发起http请求，查询用户
    //2.1 url路径
    String url = "http://localhost:8080/user/" + order.getUserId();
    //2.2 发送http请求，实现远程调用
    User user = restTemplate.getForObject(url, User.class);
    //3.封装user到Order中
    order.setUser(user);
    //4.返回
    return order;
}
```

在IDEA中分别启动订单模块和用户模块，然后浏览器中直接进行访问即可：

```http
http://localhost:8081/order/101
```

![image-20210903223928146](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225254.png) 

#### 2.4 提供者与消费者

在服务调用关系中，会有两个不同的角色：

`服务提供者`：一次业务中，被其它微服务调用的服务(提供接口给其它微服务)；

`服务消费者`：一次业务中，调用其它微服务的服务(调用其它微服务提供的接口)。

![image-20210903224606793](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225301.png) 

但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。

如果服务A调用了服务B，而服务B又调用了服务C，那么服务B的角色是什么？

- 对于A调用B的业务而言：A是服务消费者，B是服务提供者；
- 对于B调用C的业务而言：B是服务消费者，C是服务提供者。

因此，服务B既可以是服务提供者，也可以是服务消费者。

### 3.Eureka注册中心

#### 3.1 Eureka的结构

在上面远程调用的例子中，我们是把调用地址通过如下的一行代码写死在了代码中的：

```java
String url = "http://localhost:8080/user/" + order.getUserId();
```

直接写死就会有很多问题，比如，服务提供者如果是一个集群的话，那这个地址该写成什么合适？我们又如何实现远程调用呢？这时就需要用到注册中心了，我们可以先把各自的微服务注册到注册中心上，需要的时候通过注册中心完成远程调用即可，这一章节主要介绍的是Eureka注册中心的使用。

**Eureka注册中心的结构如下：**

![20210904200248](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904200602.jpg) 

**结构图解：**

1. user-service服务实例启动后，将自己的信息注册到eureka-server(Eureka服务端)，这个是`服务注册`；
2. eureka-server保存服务名称到服务实例地址列表的映射关系中，然后order-service根据服务名称，拉取实例地址列表，这个是`服务发现`或`服务拉取`；
3. 然后order-service从实例列表中利用`负载均衡`算法选中一个实例地址，并向该实例地址发起`远程调用`；
4. user-service会每隔一段时间(默认30秒)向eureka-server发起请求，报告自己的状态，称为**心跳**；当超过一定时间没有发送心跳时，eureka-server会认为对应的微服务实例出现了故障，便会将该实例从服务列表中剔除，这样一来，当order-service拉取服务时，就能将有故障的实例排除掉了。

> **说明**：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端。

#### 3.2 搭建Eureka服务端

Eureka服务端的搭建，需要创建一个独立的微服务，下面就在cloud-parent父工程下创建一个名为eureka-server的SpringBoot工程，目录结构如下所示：

![image-20210904204235259](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221633.png) 

然后我们需要在eureka-server工程对应的pom文件中引入以下依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

之后我们需要在启动类中添加`@EnableEurekaServer`注解：

```java
package com.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@EnableEurekaServer
@SpringBootApplication
public class EurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
```

最后就是在application.yml文件中添加对应的配置，比如下面这样：

```yaml
server:
  port: 10086 # 服务端口
spring:
  application:
    name: eurekaserver # eureka的服务名称，自定义，不重复即可
eureka:
  client:
    service-url:  # eureka的地址信息
      defaultZone: http://localhost:10086/eureka
```

> **说明**：eureka自己也是一个微服务，所以eureka在启动的时候，会将自己在注册到eureka上，所以上面也定义了它自己的服务名称。

接下来就可以在eureka-server的启动类中启动eureka的服务端了，启动成功后直接在浏览器访问如下地址即可：

```http
http://localhost:10086/
```

![image-20210904210416023](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221642.png) 

#### 3.3 服务注册

接下来将我们的user-service服务和order-service服务都注册到Eureka上。

首先在各自工程的pom文件中都引入如下依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

然后在user-service工程的application.yml文件中添加如下内容：

```yaml
spring:
  application:
    name: userservice # user-service服务的服务名称
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```

而在order-service工程的application.yml文件中添加以下内容：

```yaml
spring:
  application:
    name: orderservice # order-service服务的服务名称
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```

然后就可以启动user-service服务以及order-service服务了，服务都启动成功后，我们再到eureka的服务端查看的时候就可以发现，已注册的服务名称中，除了eurekaserver(eureka自身服务的服务名)外，还包含了userservice和orderservice，说明我们自己的服务都已经成功注册到eureka上了。

![image-20210904214759080](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221649.png) 

我们也可以给自己的服务启多个实例，演示一下多实例的效果，下面就以user-service服务为例。本地同一个服务直接启动多个实例的话会端口冲突，所以我们需要变更一下端口，比如`-Dserver.port=8082`这样，步骤如下：

![image-20210904220144332](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221701.png) 

![image-20210904220643931](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221707.png) 

![image-20210904220851962](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221720.png) 

![image-20210904221046962](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221728.png) 

![image-20210904221431546](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221735.png) 

#### 3.4 服务拉取和负载均衡

在前面的步骤中，已经把user-service服务和order-service服务都注册到eureka注册中心了，接下来就从eureka注册中心拉取user-service服务的实例列表并实现负载均衡。

首先在order-service的OrderApplication类中，给RestTemplate这个Bean添加一个`@LoadBalanced`注解：

```java
package com.order;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@MapperScan("com.order.mapper")
@SpringBootApplication
public class OrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

然后修改`com.order.service.impl.OrderServiceImpl#queryOrderById`方法中调用user-service服务的地址，把之前的地址和端口的部分改成user-service服务注册到eureka上的服务名，即`userservice`，如下所示：

```java
@Override
public Order queryOrderById(Long orderId) {
    Order order = orderMapper.findById(orderId);
    //String url = "http://localhost:8080/user/" + order.getUserId();
    String url = "http://userservice/user/" + order.getUserId();
    User user = restTemplate.getForObject(url, User.class);
    order.setUser(user);
    return order;
}
```

完成以上修改后，重启order-service服务，然后在浏览器访问以下地址：

```http
http://localhost:8080/order/102
```

![image-20210904223942005](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225750.png) 

通过以上结果可知，已经通过eureka注册中心获取到了用户信息，我们可以访问多次，来测试负载均衡的效果，我访问了六次后，以下是控制台日志打印的结果：

![image-20210904224427752](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225757.png) 

![image-20210904224815466](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225806.png) 

![image-20210904225013553](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225816.png) 

> **说明**：启动两个user-service服务并且都注册到eureka上后，通过以上截图可知，当我们通过远程调用的方式去访问user-service服务的时候，每个user-service服务都有被访问到，说明确实实现了负载均衡。上面在进行访问测试的时候只访问了六次，其实不管我们访问多少次，多个user-service服务被访问到的概率都是一样的，这也说明默认情况下，多个user-service服务的负载均衡权重是一样的。

### 4.Ribbon负载均衡





























































