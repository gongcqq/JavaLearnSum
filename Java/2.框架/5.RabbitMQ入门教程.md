### 1.初识MQ

#### 1.1 同步和异步通讯

##### 1.1.1 同步通讯的优缺点

同步方式虽然调用可以实时得到结果，但却存在下面的问题：

![image-20211119223715893](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230426.png) 

**同步调用的优点：**

- 时效性较强，可以立即得到结果。

**同步调用的缺点：**

- 耦合度高；
- 性能和吞吐能力下降；
- 有额外的资源消耗；
- 有级联失败问题。

##### 1.1.2 异步通讯的优缺点

异步调用常见实现就是事件驱动模式，以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，需要调用物流服务，从仓库分配响应的库存并准备发货，以及调用短信服务通知支付结果。如下所示：

![image-20211119225121579](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230435.png) 

在事件模式中，支付服务是事件`发布者`(publisher)，在支付完成后只需要发布一个支付成功的`事件`(event)，事件中带上订单id。订单服务、物流服务以及短信服务都是事件`订阅者`(Consumer)，订阅支付成功的事件，监听到事件后完成自己业务即可。

为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是通过起到中间人角色的Broker。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。

![image-20211119225730288](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230442.png) 

Broker是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。

**异步调用的优点：**

- `吞吐量提升`：无需等待订阅者处理完成，响应更快速；
- `故障隔离`：服务没有直接调用，不存在级联失败问题；
- `调用无阻塞`：调用间没有阻塞，不会造成无效的资源占用；
- `低耦合`：耦合度极低，每个服务都可以灵活插拔，可替换；
- `流量削峰`：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件。

**异步调用的缺点：**

- 架构复杂了，业务没有明显的流程线，不好管理；
- 需要依赖于Broker的可靠性、安全性以及性能。

> **说明**：开源软件或云平台上Broker的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。

#### 1.2 常见的MQ技术对比

MQ(MessageQueue)，中文是消息队列，字面来看就是存放消息的队列，也就是事件驱动架构中的Broker。

几种常见MQ的对比如下：

![image-20211119231325786](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119231821.png) 

结论如下：

- `追求可用性`：Kafka、RocketMQ、RabbitMQ
- `追求可靠性`：RabbitMQ、RocketMQ
- `追求吞吐能力`：RocketMQ、Kafka
- `追求消息低延迟`：RabbitMQ、Kafka

### 2.RabbitMQ入门

#### 2.1 RabbitMQ概述

[RabbitMQ](https://www.rabbitmq.com/)是基于Erlang语言开发的开源消息通信中间件，它的基本结构如下所示：

![image-20211119232135006](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119232543.png) 

RabbitMQ中的一些角色：

- `publisher`：生产者；
- `consumer`：消费者；
- `exchange`：交换机，负责消息路由；
- `queue`：队列，存储消息；
- `virtualHost`：虚拟主机，隔离不同租户的exchange、queue以及消息的隔离。

#### 2.2 RabbitMQ的安装

##### 2.2.1 普通方式安装

1. 首先我们从github上下载[rabbitmq安装包](https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm)以及它依赖的[erlang环境包](https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.7/erlang-21.3.7-1.el7.x86_64.rpm)，如果网速不好，也可以使用以下备用下载地址进行下载：

   ```bash
   # 下载rabbitmq-server-3.8.8-1.el7.noarch.rpm
   https://gongsl.lanzoui.com/ioQACwoi41e
   
   # 下载erlang-21.3.7-1.el7.x86_64.rpm
   https://gongsl.lanzoui.com/igGtzwoi3yb
   ```

2. 将下载的包传到linux主机上后就可以进行安装了：

   ```bash
   # 首先安装一个erlang的依赖
   yum install -y socat
   
   # 然后使用rpm命令安装erlang环境
   rpm -ivh erlang-21.3.7-1.el7.x86_64.rpm
   
   # 最后安装rabbitmq
   rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm
   ```

3. 下载完成之后，直接启动即可：

   ```bash
   systemctl start rabbitmq-server
   ```

4. rabbitmq启动成功之后，我们需要安装一个web管理插件，以便能够访问rabbitmq控制台：

   ```bash
   rabbitmq-plugins enable rabbitmq_management
   ```

   ![image-20211120005231454](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120011849.png) 

5. 然后需要添加一个用户，方便登录控制台：

   ```bash
   # 创建用户，用户名是admin，密码是123
   rabbitmqctl add_user admin 123
   
   # 设置用户角色
   rabbitmqctl set_user_tags admin administrator
   
   # 设置用户在"/"这个虚拟主机下的所有权限
   rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"
   
   # 然后我们也可以通过以下命令查看用户
   rabbitmqctl list_users
   ```

6. 最后使用创建好的用户名密码登录控制台即可，地址就是我们主机的地址，端口是`15672`，比如下面这样：

   ```http
   http://192.168.68.11:15672/
   ```

   ![image-20211120011600590](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120011854.png) 

##### 2.2.2 docker方式安装

1. 下载镜像文件：

   ```bash
   # 我这边直接下载目前最新镜像
   docker pull rabbitmq:3.9.9-management
   ```

2. 直接使用`docker run`命令运行MQ容器：

   ```bash
   # 运行容器时创建一个用户，用户名密码都是admin，下面的15672是控制台端口，5672是消息通信的端口
   docker run \
    -e RABBITMQ_DEFAULT_USER=admin \
    -e RABBITMQ_DEFAULT_PASS=admin \
    --name mq \
    --hostname rabbitmq \
    -p 15672:15672 \
    -p 5672:5672 \
    -d \
    rabbitmq:3.9.9-management
   
   # 容器创建成功后我们也可以使用如下命令进行查看
   docker ps
   ```

   > **说明**：我们不手动创建用户也可以，也会自动创建一个用户，用户名密码都是guest。

3. 浏览器直接输入RabbitMQ所在主机地址和`15672`端口即可访问RabbitMQ的控制台，如下所示：

   ```http
   http://192.168.68.11:15672/
   ```

   ![image-20211120112935388](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120113033.png) 

##### 2.2.3 k8s方式部署RabbitMQ集群

**说明**：这里安装所涉及到的yaml文件均来自github上rabbitmq官方的[diy-kubernetes-examples](https://github.com/rabbitmq/diy-kubernetes-examples/tree/master/minikube)项目。这种方式的安装属于迷你版的，像存储之类的东西都没有配置，所以只建议学习使用，不建议用于生产环境。

1. 依次执行以下命令进行集群部署：

   ```bash
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/namespace.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/configmap.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/rbac.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/services.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/sts.yaml
   ```

2. 然后使用如下命令查看部署情况：

   ```bash
   kubectl get svc,po -n test-rabbitmq -o wide
   ```

   ![image-20211120124327956](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125220.png) 

3. 由以上截图可知，控制台的`15672`端口映射到主机的端口是`31672`，所以浏览器随便使用一个集群中主机的地址加上这个端口号即可访问控制台，默认用户名密码都是guest，如下所示：

   ```http
   http://192.168.68.20:31672/
   ```

   ![image-20211120124709159](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125225.png) 

   > **说明**：控制台的`Nodes`栏也可以看到我们部署的RabbitMQ中的三个节点信息。

4. 我们也可以使用`kubectl logs rabbitmq-0 -n test-rabbitmq`命令查看Pod的日志，通过日志可以发现，部署好的Pod会自动加入到MQ集群中。

   ![image-20211120125737867](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125747.png) 

#### 2.3 RabbitMQ消息模型

在RabbitMQ官网上介绍的[消息模型](https://www.rabbitmq.com/getstarted.html)总共有七种，但是其实最常用的只有前五种，如下所示：

![image-20211122122415988](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123313.png) 

- 第一种属于基本消息队列(BasicQueue)，如下图：

  ![image-20211122122656579](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123321.png) 

- 第二种属于工作消息队列(WorkQueue)，如下图：

  ![image-20211122122754441](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123325.png) 

- 第三种是发布、订阅的广播(Fanout)模式，如下图：

  ![image-20211122122954906](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123329.png) 

- 第四种是发布、订阅的路由(Direct)模式，如下图：

  ![image-20211122123033157](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123334.png) 

- 第五种是发布、订阅的主题(Topic)模式，如下图：

  ![image-20211122123106982](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123339.png) 

### 3.RabbitMQ入门案例

官方的HelloWorld案例是基于最基础的消息队列模型来实现的，只包括三个角色：

- `publisher`：消息发布者，将消息发送到队列queue；
- `queue`：消息队列，负责接受并缓存消息；
- `consumer`：订阅队列，处理队列中的消息。

![image-20211122141448984](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122152945.png) 

首先在IDEA中导入[rabbitmq-demo](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122152945.png)工程，该工程下包含publisher和consumer这两个子工程，其中publisher工程用于发布消息，consumer工程用于消费消息。

publisher工程中的用于发布消息的PublisherTest类内容如下：

```java
package com.mq.demo.test;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class PublisherTest {

    public static void main(String args[]) throws IOException, TimeoutException {
        // 1.建立连接
        ConnectionFactory factory = new ConnectionFactory();
        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
        factory.setHost("192.168.68.11"); //需要改成自己的MQ所在主机的地址
        factory.setPort(5672);
        factory.setVirtualHost("/");
        factory.setUsername("admin");
        factory.setPassword("admin");
        // 1.2.建立连接
        Connection connection = factory.newConnection();

        // 2.创建通道Channel
        Channel channel = connection.createChannel();

        // 3.创建队列
        String queueName = "simple.queue";
        channel.queueDeclare(queueName, false, false, false, null);

        // 4.发送消息
        String message = "hello, rabbitmq!";
        channel.basicPublish("", queueName, null, message.getBytes());
        System.out.println("发送消息成功：【" + message + "】");

        // 5.关闭通道和连接
        channel.close();
        connection.close();

    }
}
```

consumer工程中的用于消费消息的ConsumerTest类内容如下：

```java
package com.mq.demo.test;

import com.rabbitmq.client.*;
import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class ConsumerTest {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 1.建立连接
        ConnectionFactory factory = new ConnectionFactory();
        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
        factory.setHost("192.168.68.11");
        factory.setPort(5672);
        factory.setVirtualHost("/");
        factory.setUsername("admin");
        factory.setPassword("admin");
        // 1.2.建立连接
        Connection connection = factory.newConnection();

        // 2.创建通道Channel
        Channel channel = connection.createChannel();

        // 3.创建队列
        String queueName = "simple.queue";
        channel.queueDeclare(queueName, false, false, false, null);

        // 4.订阅消息
        channel.basicConsume(queueName, true, new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body) {
                // 5.处理消息
                String message = new String(body);
                String threadName = Thread.currentThread().getName();
                System.out.println("["+threadName+"]线程接收到消息：【" + message + "】");
            }
        });
        System.out.println("["+Thread.currentThread().getName()+"]线程等待接收消息。。。。");
    }
}
```

我们先运行`PublisherTest`类，运行成功后，我们到RabbitMQ控制台进行查看，可以发现在`队列`菜单栏下多出一个队列，名称就是我们在代码中命名的队列名：

![image-20211122173313570](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190544.png) 

点击队列名后，可以在`Get messages`下面查看到我们发布的消息的具体内容：

![image-20211122173648218](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190552.png) 

然后我们再运行`ConsumerTest`类，运行成功后，队列里的消息就被消费调了，然后控制台会打印如下内容：

![image-20211122173921541](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190604.png) 

> **说明**：我在代码中把当前线程的线程名打印出来了，通过以上截图也可以发现，RabbitMQ在消费消息的时候和发送消息一样都是通过异步的方式，都不会阻塞主线程。

### 4.整合SpringBoot

#### 4.1 什么是SpringAMQP

MQ和SpringBoot的整合主要依靠于SpringAMQP，关于[SpringAMQP](https://spring.io/projects/spring-amqp)的介绍如下：

![image-20211122191637494](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122191650.png) 

#### 4.2 演示基本消息队列

在RabbitMQ入门案例中，我们使用的**rabbitmq-demo**工程就是一个SpringBoot工程，所以这里就还使用这个工程。在整合SpringBoot时，给RabbitMQ发送消息，可以使用spring-rabbit提供的`RabbitTemplate`类。

1. 由于rabbitmq-demo工程中的两个子工程都需要用到AMQP相关的依赖，所以我们就直接在父工程的pom文件中引入相关依赖：

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   ```

2. 编写publisher服务的application.yml文件，添加MQ的连接信息：

   ```yaml
   spring:
     rabbitmq:
       host: 192.168.68.11 # MQ所在主机的IP地址
       port: 5672 # 端口
       virtual-host: / # 虚拟主机
       username: admin #用户名
       password: admin # 密码
   ```

3. 在publisher服务中新建一个测试类，并编写测试方法：

   ```java
   package com.mq.demo;
   
   import org.junit.Test;
   import org.junit.runner.RunWith;
   import org.springframework.amqp.rabbit.core.RabbitTemplate;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.test.context.junit4.SpringRunner;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-22 19:48
    */
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class SpringAmqpTest {
   
       @Autowired
       private RabbitTemplate rabbitTemplate;
   
       @Test
       public void testSimpleQueue() {
           //队列的名称
           String queueName = "simple.queue";
           //消息的内容
           String message = "hello, spring amqp!";
           rabbitTemplate.convertAndSend(queueName, message);
       }
   }
   ```

4. 启动测试，进行消息的发布，然后到控制台可以看到确实有一条待消费的消息存在：

   ![image-20211123112617061](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211123115519.png) 

   点击队列名称进去查看消息内容，发现确实是我们代码中设置的内容：

   ![image-20211123112745914](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211123115526.png) 

   > **注意**：使用`rabbitTemplate.convertAndSend()`发送消息的时候，如果队列已存在，消息可以发送成功；但是如果队列不存在，虽然代码执行不会报错，但是也不会自动创建队列，那么这个消息其实就算丢失了。

5. 





















































