### 1.初识MQ

#### 1.1 同步和异步通讯

##### 1.1.1 同步通讯的优缺点

同步方式虽然调用可以实时得到结果，但却存在下面的问题：

![image-20211119223715893](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230426.png) 

**同步调用的优点：**

- 时效性较强，可以立即得到结果。

**同步调用的缺点：**

- 耦合度高；
- 性能和吞吐能力下降；
- 有额外的资源消耗；
- 有级联失败问题。

##### 1.1.2 异步通讯的优缺点

异步调用常见实现就是事件驱动模式，以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，需要调用物流服务，从仓库分配响应的库存并准备发货，以及调用短信服务通知支付结果。如下所示：

![image-20211119225121579](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230435.png) 

在事件模式中，支付服务是事件`发布者`(publisher)，在支付完成后只需要发布一个支付成功的`事件`(event)，事件中带上订单id。订单服务、物流服务以及短信服务都是事件`订阅者`(Consumer)，订阅支付成功的事件，监听到事件后完成自己业务即可。

为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是通过起到中间人角色的Broker。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。

![image-20211119225730288](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119230442.png) 

Broker是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。

**异步调用的优点：**

- `吞吐量提升`：无需等待订阅者处理完成，响应更快速；
- `故障隔离`：服务没有直接调用，不存在级联失败问题；
- `调用无阻塞`：调用间没有阻塞，不会造成无效的资源占用；
- `低耦合`：耦合度极低，每个服务都可以灵活插拔，可替换；
- `流量削峰`：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件。

**异步调用的缺点：**

- 架构复杂了，业务没有明显的流程线，不好管理；
- 需要依赖于Broker的可靠性、安全性以及性能。

> **说明**：开源软件或云平台上Broker的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。

#### 1.2 常见的MQ技术对比

MQ(MessageQueue)，中文是消息队列，字面来看就是存放消息的队列，也就是事件驱动架构中的Broker。

几种常见MQ的对比如下：

![image-20211119231325786](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119231821.png) 

结论如下：

- `追求可用性`：Kafka、RocketMQ、RabbitMQ
- `追求可靠性`：RabbitMQ、RocketMQ
- `追求吞吐能力`：RocketMQ、Kafka
- `追求消息低延迟`：RabbitMQ、Kafka

### 2.RabbitMQ入门

#### 2.1 RabbitMQ概述

[RabbitMQ](https://www.rabbitmq.com/)是基于Erlang语言开发的开源消息通信中间件，它的基本结构如下所示：

![image-20211119232135006](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211119232543.png) 

RabbitMQ中的一些角色：

- `publisher`：生产者；
- `consumer`：消费者；
- `exchange`：交换机，负责消息路由；
- `queue`：队列，存储消息；
- `virtualHost`：虚拟主机，隔离不同租户的exchange、queue以及消息的隔离。

#### 2.2 RabbitMQ的安装

##### 2.2.1 普通方式安装

1. 首先我们从github上下载[rabbitmq安装包](https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm)以及它依赖的[erlang环境包](https://github.com/rabbitmq/erlang-rpm/releases/download/v21.3.7/erlang-21.3.7-1.el7.x86_64.rpm)，如果网速不好，也可以使用以下备用下载地址进行下载：

   ```bash
   # 下载rabbitmq-server-3.8.8-1.el7.noarch.rpm
   https://gongsl.lanzoui.com/ioQACwoi41e
   
   # 下载erlang-21.3.7-1.el7.x86_64.rpm
   https://gongsl.lanzoui.com/igGtzwoi3yb
   ```

2. 将下载的包传到linux主机上后就可以进行安装了：

   ```bash
   # 首先安装一个erlang的依赖
   yum install -y socat
   
   # 然后使用rpm命令安装erlang环境
   rpm -ivh erlang-21.3.7-1.el7.x86_64.rpm
   
   # 最后安装rabbitmq
   rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm
   ```

3. 下载完成之后，直接启动即可：

   ```bash
   systemctl start rabbitmq-server
   ```

4. rabbitmq启动成功之后，我们需要安装一个web管理插件，以便能够访问rabbitmq控制台：

   ```bash
   rabbitmq-plugins enable rabbitmq_management
   ```

   ![image-20211120005231454](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120011849.png) 

5. 然后需要添加一个用户，方便登录控制台：

   ```bash
   # 创建用户，用户名是admin，密码是123
   rabbitmqctl add_user admin 123
   
   # 设置用户角色
   rabbitmqctl set_user_tags admin administrator
   
   # 设置用户在"/"这个虚拟主机下的所有权限
   rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"
   
   # 然后我们也可以通过以下命令查看用户
   rabbitmqctl list_users
   ```

6. 最后使用创建好的用户名密码登录控制台即可，地址就是我们主机的地址，端口是`15672`，比如下面这样：

   ```http
   http://192.168.68.11:15672/
   ```

   ![image-20211120011600590](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120011854.png) 

##### 2.2.2 docker方式安装

1. 下载镜像文件：

   ```bash
   # 我这边直接下载目前最新镜像
   docker pull rabbitmq:3.9.9-management
   ```

2. 直接使用`docker run`命令运行MQ容器：

   ```bash
   # 运行容器时创建一个用户，用户名密码都是admin，下面的15672是控制台端口，5672是消息通信的端口
   docker run \
    -e RABBITMQ_DEFAULT_USER=admin \
    -e RABBITMQ_DEFAULT_PASS=admin \
    --name mq \
    --hostname rabbitmq \
    -p 15672:15672 \
    -p 5672:5672 \
    -d \
    rabbitmq:3.9.9-management
   
   # 容器创建成功后我们也可以使用如下命令进行查看
   docker ps
   ```

   > **说明**：我们不手动创建用户也可以，也会自动创建一个用户，用户名密码都是guest。

3. 浏览器直接输入RabbitMQ所在主机地址和`15672`端口即可访问RabbitMQ的控制台，如下所示：

   ```http
   http://192.168.68.11:15672/
   ```

   ![image-20211120112935388](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120113033.png) 

#### 2.3 RabbitMQ消息模型

在RabbitMQ官网上介绍的[消息模型](https://www.rabbitmq.com/getstarted.html)总共有七种，但是其实最常用的只有前五种，如下所示：

![image-20211122122415988](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123313.png) 

- 第一种属于基本消息队列(BasicQueue)，如下图：

  ![image-20211122122656579](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123321.png) 

- 第二种属于工作消息队列(WorkQueue)，如下图：

  ![image-20211122122754441](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123325.png) 

- 第三种是发布、订阅的广播(Fanout)模式，如下图：

  ![image-20211122122954906](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123329.png) 

- 第四种是发布、订阅的路由(Direct)模式，如下图：

  ![image-20211122123033157](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123334.png) 

- 第五种是发布、订阅的主题(Topic)模式，如下图：

  ![image-20211122123106982](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122123339.png) 

### 3.RabbitMQ入门案例

官方的HelloWorld案例是基于最基础的消息队列模型来实现的，只包括三个角色：

- `publisher`：消息发布者，将消息发送到队列queue；
- `queue`：消息队列，负责接受并缓存消息；
- `consumer`：订阅队列，处理队列中的消息。

![image-20211122141448984](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122152945.png) 

首先在IDEA中导入[rabbitmq-demo](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122152945.png)工程，该工程下包含publisher和consumer这两个子工程，其中publisher工程用于发布消息，consumer工程用于消费消息。

publisher工程中的用于发布消息的PublisherTest类内容如下：

```java
package com.mq.demo.test;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class PublisherTest {

    public static void main(String args[]) throws IOException, TimeoutException {
        // 1.建立连接
        ConnectionFactory factory = new ConnectionFactory();
        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
        factory.setHost("192.168.68.11"); //需要改成自己的MQ所在主机的地址
        factory.setPort(5672);
        factory.setVirtualHost("/");
        factory.setUsername("admin");
        factory.setPassword("admin");
        // 1.2.建立连接
        Connection connection = factory.newConnection();

        // 2.创建通道Channel
        Channel channel = connection.createChannel();

        // 3.创建队列
        String queueName = "simple.queue";
        channel.queueDeclare(queueName, false, false, false, null);

        // 4.发送消息
        String message = "hello, rabbitmq!";
        channel.basicPublish("", queueName, null, message.getBytes());
        System.out.println("发送消息成功：【" + message + "】");

        // 5.关闭通道和连接
        channel.close();
        connection.close();

    }
}
```

consumer工程中的用于消费消息的ConsumerTest类内容如下：

```java
package com.mq.demo.test;

import com.rabbitmq.client.*;
import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class ConsumerTest {

    public static void main(String[] args) throws IOException, TimeoutException {
        // 1.建立连接
        ConnectionFactory factory = new ConnectionFactory();
        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码
        factory.setHost("192.168.68.11");
        factory.setPort(5672);
        factory.setVirtualHost("/");
        factory.setUsername("admin");
        factory.setPassword("admin");
        // 1.2.建立连接
        Connection connection = factory.newConnection();

        // 2.创建通道Channel
        Channel channel = connection.createChannel();

        // 3.创建队列
        String queueName = "simple.queue";
        channel.queueDeclare(queueName, false, false, false, null);

        // 4.订阅消息
        channel.basicConsume(queueName, true, new DefaultConsumer(channel){
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body) {
                // 5.处理消息
                String message = new String(body);
                String threadName = Thread.currentThread().getName();
                System.out.println("["+threadName+"]线程接收到消息：【" + message + "】");
            }
        });
        System.out.println("["+Thread.currentThread().getName()+"]线程等待接收消息。。。。");
    }
}
```

我们先运行`PublisherTest`类，运行成功后，我们到RabbitMQ控制台进行查看，可以发现在`队列`菜单栏下多出一个队列，名称就是我们在代码中命名的队列名：

![image-20211122173313570](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190544.png) 

点击队列名后，可以在`Get messages`下面查看到我们发布的消息的具体内容：

![image-20211122173648218](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190552.png) 

然后我们再运行`ConsumerTest`类，运行成功后，队列里的消息就被消费调了，然后控制台会打印如下内容：

![image-20211122173921541](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122190604.png) 

> **说明**：我在代码中把当前线程的线程名打印出来了，通过以上截图也可以发现，RabbitMQ在消费消息的时候和发送消息一样都是通过异步的方式，都不会阻塞主线程。

### 4.整合SpringBoot

#### 4.1 什么是SpringAMQP

MQ和SpringBoot的整合主要依靠于SpringAMQP，关于[SpringAMQP](https://spring.io/projects/spring-amqp)的介绍如下：

![image-20211122191637494](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211122191650.png) 

#### 4.2 演示基本消息队列

在RabbitMQ入门案例中，我们使用的**rabbitmq-demo**工程就是一个SpringBoot工程，所以这里就还使用这个工程。在整合SpringBoot时，给RabbitMQ发送消息，可以使用spring-rabbit提供的`RabbitTemplate`类。

1. 由于rabbitmq-demo工程中的两个子工程都需要用到AMQP相关的依赖，所以我们就直接在父工程的pom文件中引入相关依赖：

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   ```

2. 编写publisher服务的application.yml文件，添加MQ的连接信息：

   ```yaml
   spring:
     rabbitmq:
       host: 192.168.68.11 # MQ所在主机的IP地址
       port: 5672 # 端口
       virtual-host: / # 虚拟主机
       username: admin #用户名
       password: admin # 密码
   ```

3. 在publisher服务中新建一个测试类，并编写测试方法：

   ```java
   package com.mq.demo;
   
   import org.junit.Test;
   import org.junit.runner.RunWith;
   import org.springframework.amqp.rabbit.core.RabbitTemplate;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.test.context.junit4.SpringRunner;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-22 19:48
    */
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class SpringAmqpTest {
   
       @Autowired
       private RabbitTemplate rabbitTemplate;
   
       @Test
       public void testSimpleQueue() {
           //队列的名称
           String queueName = "simple.queue";
           //消息的内容
           String message = "hello, spring amqp!";
           rabbitTemplate.convertAndSend(queueName, message);
       }
   }
   ```

4. 启动测试，进行消息的发布，然后到控制台可以看到确实有一条待消费的消息存在：

   ![image-20211123112617061](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211123115519.png) 

   点击队列名称进去查看消息内容，发现确实是我们代码中设置的内容：

   ![image-20211123112745914](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211123115526.png) 

   > **注意**：使用`rabbitTemplate.convertAndSend()`发送消息的时候，如果队列已存在，消息可以发送成功；但是如果队列不存在，虽然代码执行不会报错，但是也不会自动创建队列，那么这个消息其实就算丢失了。

5. 接下来在consumer服务的application.yml中也配置MQ的连接信息：

   ```yaml
   spring:
     rabbitmq:
       host: 192.168.68.11 # MQ所在主机的IP地址
       port: 5672 # 端口
       virtual-host: / # 虚拟主机
       username: admin #用户名
       password: admin # 密码
   ```

6. 然后在consumer服务中新建一个消费消息的类，在类中定义一个使用`@RabbitListener`注解的方法，用于接收指定队列传过来的消息，并做相应处理：

   ```java
   package com.mq.demo.listener;
   
   import org.springframework.amqp.rabbit.annotation.RabbitListener;
   import org.springframework.stereotype.Component;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-23 16:33
    */
   @Component
   public class SpringRabbitListener {
   
       @RabbitListener(queues = "simple.queue")
       public void listenSimpleQueueMessage(String msg){
           System.out.println("消费者接收到消息：【" + msg + "】");
       }
   }
   ```

7. 之后我们直接运行consumer服务的启动类`ConsumerApplication`即可，可以看到控制台打印如下，说明我们发送的消息确实已经被消费了：

   ![image-20211123164227922](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151739.png) 

   然后在RabbitMQ管理控制台上也可以看到消息已经没有了：

   ![image-20211123164327848](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151745.png) 

   > **注意**：消息一旦被消费就会从队列中删除，而且RabbitMQ是没有消息回溯功能的。

#### 4.3 演示工作消息队列

工作消息队列和基本消息队列相比，最大的区别就是它有多个消费者，好处是可以提高消息处理速度，避免队列消息堆积。

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151750.png" alt="image-20211123170532794" style="zoom: 70%;" /> 

下面会沿用以上基本消息队列中用到的类，并在其中新增一些方式来演示工作消息队列：

1. 在publisher服务的`SpringAmqpTest`类中新增如下内容，然后运行该方法发布消息：

   ```java
   @Test
   public void testWorkQueue() throws InterruptedException {
       String queueName = "simple.queue";
       String message = ">>>hello, message-";
       for (int i = 1; i <= 50; i++) {
           //发消息
           rabbitTemplate.convertAndSend(queueName, message + i);
           //避免发送太快，让这50个消息在一秒钟内发完
           Thread.sleep(20);
       }
   }
   ```

2. 之后修改consumer服务的`SpringRabbitListener`类，将之前的listenSimpleQueueMessage方法暂时先注释掉，然后新增两个消费同一队列中消息的方法，最终内容如下：

   ```java
   package com.mq.demo.listener;
   
   import org.springframework.amqp.rabbit.annotation.RabbitListener;
   import org.springframework.stereotype.Component;
   import java.time.LocalTime;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-23 16:33
    */
   @Component
   public class SpringRabbitListener {
   
       /*@RabbitListener(queues = "simple.queue")
       public void listenSimpleQueueMessage(String msg){
           System.out.println("消费者接收到消息：【" + msg + "】");
       }*/
   
       @RabbitListener(queues = "simple.queue")
       public void listenWorkQueueMessage1(String msg) throws InterruptedException {
           System.out.println("消费者1接收到消息：【" + msg + "】--->" + LocalTime.now());
           Thread.sleep(25);
       }
   
       @RabbitListener(queues = "simple.queue")
       public void listenWorkQueueMessage2(String msg) throws InterruptedException {
           System.err.println("消费者2接收到消息：【" + msg + "】--->" + LocalTime.now());
           Thread.sleep(100);
       }
   }
   ```

3. 通过以上代码可知，消费者1每秒可以消费40个消息，消费者2每秒可以消费10个消息，两个消费者同时进行消费，按理说一秒内就能将我们发布的50个消息消费掉才对，但是运行consumer服务后控制台打印是这样的：

   ![image-20211123211721368](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151758.png) 

   ![image-20211123212431902](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151803.png) 

   > **说明**：从整个结果看，两个消费者消费50个消息，总共用了两秒多，比预期的时间慢了一倍。而且我们设置的消费者1的消费速度是更快的，按理说应该能者多劳，让消费者1消费更多消息的，但是从控制台打印结果看，并不是谁消费能力强谁就消费的多，反而是50个消息两个消费者对半分，一个消费者消费25个消息。

4. 出现以上结果的原因是受RabbitMQ内部的消费预取机制影响，这种机制就是不管处理的快不快，消费者都会先把消息拿过来再说，再慢慢处理。这样的话，就算消费者1早就已经消费完预取的消息啦，也没法继续处理剩下的消息了，因为剩下的消息已经被消费者2预取了。我们可以通过在consumer服务的application.yml文件中设置prefetch的值来控制预取消息的上限，如下所示：

   ```yaml
   spring:
     rabbitmq:
       listener:
         simple:
           prefetch: 1 # 每次只能获取一条消息，处理完成后才能获取下一个消息
   ```

5. 设置完成之后重启consumer服务，然后我们再发布50条消息，观察控制台打印结果：

   ![image-20211124112228446](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151810.png) 

   ![image-20211124112948490](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124151815.png) 

#### 4.4 演示发布订阅队列

发布订阅模式与前面案例的区别就是允许将同一消息发送给多个消费者，实现方式是加入了exchange(交换机)。

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124155306.png" alt="image-20211124153125427" style="zoom:67%;" /> 

常见的exchange类型包括：

- `Fanout`：广播；
- `Direct`：路由；
- `Topic`：话题。

> **注意**：exchange是负责消息路由的，而不是存储，所以路由失败消息就会丢失。

##### 4.4.1 发布订阅-Fanout Exchange

`Fanout Exchange`会将接收到的消息广播到每一个跟其绑定的队列，如下所示：

![image-20211124155244716](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124155315.png) 

下面利用SpringAMQP演示Fanout Exchange的使用，具体思路如下：

- 在consumer服务中，利用代码声明Exchange、Queue，并将两者进行绑定；
- 在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2这两个队列；
- 在publisher服务中编写测试方法，向名为test.fanout的交换机发送消息。

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124160535.png" alt="image-20211124155721709" style="zoom:67%;" /> 

SpringAMQP是提供了声明交换机、队列、绑定关系的API的，如下所示：

![image-20211124160637947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165455.png) 

下面就演示下Fanout Exchange的使用，具体实现步骤如下所示：

1. 在consumer服务中增加一个配置类，并在该类中声明FanoutExchange、Queue和绑定关系对象Binding，具体内容如下所示：

   ```java
   package com.mq.demo.config;
   
   import org.springframework.amqp.core.Binding;
   import org.springframework.amqp.core.BindingBuilder;
   import org.springframework.amqp.core.FanoutExchange;
   import org.springframework.amqp.core.Queue;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-24 16:12
    */
   @Configuration
   public class FanoutConfig {
   
       //声明FanoutExchange交换机
       @Bean
       public FanoutExchange fanoutExchange(){
           return new FanoutExchange("test.fanout");
       }
   
       //声明第一个队列
       @Bean
       public Queue fanoutQueue1(){
           return new Queue("fanout.queue1");
       }
   
       //将队列1和交换机绑定起来
       @Bean
       public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){
           return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
       }
   
       //声明第二个队列
       @Bean
       public Queue fanoutQueue2(){
           return new Queue("fanout.queue2");
       }
   
       //将队列2和交换机绑定起来
       @Bean
       public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){
           return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);
       }
   }
   ```

2. 然后我们在consumer服务的`SpringRabbitListener`类中再添加两个方法，分别用于监听上一步声明的两个队列：

   ```java
   @RabbitListener(queues = "fanout.queue1")
   public void listenFanoutQueue1(String msg) {
       System.out.println("消费者1接收到fanout消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(queues = "fanout.queue2")
   public void listenFanoutQueue2(String msg) {
       System.out.println("消费者2接收到fanout消息：【" + msg + "】--->" + LocalTime.now());
   }
   ```

3. 之后在publisher服务的`SpringAmqpTest`类中添加测试方法，用于发布消息：

   ```java
   @Test
   public void testFanoutQueue() {
       //交换机名称
       String exchangeName = "test.fanout";
       //消息
       String message = "hello, everyone!";
       //发送消息，入参分别是交换机名称、routingKey(暂时为空)、消息
       rabbitTemplate.convertAndSend(exchangeName,"",message);
   }
   ```

4. 代码编写完成之后，启动consumer服务，然后在RabbitMQ的控制台可以看到在代码中创建的两个队列，而且也多了一个交换机，点击我们新增的那个交换机后，可以看到绑定的正是我们新增的那两个队列：

   ![image-20211124164547672](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165508.png) 

   ![image-20211124164716274](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165515.png) 

   点击名为`test.fanout`的交换机后，可以查看和队列的绑定关系：

   ![image-20211124165300396](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124165520.png) 

5. 接下来运行publisher服务中SpringAmqpTest类里面的testFanoutQueue方法发送消息，通过consumer服务控制台的打印结果可知，发送的一条消息同时被多个消费者进行了消费：

   ![image-20211124165927021](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124170009.png) 

> **说明**：通过以上演示结果可知，Fanout Exchange确实会将消息路由到每个绑定的队列上，然后每个队列对应的消费者再从队列中获取消息进行消费。

##### 4.4.2 发布订阅-Direct Exchange

`Direct Exchange`会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式：

- 每一个Queue都与Exchange设置一个BindingKey；
- 发布者发送消息时，可以指定消息的RoutingKey进行发布；
- Exchange会将消息路由到BindingKey与消息的RoutingKey一致的队列。

如下图所示，RoutingKey的值如果为`blue`的话，消息会被路由到queue1队列，然后被该队列下的消费者消费；如果值为`yellow`的话，消息就会被路由到queue2队列，并被该队列下的消费者消费；如果值为`red`的话，那么消息就会被分别路由到queue1队列和queue2队列，并被它们各自的消费者消费：

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124174207.png" alt="image-20211124173747573" style="zoom: 60%;" /> 

下面利用SpringAMQP演示Direct Exchange的使用，具体思路如下：

- 利用@RabbitListener声明Exchange、Queue、RoutingKey；
- 在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2这两个队列；
- 在publisher服务中编写测试方法，向名为test.direct的交换机发送消息。

![image-20211124174626092](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124174700.png) 

> **说明**：前面在演示Fanout Exchange的时候，Exchange、Queue等都是通过`@Bean`注解声明的，这种方式太过于麻烦了，所以这里就直接通过配置`@RabbitListener`注解中的相关参数来进行声明。

下面就演示下Direct Exchange的使用，具体实现步骤如下所示：

1. 在consumer服务的`SpringRabbitListener`类中，编写两个消费者方法，使用`@RabbitListener`注解分别配置监听的队列，并通过该注解的其余参数声明Exchange以及RoutingKey，具体内容如下：

   ```java
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "direct.queue1"),
           exchange = @Exchange(name = "test.direct",type = ExchangeTypes.DIRECT),
           key = {"red", "blue"}
   ))
   public void listenDirectQueue1(String msg) {
       System.out.println("消费者1接收到direct消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "direct.queue2"),
           exchange = @Exchange(name = "test.direct",type = ExchangeTypes.DIRECT),
           key = {"red", "yellow"}
   ))
   public void listenDirectQueue2(String msg) {
       System.out.println("消费者2接收到direct消息：【" + msg + "】--->" + LocalTime.now());
   }
   ```

   > **说明**：在以上`@RabbitListener`注解中，`@QueueBinding`注解的exchange属性是用来绑定交换机的，并且可以通过`@Exchange`注解的type属性声明交换机的类型(默认类型就是**direct**)，然后@QueueBinding注解的另一个key属性就是用来指定**bindingKey**的，支持指定多个。

2. 然后在publisher服务的SpringAmqpTest类中添加一个发布消息的测试方法：

   ```java
   @Test
   public void testDirectQueue() {
       //交换机名称
       String exchangeName = "test.direct";
       String routingKey = "blue";
       //消息
       String message = "hello, blue!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

   > **说明**：这里将routingKey的值设置为`blue`，所以消息只会路由到queue1队列。

3. 启动consumer服务后，RabbitMQ的控制台就会多出direct.queue1和direct.queue2这两个队列，同时也会多出一个名为test.direct的交换机，点击进去后，可以查看交换机和队列的绑定关系：

   ![image-20211124182756184](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184709.png) 

4. 然后我们运行publisher服务中SpringAmqpTest类的testDirectQueue方法发布消息，观察consumer服务控制台的打印结果：

   ![image-20211124183025301](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184718.png) 

   > **说明**：由于direct.queue1队列与交换机的bindingKey中包含`blue`这个值，而发布消息时routingKey的值就设置的是`blue`，所以消息就只路由到了direct.queue1队列，并被该队列下的消费者消费。

5. 我们将publisher服务的SpringAmqpTest类中的testDirectQueue方法改成下面这样，再重新发布消息：

   ```java
   @Test
   public void testDirectQueue() {
       //交换机名称
       String exchangeName = "test.direct";
       String routingKey = "yellow";
       //消息
       String message = "hello, yellow!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

   通过consumer服务的控制台打印可以发现，由于只有direct.queue2队列与交换机的bindingKey中包含`yellow`这个值，所以消息就只路由到了direct.queue2队列，并被该队列下的消费者消费：

   ![image-20211124183553931](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184724.png) 

6. 如果我们将publisher服务的SpringAmqpTest类中的testDirectQueue方法改成下面这样：

   ```java
   @Test
   public void testDirectQueue() {
       //交换机名称
       String exchangeName = "test.direct";
       String routingKey = "red";
       //消息
       String message = "hello, red!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

   由于两个队列与交换机的bindingKey中都包含`red`这个值，所以当routingKey的值设置为`red`时，两个队列都是会收到路由过来的消息的，所以consumer服务的控制台打印如下：

   ![image-20211124184143616](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124184729.png) 

> **说明**：在`Direct Exchange`这种模式中，如果所有与交换机绑定的队列的bindingKey里面都包含发布消息时设置的routingKey的值，那么这种模式就和`Fanout Exchange`模式功能是一样的啦。

##### 4.4.3 发布订阅-Topic Exchange

`Topic Exchange`与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以==.==分割。

Queue与Exchange指定BindingKey时也可以使用通配符：

- `#`：代指零个或多个单词；
- `*`：代指一个单词。

下面利用SpringAMQP演示Topic Exchange的使用，具体思路如下：

- 利用@RabbitListener声明Exchange、Queue、RoutingKey；
- 在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2这两个队列；
- 在publisher服务中编写测试方法，向名为test.topic的交换机发送消息。

![image-20211124210649082](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124212943.png) 

下面就演示下Topic Exchange的使用，具体实现步骤如下所示：

1. 在consumer服务的`SpringRabbitListener`类中，编写两个消费者方法，使用`@RabbitListener`注解分别配置监听的队列，并通过该注解的其余参数声明Exchange以及RoutingKey，具体内容如下：

   ```java
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "topic.queue1"),
           exchange = @Exchange(name = "test.topic",type = ExchangeTypes.TOPIC),
           key = "china.#"
   ))
   public void listenTopicQueue1(String msg) {
       System.out.println("消费者1接收到topic消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "topic.queue2"),
           exchange = @Exchange(name = "test.topic",type = ExchangeTypes.TOPIC),
           key = "#.news"
   ))
   public void listenTopicQueue2(String msg) {
       System.out.println("消费者2接收到topic消息：【" + msg + "】--->" + LocalTime.now());
   }
   
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "topic.queue3"),
           exchange = @Exchange(name = "test.topic",type = ExchangeTypes.TOPIC),
           key = "china.*"
   ))
   public void listenTopicQueue3(String msg) {
       System.out.println("消费者3接收到topic消息：【" + msg + "】--->" + LocalTime.now());
   }
   ```

2. 然后在publisher服务的SpringAmqpTest类中添加一个发布消息的测试方法：

   ```java
   @Test
   public void testTopicQueue() {
       //交换机名称
       String exchangeName = "test.topic";
       String routingKey = "china.news";
       //消息
       String message = "hello, topic!";
       //发送消息，入参分别是交换机名称、routingKey、消息
       rabbitTemplate.convertAndSend(exchangeName, routingKey, message);
   }
   ```

3. 启动consumer服务后，RabbitMQ的控制台就会多出topic相关的三个队列，同时也会多出一个名为test.topic的交换机，点击进去后，可以查看交换机和队列的绑定关系：

   ![image-20211124211227751](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124212959.png) 

4. 然后我们运行publisher服务中SpringAmqpTest类的testTopicQueue方法发布消息，观察consumer服务控制台的打印结果：

   ![image-20211124211340666](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124213008.png) 

   > **说明**：由于三个队列在和交换机绑定的时候，bindingKey中的通配符都可以匹配到RoutingKey的值，所以消息就都路由到这三个队列中了，所以它们对应的消费者就都消费消息了。

5. 如果我们将SpringAmqpTest类中testTopicQueue方法的routingKey的值改成`china.other`的话，那么当重新发布消息后，由于`topic.queue2`队列的bindingKey中的通配符匹配不到routingKey，所以不会向该队列路由消息，该队列的消费者也就无法消费消息，所以consumer服务的控制台打印如下：

   ![image-20211124212235957](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124213013.png) 

   如果我们把routingKey的值改成`china.today.news`的话，由于`topic.queue3`队列的bindingKey中的通配符使用的是`*`，所以只能匹配一个单词，如果routingKey的值是china.today的话还可以匹配到，但多个news就匹配不到了，所以不会向该队列路由消息，该队列的消费者也就无法消费消息，所以consumer服务的控制台打印如下：

   ![image-20211124212931103](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211124213018.png) 

#### 4.5 发送Object类型的消息

在前面演示发布消息的时候，都是使用的字符串类型的消息，所以并不知道如果消息是一个Object对象的话会怎么样，这里就以Map集合为例：

在publisher服务的SpringAmqpTest类中新增一个测试方法：

```java
@Test
public void testObjectQueue() {
    //这里就直接使用演示基础消息队列时创建的队列
    String queueName = "simple.queue";
    Map<String, Object> msg = new HashMap<>();
    msg.put("name", "张三");
    msg.put("age", 20);
    rabbitTemplate.convertAndSend(queueName, msg);
}
```

直接运行testObjectQueue方法发布消息，然后到RabbitMQ控制台查看消息内容：

![image-20211124215449900](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211125000222.png) 

> **说明**：可以发现，Object类型的消息被序列化了。Spring对消息对象的处理是由`MessageConverter`来处理的。而默认实现是`SimpleMessageConverter`，基于JDK的ObjectOutputStream完成序列化使用的是java里面的序列化方式，这种方式我们是不推荐使用的，推荐用JSON方式序列化。

下面就演示使用JSON方式序列化的相关操作步骤：

1. 我们在父工程的pom文件中增加以下依赖：

   ```xml
   <dependency>
       <groupId>com.fasterxml.jackson.core</groupId>
       <artifactId>jackson-databind</artifactId>
   </dependency>
   ```

   在父工程添加的依赖，如果子工程引用不到的话，可以在子工程的`<parent>`标签中添加`<relativePath/>`解决，类似下面这样：

   ```xml
   <parent>
       <artifactId>rabbitmq-demo</artifactId>
       <groupId>com.mq.demo</groupId>
       <version>1.0-SNAPSHOT</version>
       <relativePath/>
   </parent>
   ```

2. 在publisher服务中新增一个配置类，然后在该类中修改序列化方式为JSON方式：

   ```java
   package com.mq.demo.config;
   
   import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
   import org.springframework.amqp.support.converter.MessageConverter;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   /**
    * @Author: gongsl
    * @Date: 2021-11-24 22:05
    */
   @Configuration
   public class ObjectConfig {
   
       @Bean
       public MessageConverter jsonMessageConverter(){
           return new Jackson2JsonMessageConverter();
       }
   }
   ```

3. 重新运行SpringAmqpTest类中的testObjectQueue方法，然后到RabbitMQ控制台查看消息内容：

   ![image-20211124234101172](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224421.png) 

   > **说明**：可以发现，消息已经使用JSON方式进行展示了，并且content_type也变成了`application/json`。

4. 由于我们发布的消息已经转换成json串了，所以在consumer服务中接收消息时，就还是按照字符串接收就行。比如我们在SpringRabbitListener类中增加以下内容：

   ```java
   @RabbitListener(queues = "simple.queue")
   public void listenObjectQueueMessage(String msg) {
       System.out.println("消费者接收到object消息：" + msg);
   }
   ```

5. 当consumer服务启动后，就可以接收到消息了，控制台打印内容如下：

   ![image-20211125000121112](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211125000311.png) 

   **注意**：如果在consumer服务中消费消息时，我们希望接收到的消息不是json字符串，而是转成json串前的map集合的话，那就需要再做一次转换。首先需要像publisher服务中那样在配置类中将序列化方式改为JSON方式，然后再修改SpringRabbitListener类中listenObjectQueueMessage方法的入参为`Map<String,Object>`即可。

> **说明**：截止到目前为止的代码，可以通过点击[rabbitmq-demo](https://gitee.com/gongcqq/others/attach_files/891554/download/rabbitmq-demo.zip)进行下载。


### 5.消息可靠性

我们在使用MQ进行异步通信的时候，最担心的就是出现以下四个问题：

![image-20211126102609124](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211126102730.png) 

针对以上问题，RabbitMQ也都有对应的解决方案，下文会依次讲解，这里首先说说消息的可靠性问题。

#### 5.1 消息可靠性问题

消息从生产者发送到交换机、再到队列、最后被消费者消费，其中每一步都有可能导致消息的丢失。

![image-20211126103307497](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211128212447.png) 

常见的丢失原因包括：

- 发送时丢失：
  - 生产者发送的消息未到达exchange；
  - 消息到达exchange但未到达queue。
- MQ宕机，queue将消息丢失；
- 消费者接收到消息后未消费就宕机。

针对以上问题，RabbitMQ分别给出了解决方案：

- 生产者消息确认机制；
- 消息持久化；
- 消费者消息确认机制；
- 消息失败重试机制。

下面就通过案例来演示每一个步骤，代码工程为[mq-advanced-demo](https://gitee.com/gongcqq/others/attach_files/894274/download/mq-advanced-demo.zip)。

#### 5.2 生产者消息确认

RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。

返回结果有两种方式：

- publisher-confirm，发送者确认：
  - 消息成功投递到交换机，返回ack；
  - 消息未投递到交换机，返回nack；
  - 消息发送过程中出现异常，没有收到回执。
- publisher-return，发送者回执：
  - 消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。

![image-20211129195015144](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222334.png)  

> **注意**：确认机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突，后续代码中这个唯一id我们就直接使用UUID进行生成。

详细的操作步骤如下所示：

1. 在publisher这个微服务的application.yml中添加配置：

   ```yaml
   spring:
     rabbitmq:
       publisher-confirm-type: correlated
       publisher-returns: true
       template:
         mandatory: true
   ```

   配置说明：

   - `publish-confirm-type`：开启publisher-confirm，这里支持两种类型：
     - `simple`：同步等待confirm结果，直到超时；
     - `correlated`：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback。
   - `publish-returns`：开启publish-return功能，也是基于callback机制，不过是定义ReturnCallback。
   - `template.mandatory`：定义消息路由失败时的策略。为true表示调用ReturnCallback；为false则直接丢弃消息。

2. 定义Return回调(ReturnCallback)，由于每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置，这里采用的方式是实现`ApplicationContextAware`接口。在publisher服务增加以下内容：

   ```java
   package com.mq.demo.config;
   
   import lombok.extern.slf4j.Slf4j;
   import org.springframework.amqp.rabbit.core.RabbitTemplate;
   import org.springframework.beans.BeansException;
   import org.springframework.context.ApplicationContext;
   import org.springframework.context.ApplicationContextAware;
   import org.springframework.context.annotation.Configuration;
   
   @Slf4j
   @Configuration
   public class CommonConfig implements ApplicationContextAware {
   
       @Override
       public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
           //获取RabbitTemplate
           RabbitTemplate template = applicationContext.getBean(RabbitTemplate.class);
           //设置ReturnCallback
           template.setReturnCallback((msg,replyCode,replyText,exchange,routingKey) -> {
               // 投递失败，记录日志
               log.error("消息发送失败，应答码：{}，失败原因：{}，交换机：{}，路由键：{},消息：{}",
                       replyCode, replyText, exchange, routingKey, msg.toString());
               // 如果有业务需要，也可以重发消息
           });
       }
   }
   ```

3. 定义ConfirmCallback。ConfirmCallback可以在发送消息时指定，因为每个业务处理confirm成功或失败的逻辑不一定相同。在publisher服务的SpringAmqpTest类中定义ConfirmCallback并发送消息，内容如下：

   ```java
   package com.mq.demo.spring;
   
   import lombok.extern.slf4j.Slf4j;
   import org.junit.Test;
   import org.junit.runner.RunWith;
   import org.springframework.amqp.rabbit.connection.CorrelationData;
   import org.springframework.amqp.rabbit.core.RabbitTemplate;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.test.context.junit4.SpringRunner;
   import org.springframework.util.concurrent.FailureCallback;
   import org.springframework.util.concurrent.SuccessCallback;
   import java.util.UUID;
   
   @Slf4j
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class SpringAmqpTest {
       
       @Autowired
       private RabbitTemplate rabbitTemplate;
   
       @Test
       public void testSendMessage2SimpleQueue() {
           String routingKey = "simple.test";
           //消息体
           String message = "hello, spring amqp!";
           //生成确认机制发送消息时的全局唯一ID，并将其封装到CorrelationData中
           CorrelationData data = new CorrelationData(UUID.randomUUID().toString());
           data.getFuture().addCallback(new SuccessCallback<CorrelationData.Confirm>() {
               @Override
               public void onSuccess(CorrelationData.Confirm confirm) {
                   if(confirm.isAck()){
                       //ack，消息成功投递到交换机
                       log.info("消息发送成功，消息ID：{}",data.getId());
                   }else {
                       //nack，消息投递到交换机失败
                       log.error("消息发送失败，消息ID：{}，失败原因：{}",
                               data.getId(),confirm.getReason());
                   }
               }
           }, new FailureCallback() {
               @Override
               public void onFailure(Throwable throwable) {
                   log.error("消息发送过程中出现异常，消息ID：{}，异常原因：{}",
                           data.getId(),throwable.getMessage());
               }
           });
           //发送消息
           rabbitTemplate.convertAndSend("amq.topic", routingKey, message, data);
       }
   }
   ```

   或者我们也可以使用lambda表达式的写法，testSendMessage2SimpleQueue方法内容如下所示：

   ```java
   @Test
   public void testSendMessage2SimpleQueue() {
       String routingKey = "simple.test";
       //消息体
       String message = "hello, spring amqp!";
       //生成确认机制发送消息时的全局唯一ID，并将其封装到CorrelationData中
       CorrelationData data = new CorrelationData(UUID.randomUUID().toString());
       data.getFuture().addCallback(confirm -> {
           if(confirm.isAck()){
               //ack，消息成功投递到交换机
               log.info("消息发送成功，消息ID：{}",data.getId());
           }else {
               //nack，消息投递到交换机失败
               log.error("消息发送失败，消息ID：{}，失败原因：{}",
                       data.getId(),confirm.getReason());
           }
       }, throwable -> log.error("消息发送过程中出现异常，消息ID：{}，异常原因：{}",
               data.getId(),throwable.getMessage()));
       //发送消息
       rabbitTemplate.convertAndSend("amq.topic", routingKey, message, data);
   }
   ```

4. 下面开始演示消息的发送。在此之前，手动在控制台创建一个队列，并和"amq.topic"交换机进行绑定，由于该交换机是默认就会存在的交换机，所以交换机不用手动创建：

   ![image-20211202213927524](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222348.png) 

   ![image-20211202214438400](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222356.png) 

   ![image-20211202214825470](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222406.png) 

5. 直接运行SpringAmqpTest类中的testSendMessage2SimpleQueue方法，本地可以看到消息发送成功的日志，并且在RabbitMQ控制台的队列中也可以看到多了一条消息：

   ![image-20211202215426614](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222415.png) 

   ![image-20211202215826137](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222421.png) 我们也可以演示消息投递到交换机失败的场景，比如向一个不存在的交换机中投递消息，本地就会打印如下内容：

   ![image-20211202220817750](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222427.png) 

6. 以上演示的都是`publisher-confirm`，下面再来演示一下`publisher-return`。`publisher-return`意思是消息投递到交换机了，但是没到队列。上面我们手动创建的"simple.queue"队列的routingKey是`simple.#`。也就是说从交换机过来的消息的routingKey只要是以"simple"开头的就可以到达队列。我们可以对SpringAmqpTest类中发消息的方法进行修改，比如把routingKey的值改成"test"，这样消息就到不了队列了，运行代码发送消息后，本地打印内容如下：

   ![image-20211202221905323](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202222435.png) 

#### 5.3 消息持久化

上文提到的生产者消息确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。

要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制，即：

- 交换机持久化；
- 队列持久化；
- 消息持久化。

> **说明**：RabbitMQ默认是内存存储消息，开启持久化功能可以确保缓存在RabbitMQ中的消息不丢失。如果我们开启了持久化功能，那么即便是对RabbitMQ进行重启，消息依然会在。

##### 5.3.1 交换机持久化

SpringAMQP中可以通过代码指定交换机持久化：

```java
@Bean
public DirectExchange simpleExchange(){
    // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除
    return new DirectExchange("simple.direct", true, false);
}
```

我们可以在RabbitMQ控制台看到持久化的交换机都会带上`D`的标示：

![image-20211202225821680](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202232038.png) 

##### 5.3.2 队列持久化

SpringAMQP中可以通过代码指定队列持久化：

```java
@Bean
public Queue simpleQueue(){
    // 使用QueueBuilder构建队列，调用durable就会持久化
    return QueueBuilder.durable("simple.queue").build();
}
```

我们可以在RabbitMQ控制台看到持久化的队列都会带上`D`的标示：

![image-20211202230328679](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211202232045.png) 

##### 5.3.3 消息持久化

利用SpringAMQP发送消息时，可以设置消息的属性，通过MessageDeliveryMode指定是否持久化，如下所示：

```java
@Test
public void testSendMessage2SimpleQueue() {
    String routingKey = "simple.test";
    //消息体
    String body = "hello, spring amqp!";
    Message message = MessageBuilder.withBody(body.getBytes(StandardCharsets.UTF_8))
            .setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();
    //发送消息
    rabbitTemplate.convertAndSend("amq.topic", routingKey, message);
}
```

**说明**：以上代码中使用`MessageDeliveryMode.PERSISTENT`表示持久化，`MessageDeliveryMode.NON_PERSISTENT`则表示不进行持久化。

> <font color="red">**注意**</font>：以上演示的交换机持久化、队列持久化以及消息持久化的操作都只是让我们知道有这种持久化的方式，如果我们是使用SpringAMQP进行消息的发送和消费，那么我们无需专门针对持久化进行什么特别的操作，SpringAMQP在默认情况下就会对交换机、队列以及消息进行持久化。

#### 5.4 消费者消息确认

RabbitMQ支持**消费者确认机制**，即消费者处理消息后可以向RabbitMQ发送ACK回执，RabbitMQ收到ACK回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：

- `manual`：手动ack。需要在业务代码结束后，调用API发送ack。这种方式有代码侵入，一般不推荐使用；
- `auto`：自动ack。由spring监测listener代码是否出现异常，没有异常则返回ack，抛出异常则返回nack；
- `none`：关闭ack。该模式MQ会假定消费者获取消息后会成功处理，因此消息投递后就会被立即删除。

> **说明**：以上三种模式中，`manual`模式有代码侵入，使用起来也较为麻烦，如无特殊业务要求，一般不推荐使用这种模式；`auto`模式有点类似事务机制，出现异常时返回nack，消息回滚到MQ，没有异常返回ack，它其实是基于AOP实现的；`none`模式一般也不推荐使用，该模式的消息投递是不可靠的，可能出现消息丢失的情况。

##### 5.4.1 演示none模式

修改consumer服务的application.yml文件，添加以下内容：

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: none # 关闭ack
```

修改consumer服务的SpringRabbitListener类中的方法，模拟一个消息处理异常：

```java
package com.mq.demo.listener;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class SpringRabbitListener {

    @RabbitListener(queues = "simple.queue")
    public void listenSimpleQueue(String msg) {
        log.info("消费者接收到simple.queue的消息：【{}】", msg);
        // 模拟异常
        System.out.println(1 / 0);
        log.info("消息处理完成！");
    }
}
```

然后启动consumer服务消费消息，可以发现，当消息处理抛异常时，RabbitMQ控制台的消息依然被删除了，故而就出现了消息没被处理而丢失的情况。

##### 5.4.2 演示auto模式

我们在publisher服务中通过SpringAmqpTest类的测试方法再发送一条消息到队列，以便演示auto模式。

首先将consumer服务的application.yml文件中的确认机制修改成auto：

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto # 自动ack
```

然后我们在SpringRabbitListener类的异常位置打上断点，通过debug方式启动consumer服务：

![image-20211203173843704](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224305.png) 

当我们到MQ的控制台查看消息状态时可以发现，此时消息状态为unack(未确定状态)：

![image-20211203174040181](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224312.png) 

然后我们放过断点抛出异常，因为Spring会自动返回nack，所以消息恢复至Ready状态，并且没有被RabbitMQ删除。所以消息不是直接丢失，而是被重新放回到队列中，再重新发送给消费者进行消费。但是由于消费者抛异常了，所以就会无限循环地进行消息回到队列再发送到消费者再回到队列的流程，最终会导致MQ压力剧增，如下所示：

![image-20211203175055819](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224318.png) 

这种无限循环肯定是不行的，会把MQ拖垮的，所以针对这种问题，就需要用到消费失败重试机制了。

##### 5.4.3 消费失败重试机制

前面有提到，当消费者的代码中出现异常后，消息会不断requeue(重入队)到队列，再重新发送给消费者，然后就会再次异常，再次requeue，无限循环，导致MQ的消息处理飙升，带来不必要的压力。这种是利用了MQ的重试，如果我们使用本地方式进行重试的话，就会大大降低对MQ的压力。

###### 5.4.3.1 本地重试

我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制地requeue到MQ队列。

修改consumer服务的application.yml文件，添加以下内容：

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        retry:
          enabled: true # 开启消费者失败重试
          initial-interval: 1000 # 设置初始的失败等待时长为1秒
          multiplier: 3 # 设置失败的等待时长倍数，下一次的等待时长 = 上一次的等待时长 * multiplier
          max-attempts: 5 # 最大重试次数
          max-interval: 10000 # 设置单次最大失败等待时间为10秒
          stateless: true # true为无状态，false为有状态。如果业务中包含事务，这里则使用false
```

然后启动consumer服务消费队列中的消息，观察本地控制台打印：

![image-20211203204546677](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224326.png) 

![image-20211203204744304](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224336.png) 

![image-20211203204926355](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224344.png) 

通过本地控制台日志打印以及MQ控制台结果可知：

- 我们配置的最大重试次数是5次，结果就重试了5次，符合预期，而且重试5次就直接抛异常了，并且不再进行重试；
- 我们设置的5次重试的时间间隔分别为1秒、3秒、9秒、10秒。第一次间隔为1秒是因为我们配置的初始的失败等待时长为1秒，而失败的等待时长倍数我们设置的是3倍，所以第二次时间间隔是3秒，第三次是9秒，第四次应该是27秒。但是通过截图可知第四次是10秒，这是因为我们设置的单次最大失败等待时间为10秒，所以当等待时间超过10秒的时候就直接在10秒内返回了，所以第四次时间间隔就不再是27秒了，而变成了10秒；
- 在重试5次后，SpringAMQP会抛出异常`AmqpRejectAndDontRequeueException`，从字面意思就可以看出这个异常的意思是直接reject，并且不会重入队到队列中，言外之意就是达到最大重试次数后就会直接把消息进行丢弃；
- 查看RabbitMQ控制台可以发现消息被删除了，说明达到最大重试次数后SpringAMQP返回的是ack，然后MQ就删除消息了，如果消费者没有成功消费消息，那么这个消息就算是丢失了；
- 在没有使用本地重试的时候，每次重试都会重新入队到MQ的队列中，然后再重发给消费者消费，并且每次重试都会抛异常，但是通过以上截图可知，本地重试是只有在达到最大重试次数后才会抛异常，前面几次重试都是不会抛异常的。

###### 5.4.3.2 重试失败策略

在上面的重试中，达到最大重试次数后消息就会被丢弃，这是由SpringAMQP内部机制决定的。在开启重试模式后，重试次数耗尽，如果消息依然失败，就会由MessageRecoverer接口来处理，它包含三种不同的实现：

- `RejectAndDontRequeueRecoverer`：重试耗尽后，直接reject，丢弃消息，默认就是这种方式；
- `ImmediateRequeueMessageRecoverer`：重试耗尽后，返回nack，消息重新入队；
- `RepublishMessageRecoverer`：重试耗尽后，将失败消息投递到指定的交换机。

如果我们不想在重试次数耗尽后直接丢弃消息，那么可以使用`RepublishMessageRecoverer`策略，失败后将消息投递到一个指定的专门存放异常消息的队列，后续由人工集中处理。

具体实现逻辑如下所示：

首先在consumer服务中定义处理失败消息的交换机和队列：

```java
@Bean
public DirectExchange errorMessageExchange(){
    String exchangeName = "error.direct";
    return new DirectExchange(exchangeName, true, false);
}
@Bean
public Queue errorQueue(){
    String queueName = "error.queue";
    return QueueBuilder.durable(queueName).build();
}
@Bean
public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){
    String routingKey = "error";
    return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(routingKey);
}
```

然后定义一个RepublishMessageRecoverer，关联队列和交换机：

```java
@Bean
public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){
    String exchangeName = "error.direct";
    String routingKey = "error";
    return new RepublishMessageRecoverer(rabbitTemplate, exchangeName, routingKey);
}
```

以上两部分可以写在同一个配置类中，完整的代码如下所示：

```java
package com.mq.demo.config;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.MessageRecoverer;
import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CommonConfig {

    @Bean
    public DirectExchange errorMessageExchange(){
        String exchangeName = "error.direct";
        return new DirectExchange(exchangeName, true, false);
    }
    @Bean
    public Queue errorQueue(){
        String queueName = "error.queue";
        return QueueBuilder.durable(queueName).build();
    }
    @Bean
    public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){
        String routingKey = "error";
        return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(routingKey);
    }
    @Bean
    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){
        String exchangeName = "error.direct";
        String routingKey = "error";
        return new RepublishMessageRecoverer(rabbitTemplate, exchangeName, routingKey);
    }
}
```

之后我们先重新发送一个消息到队列中，然后重启consumer服务，并观察本地控制台的日志打印：

![image-20211203223124583](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224354.png) 

然后我们再去MQ控制台看看队列情况：

![image-20211203223405234](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224404.png) 

我们也可以点击进入到"error.queue"队列中查看消息的具体内容，可以发现，不但包含了消息内容，还包含了异常的堆栈信息：

![image-20211203224010456](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211203224448.png) 

### 6.死信交换机

#### 6.1 初始死信交换机

当一个队列中的消息满足下列情况之一时，可以成为`死信(dead letter)`：

- 消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false；
- 消息是一个过期消息，超时无人消费；
- 要投递的队列消息堆积满了，最早的消息可能成为死信。

如果这个包含死信的队列配置了`dead-letter-exchange`属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为`死信交换机`(Dead Letter Exchange，简称DLX)。

一个消息被消费者拒绝了，就变成了死信。如果队列绑定了死信交换机，这个死信就会被投递给这个交换机。如果这个死信交换机也绑定了了一个死信队列，那么这个消息最终就会进入到这个专门用来存放死信的队列中，如下图所示：

![image-20211205140043177](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230151.png)  

另外，队列将死信投递给死信交换机时，必须知道两个信息：

- 死信交换机名称，通过`dead-letter-exchange`进行指定；
- 死信交换机与死信队列绑定的RoutingKey，通过`dead-letter-routing-key`进行指定。

只有知道了以上两个信息，才能确保投递的消息到达死信交换机，并且正确路由到死信队列。

> **说明**：可以发现，这里处理死信的方式和前面重试失败策略中`RepublishMessageRecoverer`这种策略差不多，都是将消息投递到一个交换机中，再发送到指定的队列。不过失败策略那里是直接由消费者将消息投递到处理异常消息的交换机中的，而这里的死信则是在消息被消费者拒绝后，由队列将消息投递到死信交换机的，并且死信交换机还有一些别的用处，下文会讲到。

我们可以在代码中，通过`@Bean`注解为一个队列指定一个死信交换机，代码示例如下所示：

```java
// 声明普通的simple.queue队列，并且为其指定死信交换机dl.direct
@Bean
public Queue simpleQueue(){
    return QueueBuilder.durable("simple.queue") // 指定队列名称，并持久化
        .deadLetterExchange("dl.direct") // 指定死信交换机
        .build();
}
// 声明死信交换机dl.direct
@Bean
public DirectExchange dlExchange(){
    return new DirectExchange("dl.direct", true, false);
}
// 声明存储死信的队列dl.queue
@Bean
public Queue dlQueue(){
    return new Queue("dl.queue", true);
}
// 将死信队列与死信交换机绑定
@Bean
public Binding dlBinding(){
    return BindingBuilder.bind(dlQueue()).to(dlExchange()).with("dl");
}
```

#### 6.2 TTL

TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，TTL超时分为两种情况：

- 消息所在的队列设置了队列中消息的存活时间；
- 消息本身设置了存活时间。

下面通过代码的方式演示一下TTL的用法：

1. 在consumer服务的SpringRabbitListener中，定义一个监听死信队列的消费者，如下所示：

   ```java
   @RabbitListener(bindings = @QueueBinding(
       value = @Queue(name = "dl.ttl.queue", durable = "true"),
       exchange = @Exchange(name = "dl.ttl.direct"),
       key = "ttl"
   ))
   public void listenDlQueue(String msg){
       log.info("接收到dl.ttl.queue的延迟消息：{}", msg);
   }
   ```

2. 然后在consumer服务中新增一个TTLConfig类，该类中创建的队列设置了TTL并指定了死信交换机：

   ```java
   package com.mq.demo.config;
   
   import org.springframework.amqp.core.*;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   /**
    * @Author: gongsl
    * @Date: 2021-12-05 20:23
    */
   @Configuration
   public class TTLConfig {
       @Bean
       public Queue ttlQueue(){
           return QueueBuilder.durable("ttl.queue") // 指定队列名称，并持久化
                   .ttl(10000) // 设置队列中消息的超时时间，10秒
                   .deadLetterExchange("dl.ttl.direct") // 指定死信交换机
                   .build();
       }
       @Bean
       public DirectExchange ttlExchange(){
           return new DirectExchange("ttl.direct",true,false);
       }
       @Bean
       public Binding ttlBinding(){
           return BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with("ttl");
       }
   }
   ```

3. 在publisher服务的SpringAmqpTest类中新增一个用法发送消息的测试方法：

   ```java
   @Test
   public void testTTLQueue() {
       // 创建消息
       String message = "hello, ttl queue!";
       // 消息ID，需要封装到CorrelationData中
       CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
       // 发送消息
       rabbitTemplate.convertAndSend("ttl.direct", "ttl", message, correlationData);
       // 记录日志
       log.info("发送消息成功");
   }
   ```

4. 先启动consumer服务监听消息，然后运行publisher服务中SpringAmqpTest类的testTTLQueue方法来发送消息。由于`ttl.queue`队列没有消费消息的消费者，并且该队列设置了队列中消息的存活时间是10秒。所以10秒后消息就会被投递到死信交换机，并发送到死信队列，然后被对应的消费者消费。我们可以从发送消息的时间以及消费死信队列中消息的时间看出队列设置的TTL确实生效了，如下所示：

   ![image-20211205204538876](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230206.png) 

   ![image-20211205204819350](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230212.png) 

5. 我们可以在发送消息的时候，给消息也设置TTL，在publisher服务的SpringAmqpTest类中增加以下测试方法：

   ```java
   @Test
   public void testTTLMsg() {
       // 创建消息
       Message message = MessageBuilder
               .withBody("hello, ttl message".getBytes(StandardCharsets.UTF_8))
               .setExpiration("5000")  // 设置消息的存活时间为5秒
               .build();
       // 消息ID，需要封装到CorrelationData中
       CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
       // 发送消息
       rabbitTemplate.convertAndSend("ttl.direct", "ttl", message, correlationData);
       log.info("发送消息成功");
   }
   ```

6. 运行publisher服务中SpringAmqpTest类的testTTLMsg方法发送消息，并观察发送消息的时间以及消费消息的时间间隔：

   ![image-20211205210008839](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230221.png) 

   ![image-20211205210127767](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230228.png) 

   > **说明**：当消息和队列都设置了TTL的时候，任何一个达到TTL的时间，消息都会成为死信，所以死信队列对应的消费者消费死信的时间取决于设置的TTL时间短的那个。

#### 6.3 延迟队列

利用TTL结合死信交换机，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为`延迟队列`(Delay Queue)模式。

延迟队列的使用场景包括：

- 延迟发送短信；
- 用户下单，如果用户在15分钟内未支付，则自动取消；
- 预约工作会议，20分钟后自动通知所有参会人员。

因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。

这个插件就是DelayExchange插件，可以直接在github上进行[下载](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/3.9.0/rabbitmq_delayed_message_exchange-3.9.0.ez)。

##### 6.3.1 安装DelayExchange插件

1. 为了方便起见，我们把之前使用docker启动的rabbitmq先删掉，然后重新启动，启动的时候使用挂载的方式将mq中插件的目录挂载到宿主机上，命令如下所示：

   ```bash
   # 先删掉之前启动的MQ
   docker rm -f mq 
   
   # 然后重新运行，并将MQ中插件的目录挂载到宿主机上
   docker run \
    -e RABBITMQ_DEFAULT_USER=admin \
    -e RABBITMQ_DEFAULT_PASS=admin \
    -v mq-plugins:/plugins \
    --name mq \
    --hostname rabbitmq \
    -p 15672:15672 \
    -p 5672:5672 \
    -d \
    rabbitmq:3.9.9-management
   ```

2. 我们上面设定的RabbitMQ的数据卷名称为`mq-plugins`，所以我们使用下面的命令查看数据卷：

   ```bash
   docker volume inspect mq-plugins
   ```

   ![image-20211205220143064](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230234.png) 

   > 然后直接将下载的插件放到宿主机的`/var/lib/docker/volumes/mq-plugins/_data`目录下即可。

3. 接下来就是进入到容器中开启插件：

   ```bash
   # 根据容器名进入容器
   docker exec -it mq bash
   
   # 执行以下命令开启插件
   rabbitmq-plugins enable rabbitmq_delayed_message_exchange
   
   # 开启插件后我们也可以查看插件列表中有没有我们的插件
   rabbitmq-plugins list
   ```

   ![image-20211205220928953](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230240.png) 

##### 6.3.2 DelayExchange的原理

DelayExchange需要将一个交换机声明为delayed类型。当我们发送消息到delayExchange时，流程如下：

- 接收消息；
- 判断消息是否具备x-delay属性；
- 如果有x-delay属性，说明是延迟消息，持久化到硬盘，读取x-delay值，作为延迟时间；
- 返回routing not found结果给消息发送者；
- x-delay时间到期后，重新投递消息到指定队列。

##### 6.3.3 DelayExchange的使用

DelayExchange使用起来和之前是一样的，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可。使用步骤如下：

1. 在consumer服务的SpringRabbitListener类中新增如下方法：

   ```java
   @RabbitListener(bindings = @QueueBinding(
           value = @Queue(name = "delay.queue", durable = "true"),
           exchange = @Exchange(name = "delay.direct",delayed = "true"),
           key = "delay"
   ))
   public void listenDelayedQueue(String msg){
       log.info("接收到delay.queue的延迟消息：{}", msg);
   }
   ```

   以上是通过`@RabbitListener`注解的方式，如果我们想要使用`@Bean`的方式的话也是可以的，代码如下：

   ```java
   @Bean
   public Queue delayedQueue(){
       return QueueBuilder.durable("delay.queue").build();
   }
   @Bean
   public DirectExchange delayedExchange(){
       return ExchangeBuilder.directExchange("delay.direct").delayed().durable(true).build();
   }
   @Bean
   public Binding delayedBinding(){
       return BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with("delay");
   }
   ```

   > **说明**：以上两种方式二者选其一即可，推荐使用`@RabbitListener`注解的方式。

2. 在publisher服务的SpringAmqpTest类中新增一个发送消息的测试方法，内容如下：

   ```java
   @Test
   public void testDelayedMsg() {
       // 创建消息
       Message message = MessageBuilder
               .withBody("hello, delayed message".getBytes(StandardCharsets.UTF_8))
               .setHeader("x-delay",10000)  // 这里一定要指定x-delay属性，设置延迟的时间，单位毫秒
               .build();
       // 消息ID，需要封装到CorrelationData中
       CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
       // 发送消息
       rabbitTemplate.convertAndSend("delay.direct", "delay", message, correlationData);
       log.info("发送消息成功");
   }
   ```

3. 重启consumer服务后，运行publisher服务的SpringAmqpTest类中的testDelayedMsg方法发送消息：

   ![image-20211205223200106](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230251.png) 

   ![image-20211205223354708](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230257.png) 

   > **说明**：通过以上截图可以发现，虽然延迟消息的效果达到了，但是发送消息的时候报错了，报错内容是我们之前演示生产者消息确认时打的日志信息，当交换机发送消息到队列失败的时候就会报上面的错。理论上交换机是不具备存储功能的，有消息过来应该立即发送给队列，但是DelayExchange的原理是，它会先帮我们把消息存储起来，在没到我们设置的延迟时间的时候，消息暂时是不会被发送到队列的。由于没有立刻路由消息到队列，所以就会报错了，报错信息就是上面的`NO_ROUTE`。但是到了延迟时间后，消息还是会被发送到队列的，所以尽管会有报错的信息，但是消息实际上还是发送成功了的。

4. 虽然上面的报错信息不影响消息的成功发送，但是延迟消息都报错也不好，我们可以通过如下方式修改代码，让延迟类信息不报错。修改publisher服务的CommonConfig类中的setApplicationContext方法，增加以下内容：

   ```java
   //针对延迟类消息的处理
   if (msg.getMessageProperties().getReceivedDelay() > 0) {
       //消息是一个延迟消息，所以忽略这个错误
       return;
   }
   ```

   ![image-20211205225905713](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211205230303.png) 

### 7.惰性队列

#### 7.1 消息堆积问题

当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。最早接收到的消息，可能就会成为死信，会被丢弃，这就是`消息堆积问题`。

解决消息堆积一般有三种思路：

1. 增加更多的消费者，提高消费速度；
2. 在消费者内开启线程池加快消息的处理速度；
3. 扩大队列的容积，提高堆积上限。

#### 7.2 惰性队列

从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的概念，也就是`惰性队列`。惰性队列的特征如下：

- 接收到消息后直接存入磁盘而非内存；
- 消费者要消费消息时才会从磁盘中读取并加载到内存；
- 支持数百万条的消息存储。

> **说明**：使用惰性队列其实就是通过扩大队列的容积，提高堆积上限的方式来解决消息堆积问题。

##### 7.2.1 命令行方式设置惰性队列

要设置一个队列为惰性队列，只需要在声明队列时，指定**x-queue-mode**属性为**lazy**即可。也可以通过命令行将一个运行中的队列修改为惰性队列，如下所示：

```bash
# 设置指定队列为惰性队列，队列名称支持正则表达式
rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"lazy"}' --apply-to queues  
```

命令解读：

- `rabbitmqctl` ：RabbitMQ的命令行工具；
- `set_policy` ：添加一个策略；
- `Lazy` ：策略名称，可以自定义；
- `"^lazy-queue$"` ：用正则表达式匹配队列的名字；
- `'{"queue-mode":"lazy"}'` ：设置队列模式为lazy模式；
- `--apply-to queues  `：策略的作用对象，这里是所有的队列。

##### 7.2.2 代码方式设置惰性队列

我们可以通过`@Bean`注解或者`@RabbitListener`注解的方式设置惰性队列，比如使用`@Bean`注解的方式：

```java
@Bean
public Queue lazyQueue(){
    return QueueBuilder.durable("lazy.queue")
            .lazy() // 开启x-queue-mode为lazy
            .build();
}
```

如果是使用`@RabbitListener`注解的方式的话，就是下面这样：

```java
@RabbitListener(bindings = @QueueBinding(
        value = @Queue(
                name = "lazy.queue",
                durable = "true",
                arguments = @Argument(name = "x-queue-mode", value = "lazy")
        ),
        exchange = @Exchange(name = "lazy.direct"),
        key = "lazy"
))
public void listenLazyQueue(String msg){
    log.info("接收到lazy.queue的惰性消息：{}", msg);
}
```

![image-20211206204100231](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002155.png) 

为了演示惰性队列和普通队列的区别，下面分别创建一个惰性队列和普通队列，然后同时分别向两个队列发送大量消息进行测试，观察队列情况：

1. 首先在consumer服务中新增一个LazyConfig类，在类中通过`@Bean`注解分别创建两个队列，内容如下：

   ```java
   package com.mq.demo.config;
   
   import org.springframework.amqp.core.Queue;
   import org.springframework.amqp.core.QueueBuilder;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   /**
    * @Author: gongsl
    * @Date: 2021-12-07 21:01
    */
   @Configuration
   public class LazyConfig {
       @Bean
       public Queue lazyQueue(){
           return QueueBuilder.durable("lazy.queue")
                   .lazy() // 开启x-queue-mode为lazy
                   .build();
       }
       @Bean
       public Queue normalQueue(){
           return QueueBuilder.durable("normal.queue").build();
       }
   }
   ```

2. 然后在publisher服务的SpringAmqpTest类中新增以下内容，便于发送消息测试：

   ```java
   @Test
   public void testLazyQueue() {
       for (int i=1; i<=100000;i++){
           // 创建消息
           Message message = MessageBuilder
                   .withBody("hello, lazy message!".getBytes(StandardCharsets.UTF_8))
                   .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)
                   .build();
           // 发送消息，这里直接往队列发，就不使用交换机了
           rabbitTemplate.convertAndSend("lazy.queue", message);
           // 记录日志
           log.info("发送消息成功");
       }
   }
   
   @Test
   public void testNormalQueue() {
       for (int i=1; i<=100000;i++){
           // 创建消息
           Message message = MessageBuilder
                   .withBody("hello, normal message!".getBytes(StandardCharsets.UTF_8))
                   .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)
                   .build();
           // 发送消息，这里直接往队列发，就不使用交换机了
           rabbitTemplate.convertAndSend("normal.queue", message);
           // 记录日志
           log.info("发送消息成功");
       }
   }
   ```

3. 之后先启动consumer服务，然后再分别运行publisher服务的SpringAmqpTest类中上面刚新增的两个发送消息的方法。最后我们再到MQ的控制台查看对应队列中的消息情况：

   ![image-20211207212140328](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002202.png) 

4. 我们分别点击队列名称进入到两个队列中查看消息的存储位置：

   ![image-20211207212450707](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002210.png) 

   ![image-20211207212627611](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002215.png)

5. 以上截图可知，惰性队列是直接将消息扇出到磁盘，消费的时候再从磁盘取。磁盘存储空间肯定比内存大很多的，所以不容易出现消息堆积的情况，但是磁盘存取消息速度肯定比内存慢的，不过也还是在能够接受的范围内的。对于普通队列，也不是说所有消息都像上面截图的那样都放在内存中的，毕竟内存的空间是有限的，所以当消息达到一定数量的时候，也是会有部分消息扇出到磁盘中的，只不过不会像惰性队列那样，直接把所有消息都扇出到磁盘。

> **说明**：惰性队列是基于磁盘存储消息的，所以消息上限高，并且没有间歇性的page-out，性能比较稳定；但是正是由于它是基于磁盘存储，所以消息时效性会降低，并且性能受限于磁盘的IO。

### 8.RabbitMQ集群

#### 8.1 集群分类

RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：

- `普通集群`：它是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。但是这种集群没有数据备份，一旦节点宕机，数据就会丢失，所以这种集群不能用于生产环境；
- `镜像集群`：它是一种主从集群，它在普通集群的基础上，添加了主从备份功能，从而提高集群的数据可用性。

镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：`仲裁队列`来代替镜像集群，底层采用Raft协议确保主从的数据一致性。

#### 8.2 普通集群

##### 8.2.1 普通集群的特征

普通集群，或者叫标准集群(classic cluster)，它具备下列特征：

- 会在集群的各个节点间共享部分数据，包括交换机、队列元信息等，但是不包含队列中的消息；
- 当访问集群某节点时，如果队列不在该节点，会通过共享的队列元信息找到对应队列的节点，并将对应节点上的数据传递到当前节点后进行返回；
- 队列所在节点宕机，队列中的消息就会丢失。

##### 8.2.2 部署普通集群

前文主要讲述了两种集群的配置方式：

- **普通模式**：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息(其它元数据信息如交换机等会同步)。例如我们有2个MQ，mq1和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。
- **镜像模式**：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。

我们先来部署普通模式集群，由于主机节点有限，就直接修改端口在一台主机上部署三个节点的mq集群：

| 主机IP        | MQ主机名 | 控制台端口      | amqp通信端口   |
| ------------- | -------- | --------------- | -------------- |
| 192.168.68.11 | mq1      | 8081 ---> 15672 | 8071 ---> 5672 |
| 192.168.68.11 | mq2      | 8082 ---> 15672 | 8072 ---> 5672 |
| 192.168.68.11 | mq3      | 8083 ---> 15672 | 8073 ---> 5672 |

集群中的节点标示默认都是：`rabbit@[hostname]`，因此以上三个节点的名称分别为：

- rabbit@mq1
- rabbit@mq2
- rabbit@mq3

###### 8.2.2.1 获取cookie

RabbitMQ底层依赖于Erlang，而Erlang虚拟机就是一个面向分布式的语言，默认就支持集群模式。集群模式中的每个RabbitMQ节点使用cookie来确定它们是否被允许相互通信。

要使两个节点能够通信，它们必须具有相同的共享秘密，称为**Erlang cookie**。cookie只是一串最多255个字符的字母数字字符。

每个集群节点必须具有**相同的cookie**，实例之间也需要它来相互通信。

我们先在之前启动的mq容器中获取一个cookie值，作为集群的cookie。具体命令如下：

```bash
# 下面的mq是容器的名称，也可以使用容器id
docker exec -it mq cat /var/lib/rabbitmq/.erlang.cookie
```

然后我这边获取到的cookie值如下：

```bash
IAEYQQGKSCSIDIUDHGMG
```

接下来使用`docker rm -f mq`命令把当前运行的MQ停止并删除，然后开始部署MQ集群。

###### 8.2.2.2 准备集群配置

首先在当前路径下新建三个目录：

```bash
mkdir mq1 mq2 mq3
```

然后在mq1目录下新建一个rabbitmq.conf文件：

```bash
cat > mq1/rabbitmq.conf <<EOF
loopback_users.guest = false
listeners.tcp.default = 5672
cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config
cluster_formation.classic_config.nodes.1 = rabbit@mq1
cluster_formation.classic_config.nodes.2 = rabbit@mq2
cluster_formation.classic_config.nodes.3 = rabbit@mq3
EOF
```

再在mq1目录下新建一个.erlang.cookie文件，并将前面获取到的cookie写入到文件中，之后修改文件权限：

```bash
# 写入cookie
cat > mq1/.erlang.cookie <<EOF
IAEYQQGKSCSIDIUDHGMG
EOF

# 修改cookie文件的权限
chmod 600 mq1/.erlang.cookie
```

以上操作完成之后，将mq1目录下新增的两个文件都拷贝到mq2和mq3目录下：

```bash
cp -a mq1/. mq2 && cp -a mq1/. mq3
```

###### 8.2.2.3 启动MQ集群

为了让三个容器能够互相连接，这里首先创建一个网络：

```bash
docker network create mq-net
```

然后使用`docker run`命令分别运行三个容器：

```bash
# 运行第一个容器
docker run -d --net mq-net \
-v ${PWD}/mq1/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \
-v ${PWD}/mq1/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=admin \
--name mq1 \
--hostname mq1 \
-p 8071:5672 \
-p 8081:15672 \
rabbitmq:3.9.9-management

# 运行第二个容器
docker run -d --net mq-net \
-v ${PWD}/mq2/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \
-v ${PWD}/mq2/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=admin \
--name mq2 \
--hostname mq2 \
-p 8072:5672 \
-p 8082:15672 \
rabbitmq:3.9.9-management

# 运行第三个容器
docker run -d --net mq-net \
-v ${PWD}/mq3/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \
-v ${PWD}/mq3/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \
-e RABBITMQ_DEFAULT_USER=admin \
-e RABBITMQ_DEFAULT_PASS=admin \
--name mq3 \
--hostname mq3 \
-p 8073:5672 \
-p 8083:15672 \
rabbitmq:3.9.9-management
```

容器都启动成功后，我们随便访问一个容器，可以发现控制台节点已经变成三个了，如下所示：

```http
http://192.168.68.11:8081/
```

![image-20211213000133891](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002228.png) 

###### 8.2.2.4 测试集群效果

我们在mq1这个节点上添加一个队列：

![image-20211213000727816](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002235.png) 

![image-20211213000810834](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002243.png) 

然后我们发现，在mq2和mq3节点的控制台上也是可以看到的：

![image-20211213001003491](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002249.png) 

![image-20211213001053933](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002255.png) 

如果我们在mq1节点控制台的simple.queue队列中添加一条消息，那么这条消息在三个mq节点上都是可以看到的。不过由于普通集群模式是没有数据备份的，所以如果我们手动让mq1宕机，那么这条消息就会丢失，并且在mq1节点上创建的队列也会处于不可用状态：

```bash
# 手动停止mq1，模拟宕机场景
docker stop mq1
```

![image-20211213001854976](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002304.png) 

![image-20211213001951647](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213002311.png) 

#### 8.3 镜像集群

在上面的案例中，一旦创建队列的主机宕机，队列就会不可用，不具备高可用能力。如果要解决这个问题，必须使用官方提供的[镜像集群](https://www.rabbitmq.com/ha.html)方案。

##### 8.3.1 镜像集群的特征

镜像集群，本质是主从模式，具备下面的特征：

- 创建队列的节点被称为该队列的`主节点`，备份到的其它节点叫做该队列的`镜像节点`；

- 交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份；
- 镜像节点仅仅起到备份数据的作用，如果从节点接收到用户请求，也会路由到主节点去完成；
- 一个队列的主节点可能是另一个队列的镜像节点；
- 所有操作都是主节点完成，然后同步给镜像节点；
- 主节点宕机后，镜像节点会替代成为新的主节点；
- 当主节点接收到消费者的ACK时，所有镜像都会删除节点中的数据。

##### 8.3.2 镜像集群的配置

镜像集群的配置有三种模式：

| 镜像模式  | 镜像参数     | 效果                                                         |
| :-------- | :----------- | :----------------------------------------------------------- |
| `exactly` | 队列的副本数 | 集群中队列副本(主服务器和镜像服务器之和)的数量。副本数如果为1意味着单个副本：即队列主节点。如果为2表示2个副本：1个队列主和1个队列镜像。换句话说就是，副本数 = 镜像数量 + 1。如果集群中的节点数少于副本数量，则该队列将镜像到所有节点。如果集群节点总数大于副本数+1，并且包含镜像的节点出现故障，则将在另一个节点上创建一个新的镜像。 |
| `all`     | 无           | 队列在群集中的所有节点之间进行镜像，并且队列将镜像到任何新加入的节点。镜像到所有节点将对所有群集节点施加额外的压力，包括网络I/O，磁盘I/O和磁盘空间使用情况。推荐使用exactly，设置副本数为(N/2 +1)。 |
| `nodes`   | 节点名称     | 指定队列创建到哪些节点，如果指定的节点全部不存在，则会出现异常。如果指定的节点在集群中存在，但是暂时不可用，会创建节点到当前客户端连接到的节点。 |

这里我们以rabbitmqctl命令作为案例来演示不同模式如何实现镜像集群，这里的前提都是已经部署了普通集群。

###### 8.3.2.1 exactly模式

随便找一个队列的主节点(比如mq1)，进入容器，然后使用如下命令创建exactly模式的镜像集群：

```bash
# 进入容器
docker exec -it mq1 bash

# 设置策略
rabbitmqctl set_policy ha-two "^two\." '{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'
```

参数说明：

- `rabbitmqctl set_policy`：固定写法；
- `ha-two`：策略名称，自定义；
- `"^two\."`：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以`two.`开头的队列名称；
- `'{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'`: 策略内容
  - `"ha-mode":"exactly"`：策略模式，此处是exactly模式，指定副本数量；
  - `"ha-params":2`：策略参数，这里是2，就是副本数量为2，1主1镜像；
  - `"ha-sync-mode":"automatic"`：同步策略，默认是manual，即新加入的镜像节点不会同步旧的消息。如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销。

策略设置成功后，我们也可以使用`rabbitmqctl list_policies`命令进行查看：

![image-20211213125925566](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151507.png) 

接下来我们可以在页面上验证一下镜像集群是否设置成功。首先在mq1节点上新增一个队列：

![image-20211213131016316](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151519.png) 

![image-20211213131504608](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151531.png) 

在以上新增的队列中的"Features"标签有一个`ha-two`，这个就是策略的名称，我们点进去可以查看详细内容，如下：

![image-20211213131856436](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151537.png) 

我们可以向队列中添加一条消息，然后手动停止mq1节点，模拟宕机场景，并观察队列变化：

![image-20211213132316840](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151545.png) 

![image-20211213132604743](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151551.png) 

![image-20211213132805133](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151556.png) 

###### 8.3.2.2 all模式

先将前面演示时停掉的mq1节点起起来，我们找一个mq节点(这里还是选择mq1节点)，进入容器后，执行以下命令：

```bash
rabbitmqctl set_policy ha-all "^all\." '{"ha-mode":"all"}'
```

- `ha-all`：策略名称，自定义；
- `"^all\."`：匹配所有以`all.`开头的队列名；
- `'{"ha-mode":"all"}'`：策略内容
  - `"ha-mode":"all"`：策略模式，此处是all模式，即所有节点都会成为镜像节点。

命令执行后，在容器中使用`rabbitmqctl list_policies`命令可以查看到我们创建的策略：

![image-20211213133612337](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151607.png) 

然后在控制台创建一个以`all.`开头的队列，可以看到如下内容：

![image-20211213134146430](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151611.png) 

###### 8.3.2.3 nodes模式

我们随便找一个mq节点(这里还是选择mq1节点)，进入容器后，执行以下命令：

```bash
rabbitmqctl set_policy ha-nodes "^nodes\." '{"ha-mode":"nodes","ha-params":["rabbit@mq1", "rabbit@mq2"]}'
```

- `rabbitmqctl set_policy`：固定写法；
- `ha-nodes`：策略名称，自定义；
- `"^nodes\."`：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以`nodes.`开头的队列名称；
- `'{"ha-mode":"nodes","ha-params":["rabbit@mq1", "rabbit@mq2"]}'`: 策略内容
  - `"ha-mode":"nodes"`：策略模式，此处是nodes模式；
  - `"ha-params":["rabbit@mq1", "rabbit@mq2"]`：策略参数，这里用于指定副本所在节点名称。

然后在控制台创建一个以`nodes.`开头的队列，可以看到如下内容：

![image-20211213135315045](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151617.png) 

#### 8.4 仲裁队列

##### 8.4.1 仲裁队列的特性

仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，它具备下列特征：

- 与镜像队列一样，都是主从模式，支持主从数据同步；
- 使用非常简单，没有复杂的配置；
- 主从同步基于Raft协议，强一致。

> **说明**：镜像集群虽然可以主从同步，但是由于不是强一致的，所以会有数据丢失的风险，仲裁队列则是专门用来解决这一问题的。

##### 8.4.2 添加仲裁队列

在任意mq节点控制台添加一个队列，队列类型选择`Quorum`类型即可：

![image-20211213135958583](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151625.png) 

![image-20211213140243844](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211213151631.png) 

可以看到，仲裁队列的`+2`字样，代表这个队列有2个镜像节点。仲裁队列默认的镜像数为5。如果我们集群有7个节点，那么镜像数肯定是5；而我们集群只有3个节点，因此镜像数量就是3。

我们也可以通过java代码的方式创建一个仲裁队列，比如在一个配置类中增加以下内容：

```java
@Bean
public Queue quorumQueue() {
    return QueueBuilder
        .durable("quorum.queue") // 持久化
        .quorum() // 仲裁队列
        .build();
}
```

由于现在是MQ集群了，所以SpringAMQP连接MQ的配置也有变化，之前的使用方式如下：

```yaml
spring:
  rabbitmq:
    host: 192.168.68.11 # rabbitMQ的ip地址
    port: 5672 # 端口
```

连接MQ集群的话，之前的`host`和`port`属性使用`addresses`属性进行替换，使用方式如下所示：

```yaml
spring:
  rabbitmq:
    addresses: 192.168.68.11:8071, 192.168.68.11:8072, 192.168.68.11:8073
```

> **说明**：截止到目前为止的代码，可以通过点击[mq-advanced-demo](https://gitee.com/gongcqq/others/attach_files/911244/download/mq-advanced-demo.zip)进行下载。

#### 8.5 k8s方式部署RabbitMQ集群

**说明**：这里安装所涉及到的yaml文件均来自github上rabbitmq官方的[diy-kubernetes-examples](https://github.com/rabbitmq/diy-kubernetes-examples/tree/master/minikube)项目。这种方式的安装属于简易版的，像存储之类的东西都没有配置，所以如果用于生产环境，可以再添加一些详细的配置。

1. 依次执行以下命令进行集群部署：

   ```bash
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/namespace.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/configmap.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/rbac.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/services.yaml
   kubectl apply -f https://gitee.com/gongcqq/others/raw/master/k8s-rabbitmq/sts.yaml
   ```

2. 然后使用如下命令查看部署情况：

   ```bash
   kubectl get svc,po -n test-rabbitmq -o wide
   ```

   ![image-20211120124327956](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125220.png) 

3. 由以上截图可知，控制台的`15672`端口映射到主机的端口是`31672`，所以浏览器随便使用一个集群中主机的地址加上这个端口号即可访问控制台，默认用户名密码都是**guest**，如下所示：

   ```http
   http://192.168.68.20:31672/
   ```

   ![image-20211120124709159](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125225.png) 

   > **说明**：控制台的`Nodes`栏也可以看到我们部署的RabbitMQ中的三个节点信息。

4. 我们也可以使用`kubectl logs rabbitmq-0 -n test-rabbitmq`命令查看Pod的日志，通过日志可以发现，部署好的Pod会自动加入到MQ集群中。

   ![image-20211120125737867](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211120125747.png)

