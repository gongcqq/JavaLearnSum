### 1.认识微服务

随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。

#### 1.1 单体架构

`单体架构`：将业务的所有功能集中在一个项目中开发，打成一个包部署。

![image-20210713202807818](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120529.png) 

单体架构的优缺点：

**优点：**

- 架构简单
- 部署成本低

**缺点：**

- 耦合度高(维护困难、升级困难)

#### 1.2 分布式架构

`分布式架构`：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。

![image-20210713203124797](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120537.png) 

分布式架构的优缺点：

**优点：**

- 降低服务耦合
- 有利于服务升级和拓展

**缺点：**

- 服务调用关系错综复杂

分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：

- 服务拆分的粒度如何界定？
- 服务之间如何调用？
- 服务的调用关系如何管理？

所以需要制定一套行之有效的标准来约束分布式架构。

#### 1.3 微服务架构

微服务的架构特征：

- `单一职责`：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责；
- `自治`：团队独立、技术独立、数据独立，独立部署和交付；
- `面向服务`：服务提供统一标准的接口，与语言和技术无关；
- `隔离性强`：服务调用做好隔离、容错、降级，避免出现级联问题。

![image-20210713203753373](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120550.png) 

微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。

因此，可以认为**微服务**是一种经过良好架构设计的**分布式架构方案**。以下是微服务较为完整的架构图：

![微服务技术架构](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225113.jpg) 

但方案该怎么落地？微服务带来的各种问题怎么解决？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案，其中在Java领域最引人注目的就是SpringCloud提供的方案了，SpringCloud其实是一套解决微服务方案的技术整合。

#### 1.4 SpringCloud

[SpringCloud](https://spring.io/projects/spring-cloud)是目前国内使用最广泛的微服务框架，它集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。

其中常见的组件包括：

![image-20210713204155887](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903120601.png) 

SpringCloud底层是依赖于SpringBoot的，并且[官网](https://spring.io/projects/spring-cloud)也提供了版本的兼容关系，如下：

| Release Train                                                | Boot Version                          |
| :----------------------------------------------------------- | :------------------------------------ |
| [2020.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes) aka Ilford | 2.4.x, 2.5.x (Starting with 2020.0.3) |
| [Hoxton](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes) | 2.2.x, 2.3.x (Starting with SR5)      |
| [Greenwich](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes) | 2.1.x                                 |
| [Finchley](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes) | 2.0.x                                 |
| [Edgware](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes) | 1.5.x                                 |
| [Dalston](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes) | 1.5.x                                 |

#### 1.5 微服务技术对比

![image-20210903122239457](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903122252.png) 

#### 1.6 总结

- 单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统
- 分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝
- 微服务：一种良好的分布式架构方案
  - 优点：拆分粒度更小、服务更独立、耦合度更低
  - 缺点：架构非常复杂，运维、监控、部署难度提高
- SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件

### 2.服务拆分和远程调用

任何分布式架构都离不开服务的拆分，微服务也是一样。

#### 2.1 服务拆分原则

微服务拆分时要遵循以下几个原则：

- 不同微服务，不要重复开发相同业务；
- 微服务数据独立，不要访问其它微服务的数据库；
- 微服务可以将自己的业务暴露为接口，供其它微服务调用。

![image-20210903162502053](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225130.png) 

#### 2.2 服务拆分示例

这里以微服务项目[cloud-parent](https://gitee.com/gongcqq/others/attach_files/821170/download/cloud-parent.zip)为例演示服务拆分，其结构如下：

![image-20210903214759456](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225153.png) 

`cloud-parent`：父工程，管理依赖。

- `order-service`：订单微服务，负责订单相关业务。
- `user-service`：用户微服务，负责用户相关业务。

要求：

- 订单微服务和用户微服务都必须有各自的数据库，相互独立；
- 订单服务和用户服务都对外暴露Restful的接口；
- 订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库。

##### 2.2.1 数据库设计

首先创建两个库，分别为**cloud_order**和**cloud_user**，然后不同库中执行以上`cloud-parent`项目中提供的不同sql脚本即可。

执行脚本后，cloud_user库中的t_user表的初始数据如下：

![image-20210903220430580](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225210.png) 

cloud_order库中的t_order表的初始数据如下：

![image-20210903220539317](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225215.png) 

> **说明**：t_order表中的user_id字段对应t_user表的id字段。

##### 2.2.2 导入微服务工程

首先将以上提供的代码导入到IDEA工程中，然后打开`Run Dashboard`面板，如下所示：

![image-20210903221334282](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225225.png) 

如果IDEA中选不到`Run Dashboard`面板(有的版本的IDEA是`Services`面板)，在项目的`.idea`目录的workspace.xml文件中添加以下内容后重启工程即可：

```xml
<option name="configurationTypes">
  <set>
    <option value="SpringBootApplicationConfigurationType" />
  </set>
</option>
```

![image-20210903222035404](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225235.png) 

生效后的`Run Dashboard`面板如下所示：

![image-20210903222418187](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225240.png) 

> **注意**：项目中用到的java的版本是jdk1.8。

#### 2.3 实现远程调用

订单模块的项目中是在启动类中使用`RestTemplate`类实现远程调用的，首先是使用如下代码将该类注入到Spring容器：

```java
@Bean
public RestTemplate restTemplate(){
    return new RestTemplate();
}
```

然后当订单模块的Service层获取订单信息的时候，使用如下方法通过远程调用将用户信息填充到Order对象中返回：

```java
@Override
public Order queryOrderById(Long orderId) {
    //1.查询订单
    Order order = orderMapper.findById(orderId);
    //2.利用RestTemplate发起http请求，查询用户
    //2.1 url路径
    String url = "http://localhost:8080/user/" + order.getUserId();
    //2.2 发送http请求，实现远程调用
    User user = restTemplate.getForObject(url, User.class);
    //3.封装user到Order中
    order.setUser(user);
    //4.返回
    return order;
}
```

在IDEA中分别启动订单模块和用户模块，然后浏览器中直接进行访问即可：

```http
http://localhost:8081/order/101
```

![image-20210903223928146](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225254.png) 

#### 2.4 提供者与消费者

在服务调用关系中，会有两个不同的角色：

`服务提供者`：一次业务中，被其它微服务调用的服务(提供接口给其它微服务)；

`服务消费者`：一次业务中，调用其它微服务的服务(调用其它微服务提供的接口)。

![image-20210903224606793](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210903225301.png) 

但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。

如果服务A调用了服务B，而服务B又调用了服务C，那么服务B的角色是什么？

- 对于A调用B的业务而言：A是服务消费者，B是服务提供者；
- 对于B调用C的业务而言：B是服务消费者，C是服务提供者。

因此，服务B既可以是服务提供者，也可以是服务消费者。

### 3.Eureka注册中心

#### 3.1 Eureka的结构

在上面远程调用的例子中，我们是把调用地址通过如下的一行代码写死在了代码中的：

```java
String url = "http://localhost:8080/user/" + order.getUserId();
```

直接写死就会有很多问题，比如，服务提供者如果是一个集群的话，那这个地址该写成什么合适？我们又如何实现远程调用呢？这时就需要用到注册中心了，我们可以先把各自的微服务注册到注册中心上，需要的时候通过注册中心完成远程调用即可，这一章节主要介绍的是Eureka注册中心的使用。

**Eureka注册中心的结构如下：**

![20210904200248](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904200602.jpg) 

**结构图解：**

1. user-service服务实例启动后，将自己的信息注册到eureka-server(Eureka服务端)，这个是`服务注册`；
2. eureka-server保存服务名称到服务实例地址列表的映射关系中，然后order-service根据服务名称，拉取实例地址列表，这个是`服务发现`或`服务拉取`；
3. 然后order-service从实例列表中利用`负载均衡`算法选中一个实例地址，并向该实例地址发起`远程调用`；
4. user-service会每隔一段时间(默认30秒)向eureka-server发起请求，报告自己的状态，称为**心跳**；当超过一定时间没有发送心跳时，eureka-server会认为对应的微服务实例出现了故障，便会将该实例从服务列表中剔除，这样一来，当order-service拉取服务时，就能将有故障的实例排除掉了。

> **说明**：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端。

#### 3.2 搭建Eureka服务端

Eureka服务端的搭建，需要创建一个独立的微服务，下面就在cloud-parent父工程下创建一个名为eureka-server的SpringBoot工程，目录结构如下所示：

![image-20210904204235259](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221633.png) 

然后我们需要在eureka-server工程对应的pom文件中引入以下依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```

之后我们需要在启动类中添加`@EnableEurekaServer`注解：

```java
package com.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@EnableEurekaServer
@SpringBootApplication
public class EurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
```

最后就是在application.yml文件中添加对应的配置，比如下面这样：

```yaml
server:
  port: 10086 # 服务端口
spring:
  application:
    name: eurekaserver # eureka的服务名称，自定义，不重复即可
eureka:
  client:
    service-url:  # eureka的地址信息
      defaultZone: http://localhost:10086/eureka
```

> **说明**：eureka自己也是一个微服务，所以eureka在启动的时候，会将自己也注册到eureka上，所以上面也定义了它自己的服务名称。

接下来就可以在eureka-server的启动类中启动eureka的服务端了，启动成功后直接在浏览器访问如下地址即可：

```http
http://localhost:10086/
```

![image-20210904210416023](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221642.png) 

#### 3.3 服务注册

接下来将我们的user-service服务和order-service服务都注册到Eureka上。

首先在各自工程的pom文件中都引入如下依赖：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

然后在user-service工程的application.yml文件中添加如下内容：

```yaml
spring:
  application:
    name: userservice # user-service服务的服务名称
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```

而在order-service工程的application.yml文件中添加以下内容：

```yaml
spring:
  application:
    name: orderservice # order-service服务的服务名称
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:10086/eureka
```

然后就可以启动user-service服务以及order-service服务了，服务都启动成功后，我们再到eureka的服务端查看的时候就可以发现，已注册的服务名称中，除了eurekaserver(eureka自身服务的服务名)外，还包含了userservice和orderservice，说明我们自己的服务都已经成功注册到eureka上了。

![image-20210904214759080](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221649.png) 

我们也可以给自己的服务启多个实例，下面就以user-service服务为例，演示一下多实例的效果。本地同一个服务直接启动多个实例的话会端口冲突，所以我们需要变更一下端口，比如`-Dserver.port=8082`这样，步骤如下：

![image-20210904220144332](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221701.png) 

![image-20210904220643931](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221707.png) 

![image-20210904220851962](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221720.png) 

![image-20210904221046962](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221728.png) 

![image-20210904221431546](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904221735.png) 

#### 3.4 服务拉取和负载均衡

在前面的步骤中，已经把user-service服务和order-service服务都注册到eureka注册中心了，接下来就从eureka注册中心拉取user-service服务的实例列表并实现负载均衡。

首先在order-service的OrderApplication类中，给RestTemplate这个Bean添加一个`@LoadBalanced`注解：

```java
package com.order;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@MapperScan("com.order.mapper")
@SpringBootApplication
public class OrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

然后修改`com.order.service.impl.OrderServiceImpl#queryOrderById`方法中调用user-service服务的地址，把之前的地址和端口的部分改成user-service服务注册到eureka上的服务名，即`userservice`，如下所示：

```java
package com.order.service.impl;

import com.order.mapper.OrderMapper;
import com.order.pojo.Order;
import com.order.pojo.User;
import com.order.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

/**
 * @Author: gongsl
 * @Date: 2021-09-02 23:35
 */
@Service
@Transactional
public class OrderServiceImpl implements OrderService {

    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public Order queryOrderById(Long orderId) {
        Order order = orderMapper.findById(orderId);
        //String url = "http://localhost:8080/user/" + order.getUserId();
        String url = "http://userservice/user/" + order.getUserId();
        User user = restTemplate.getForObject(url, User.class);
        order.setUser(user);
        return order;
    }
}
```

完成以上修改后，重启order-service服务，然后在浏览器访问以下地址：

```http
http://localhost:8080/order/102
```

![image-20210904223942005](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225750.png) 

通过以上结果可知，已经通过eureka注册中心获取到了用户信息，我们可以访问多次，来测试负载均衡的效果，我访问了六次后，以下是控制台日志打印的结果：

![image-20210904224427752](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225757.png) 

![image-20210904224815466](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225806.png) 

![image-20210904225013553](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210904225816.png) 

> **说明**：启动两个user-service服务并且都注册到eureka上后，通过以上截图可知，当我们通过远程调用的方式去访问user-service服务的时候，每个user-service服务都有被访问到，说明确实实现了负载均衡。上面在进行访问测试的时候只访问了六次，我们也可以多访问几次进行测试，可以发现，默认使用的负载均衡策略是轮询策略。

### 4.Ribbon负载均衡

在上面3.4章节中，我们只是使用了一个`@LoadBalanced`注解，就实现了负载均衡的效果，这里面的原理是什么呢？我们如何改变负载均衡的策略呢？这一章节就是来回答这些问题的。

#### 4.1 负载均衡原理

SpringCloud的底层其实是利用了一个名为**Ribbon**的组件，来实现负载均衡功能的。

前面我们明明在代码中将调用用户模块的地址写成了类似`http://userservice/user/1`这种形式(其中`userservice`是user-service服务注册到eureka上的服务名称)，可是为什么还能轮询调到对应的user-service服务呢？下图就是负载均衡的原理图：

![image-20210713224517686](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135316.png) 

#### 4.2 源码分析

我们并没有通过具体的IP和端口，而是通过服务名就可以找到对应的user-service服务，主要依靠的是SpringCloud源码中的`org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor`类。

我们在代码中是使用如下`@LoadBalanced`注解的方式实现负载均衡的：

```java
@Bean
@LoadBalanced
public RestTemplate restTemplate(){
    return new RestTemplate();
}
```

当我们进行请求访问的时候，`LoadBalancerInterceptor`类就会对RestTemplate的请求进行拦截，然后从Eureka上根据服务名称获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务名称。

现在我们在浏览器访问`http://localhost:8080/order/102`，然后通过打断点的方式进行源码跟踪：

##### 4.2.1 LoadBalancerInterceptor

首先在`LoadBalancerInterceptor`类的`intercept`方法上打断点，然后浏览器开始访问：

![image-20210905113104180](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135323.png) 

可以看到这里的intercept方法，已经拦截了用户的HttpRequest请求，并做了几件事：

- `request.getURI()`：获取请求的uri；
- `originalUri.getHost()`：获取url路径中的服务名称，比如userservice；
- `this.loadBalancer.execute()`：处理服务名称和用户请求。

这里的`this.loadBalancer`是`LoadBalancerClient`类型，我们继续跟入到`execute()`方法内部。

##### 4.2.2 RibbonLoadBalancerClient

接下来会进入到`org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient`类中，该类是上面提到的`LoadBalancerClient`接口的实现类。

![image-20210905113828250](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135329.png) 

![image-20210905120003916](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135333.png) 

通过以上截图可知，这次访问获取到的是端口为8081的user-service服务，我们放行后再次访问，发现这次访问到的服务是端口为8082的了，说明确实实现了负载均衡。

![image-20210905120418054](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135338.png) 

##### 4.2.3 IRule

在上面截图的RibbonLoadBalancerClient类的execute方法中，可以发现，是使用如下两行代码来做负载均衡的：

```java
ILoadBalancer loadBalancer = getLoadBalancer(serviceId);
Server server = getServer(loadBalancer, hint);
```

那么我们就跟到`getServer()`方法中，看看到底使用的是哪种负载均衡策略：

![image-20210905121634843](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135345.png) 

![image-20210905121925079](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135352.png) 

然后我们会进入到`com.netflix.loadbalancer.BaseLoadBalancer`类的`chooseServer()`方法中，如下所示：

![image-20210905122603652](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135358.png) 

我们可以看下上图中成员变量rule的值，由下图可知，rule其实是`IRule`类型，默认值是`RoundRobinRule`对象。

![image-20210905123433641](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135405.png) 

如果我们打断点的话，可以发现，上面rule的值最终其实是`ZoneAvoidanceRule`对象，它和`RoundRobinRule`一样都是采用的轮询策略，具体它们有什么区别，下文会进行对比介绍。

##### 4.2.5 总结

SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结的话，就是下面这样：

![image-20210713224724673](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905135435.png) 

#### 4.3 负载均衡策略

##### 4.3.1 负载均衡策略类型

负载均衡的规则都定义在了IRule接口中，而IRule有很多不同的实现类：

![image-20210905162919415](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905164155.png) 

不同策略类型的含义如下：

![image-20210905164005682](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905164200.png) 

> **说明**：这里默认的实现是`ZoneAvoidanceRule`，它是一种轮询方案。

##### 4.3.2 自定义使用的策略

通过定义IRule的实现可以修改负载均衡的规则，从而改变我们所使用的负载均衡的策略，主要有以下两种方式：

1. **代码的方式。**我们可以在order-service工程的OrderApplication类(或配置类)中，定义一个新的IRule：

   ```java
   @Bean
   public IRule randomRule(){
       //将负载均衡策略从默认的轮询改为随机
       return new RandomRule();
   }
   ```

2. **配置文件的方式。**我们可以在order-service工程的application.yml中针对指定服务配置指定负载均衡策略：

```yaml
userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 
```

> **注意**：我们一般使用默认的负载均衡策略即可，确需修改的，上述两种方式是有根本区别的。第一种通过代码的方式是针对全局生效的，如果order-service服务需要调用多个不同微服务的话，第一种方式就会将调用所有微服务的负载均衡策略都改为随机策略；第二种方式则是指定服务设置策略，也就是说，如果调用多个不同的服务的话，按照第二种方式进行配置，除了调用user-service服务会使用随机策略外，调用其余服务都还是使用默认的轮询策略。

#### 4.4 饥饿加载

Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，所以第一次请求访问时间会较长。而饥饿加载则会在项目启动时就创建，这样可以降低第一次访问的耗时。如果有需要，我们可以通过以下方式开启饥饿加载：

```yaml
# 在order-service工程的application.yml中加入以下内容
ribbon:
  eager-load:
    enabled: true # 开启饥饿加载
    clients:  
      - userservice # 指定对userservice这个服务饥饿加载
```

> **说明**：截止到目前为止的代码可以点击[cloud-parent](https://gitee.com/gongcqq/others/attach_files/821855/download/cloud-parent.zip)进行下载。

### 5.Nacos注册中心

[Nacos](https://nacos.io/zh-cn/)是阿里巴巴的产品，它是[SpringCloudAlibaba](https://spring.io/projects/spring-cloud-alibaba)中的一个组件，相比于[Eureka](https://github.com/Netflix/eureka)而言功能更加丰富，在国内受欢迎程度更高。

#### 5.1 Nacos简介

Nacos致力于帮助我们发现、配置和管理微服务。它提供了一组简单易用的特性集，帮助我们快速实现动态服务发现、服务配置、服务元数据及流量管理。

Nacos也帮助我们更敏捷和容易地构建、交付和管理微服务平台，它是构建以"服务"为中心的现代应用架构(例如微服务范式、云原生范式)的服务基础设施。

Nacos的关键特性主要包括以下几点:

- 服务发现和服务健康监测；
- 动态配置服务；
- 动态DNS服务；
- 服务及其元数据管理。

#### 5.2 Nacos的安装

为了更贴近真实场景，这里介绍的是Nacos在linux下的安装使用。

1. 下载安装包并解压：

   ```shell
   # 下载安装包(2.0以上版本可能还存在一些bug，所以暂时使用1.4.1版本)
   wget https://github.com/alibaba/nacos/releases/download/1.4.1/nacos-server-1.4.1.tar.gz
   
   # 解压安装包
   tar -zxvf nacos-server-1.4.1.tar.gz
   ```

   解压后目录结构如下：

   ```shell
   [root@master ~]# tree nacos
   nacos
   ├── bin
   │   ├── shutdown.cmd
   │   ├── shutdown.sh
   │   ├── startup.cmd
   │   └── startup.sh
   ├── conf
   │   ├── 1.4.0-ipv6_support-update.sql
   │   ├── application.properties
   │   ├── application.properties.example
   │   ├── cluster.conf.example
   │   ├── nacos-logback.xml
   │   ├── nacos-mysql.sql
   │   └── schema.sql
   ├── LICENSE
   ├── NOTICE
   └── target
       └── nacos-server.jar
   ```

2. 启动nacos：

   ```shell
   # standalone代表着单机模式运行，非集群模式
   cd nacos/bin/ && sh startup.sh -m standalone
   ```

   ![image-20210905201114733](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224343.png) 

   > **说明**：启动nacos需要依赖java环境，并且版本要求是jdk1.8及其以上。

3. 访问nacos控制台：

   ```shell
   # nacos默认端口是8848，所以浏览器输入以下地址(ip要换成自己的主机ip)进行访问即可
   http://192.168.68.11:8848/nacos
   ```

   进入到界面中后，输入用户名密码进行登录即可，默认用户名密码都是`nacos`。

   ![image-20210905201725368](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224354.png) 

4. 关闭nacos服务：

   ```shell
   # 如果我们想关闭nacos的话，直接执行以下命令即可
   sh shutdown.sh
   ```

> **说明**：如果想了解更多关于nacos的安装以及详细的使用说明，可以参考[nacos官网](https://nacos.io/zh-cn/docs/quick-start.html)。

#### 5.3 服务注册到Nacos上

1. 在cloud-parent父工程的pom文件中的`<dependencyManagement>`标签内引入SpringCloudAlibaba的依赖：

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-alibaba-dependencies</artifactId>
       <version>2.2.6.RELEASE</version>
       <type>pom</type>
       <scope>import</scope>
   </dependency>
   ```

2. 然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

   > **说明**：由于我们已经用不到eureka了，所以我们可以注释掉eureka的依赖。

3. 在user-service和order-service的application.yml中添加nacos地址信息：

   ```yaml
   spring:
     cloud:
       nacos:
         server-addr: 192.168.68.11:8848 # nacos服务的地址和端口
   ```

4. 启动user-service服务和order-service服务，然后在nacos控制台的`服务管理`下的`服务列表`中就可以看到我们注册到nacos上的服务信息了： 

   ![image-20210905211727576](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224406.png)   

   ![image-20210905210421700](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224413.png) 

   > **说明**：这时我们可以在浏览器输入类似`http://localhost:8080/order/101`这样的地址进行远程调用，看看服务都注册到nacos上后，order-service是否还能调到user-service，我这边测试是可以的。

#### 5.4 服务分级存储模型

一个**服务**可以有多个**实例**，例如我们的user-service，可以有：

- 127.0.0.1:8081
- 127.0.0.1:8082
- 127.0.0.1:8083

假如这些实例分布于全国各地的不同机房，例如：

- 127.0.0.1:8081，在上海机房
- 127.0.0.1:8082，在上海机房
- 127.0.0.1:8083，在杭州机房

Nacos会将同一机房内的实例，划分为一个**集群**。

也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224421.png" alt="image-20210713232522531" style="zoom: 50%;" /> 

微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：

<img src="https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224430.png" alt="image-20210713232658928" style="zoom: 60%;" /> 

> **说明**：杭州机房内的order-service应该优先访问同机房的user-service。

##### 5.4.1 给微服务配置集群

修改user-service的application.yml文件，添加集群配置：

```yaml
spring:
  cloud:
    nacos:
      server-addr: 192.168.68.11:8848
      discovery:
        cluster-name: HZ # 集群名称，自定义，不重复即可
```

重启两个user-service实例后，我们可以在nacos控制台看到下面的结果：

![image-20210905223846857](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224438.png)  

我们也可以配置多集群，可以再复制一个user-service启动配置，添加属性：

```shell
-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH
```

![image-20210905223533361](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224443.png) 

![image-20210905224157724](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224450.png) 

启动UserApplication3后再次查看nacos控制台：

![image-20210905223942762](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905224458.png) 

##### 5.4.2 同集群优先的负载均衡

前面在讲Ribbon的负载均衡策略的时候，并没有根据同集群优先来实现负载均衡的策略。

因此Nacos中提供了一个`com.alibaba.cloud.nacos.ribbon.NacosRule`的实现，可以优先从同集群中挑选实例，下面就进行相关配置和演示。

1. 首先修改order-service的application.yml文件，添加集群配置：

   ```yaml
   spring:
     cloud:
       nacos:
         server-addr: 192.168.68.11:8848
         discovery:
           cluster-name: HZ # 这里将order-service添加到HZ集群
   ```

2. 再次修改order-service的application.yml文件，改变负载均衡的规则：

   ```yaml
   userservice:
     ribbon:
       NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 
   ```

3. 重启order-service服务进行访问测试：

   ![20210905230543](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905234326.gif) 

   由于我们将order-service添加到了HZ集群，并使用`NacosRule`作为负载均衡策略。所以正常情况下，当我们在浏览器访问order-service服务时，只会远程调用到同处于HZ集群的user-service服务，以上[动图](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905234326.gif)也确实印证了这一点。在获取到同集群的user-service服务列表后，会再通过随机负载均衡策略挑选一个服务进行远程调用。

   如果我们停掉同是HZ集群下的所有user-service服务，就会调用到SH集群下的user-service服务了，具体演示过程如以下[动图](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905235713.gif)：

   ![20210905235623](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210905235713.gif) 

#### 5.5 Nacos的权重配置

服务器设备的性能是有差异的，不排除会出现部分实例所在机器性能较好，另一些较差的情况。有时我们会希望性能好的机器承担更多的用户请求，但是如果我们使用同集群优先的负载均衡策略，则默认情况下`NacosRule`是同集群内随机挑选服务器，这样就不会考虑到机器性能的问题。

因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高，我们可以的将性能较好的机器的权重配置高一些，以便更多地承担用户请求。

我们可以直接在nacos的控制台上进行实例的权重修改，权重的范围是`0~1`，如果将实例的权重设置为`0`，就相当于将该实例下线，则该实例将永远不会再承担任何用户请求。

下面进行修改权重的操作演示：

![image-20211021210151843](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211021211731.png) 

![image-20211021210913378](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211021211738.png) 

![image-20211021211054987](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211021211746.png) 

上述设置完成之后，我们可以在浏览器访问`http://localhost:8080/order/101`进行测试，可以明显发现，进入到权重值配置为`0.2`的实例的流量明显少于另一个权重值为`1`的实例，说明权重的配置是生效的。

#### 5.6 Nacos环境隔离

Nacos提供了namespace来实现环境隔离功能。

- nacos中可以有多个namespace；
- namespace下可以有group、service等；
- 不同namespace之间相互隔离，不同namespace的服务互相是不可见的。

![image-20211023160642391](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023160659.png) 

##### 5.6.1 创建namespace

默认情况下，所有service、data、group都在同一个namespace下，名为`public`：

![image-20211023161010870](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023162152.png) 

我们可以点击页面新增按钮，添加一个namespace：

![image-20211023161853795](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023162209.png) 

![image-20211023162049377](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023162216.png) 

![image-20211023162129556](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023162232.png) 

##### 5.6.2 给微服务配置namespace

给微服务配置namespace只能通过修改配置来实现。

例如，修改order-service的application.yml文件(增加`namespace`属性)：

```yaml
spring:
  cloud:
    nacos:
      server-addr: 192.168.68.11:8848
      discovery:
        cluster-name: HZ
        namespace: 21fa5899-e0e5-4263-915e-a4ec7959c497 # 命名空间，填页面上的命名空间ID
```

启动order-service服务以及user-service服务，访问Nacos控制台，会看到下面的结果：

![image-20211023164407539](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023171657.png) 

![image-20211023164459207](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023171702.png) 

![image-20211023164539651](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023171706.png) 

可以发现，order-service服务已经被归类到`dev`命名空间下了，而user-service服务还是在默认的`public`命名空间下，由于不同命名空间下的服务是不可见的，所以即便在`public`命名空间下有三个user-service服务，当我们在浏览器通过`http://localhost:8080/order/101`进行访问测试的时候，还是会因为order-service找不到user-service服务而报错，比如下面这样：

![image-20211023170616230](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023171712.png) 

![image-20211023170632944](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023171719.png) 

> **说明**：如果我们修改user-service服务的配置文件，将它也放到`dev`命名空间下的话，order-service服务就能访问到它了。

#### 5.7 Nacos的实例类型

Nacos的服务实例主要分为两种类型：

- `临时实例`：这种实例如果宕机超过一定时间，会被从服务列表中剔除，这个是默认的实例类型；
- `非临时实例`：这种实例如果宕机，不会被从服务列表剔除，也可以叫永久实例。

我们可以在实例详情中查看一个实例是否为临时实例，如下所示：

![image-20211023213118649](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023235224.png) 

我们也可以通过修改服务配置的方式将服务设置为非临时实例，比如要将order-service服务修改为非临时实例，可以修改该服务的application.yml配置，如下所示：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        ephemeral: false # 设置为非临时实例
```

![image-20211023222144747](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023235231.png) 

#### 5.8 Nacos与Eureka的区别

Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：

![image-20211023223400549](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211023235236.png) 

Nacos与eureka的共同点：

- 都支持服务注册和服务拉取；
- 都支持服务提供者心跳方式做健康检测。

Nacos与Eureka的区别：

- Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式；
- 临时实例心跳不正常会被剔除，非临时实例则不会被剔除；
- Nacos支持服务列表变更的消息推送模式，服务列表更新更及时；
- Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式。

### 6.Nacos配置管理

Nacos除了可以做注册中心，同样可以用作配置管理。

#### 6.1 统一配置管理

当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会很麻烦，而且很容易出错。我们需要有一种统一的配置管理方案，可以集中管理所有实例的配置。

![image-20211024220612632](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211024220705.png) 

Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。

##### 6.1.1 在nacos中添加配置文件

![image-20211024221117079](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211024223529.png) 

![image-20211024222035124](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211024223534.png) 

页面上配置的内容如下：

```yaml
pattern:
  dateformat: yyyy-MM-dd HH:mm:ss
```

> **注意**：并不是所有配置都应放在nacos上，像项目中可能会变动的配置以及需要热更新的配置才有放到nacos上进行管理的必要，一些像数据库的连接信息等基本不会变更的配置还是保存在微服务本地比较好。

##### 6.1.2 微服务拉取nacos上的配置

微服务需要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目的启动。但如果尚未读取本地的application.yml文件，我们又无法获取nacos的地址。所以这时候就需要用到`bootstrap.yml`文件了，这个文件是Spring引入的一种新的配置文件，其优先级高于application.yml。也就是说，项目在启动的时候，会优先加载该文件，所以我们只需将nacos的一些相关配置放到`bootstrap.yml`文件中即可。

![image-20211024223518936](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211024223545.png) 

1. 引入nacos-config依赖

   这里以user-service服务为例，首先在user-service服务中引入nacos-config的客户端依赖：

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   ```

2. 在user-service项目的`resources`目录下添加一个bootstrap.yaml文件，内容如下：

   ```yaml
   spring:
     application:
       name: userservice # 服务名称，这里添加后，之前在application.yml中添加的就可以注释掉了
     profiles:
       active: dev # 开发环境，这里是dev
     cloud:
       nacos:
         server-addr: 192.168.68.11:8848 # 服务地址，记得注释掉在application.yml中重复添加的地址
         config:
           file-extension: yaml #对应nacos上配置文件的后缀名
   ```

   > **说明**：项目启动后，会根据以上服务名、环境以及后缀名去nacos上读取配置，在本例中，到nacos上读取到的配置名即为`userservice-dev.yaml`。

3. 通过代码方式验证是否成功读取到nacos上的配置：

   在user-service项目的com.user.controller.UserController类中添加如下业务逻辑：

   ```java
   @Value("${pattern.dateformat}")
   private String dateformat;
   
   @GetMapping("/now")
   public String now(){
       //根据指定格式对当前时间进行格式化处理
       log.info("日期格式：{}",dateformat);
       return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));
   }
   ```

   ![image-20211024225108159](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211024225310.png) 

   启动项目后，浏览器访问`http://localhost:8081/user/now`进行验证： 

   ![image-20211024225818134](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211024225824.png) 

   ![image-20211024230120944](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20211024230127.png) 

   > **说明**：通过以上浏览器访问到的结果可知，我们已经读取到naocs上的配置了，并将当前时间通过nacos上指定的配置进行了格式化展示。

#### 6.2 配置的热更新





























