### 1.在CentOS上安装docker

如果之前安装过旧版本的docker，记得要先卸载，命令如下：

```bash
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```

#### 1.1 设置yum源

安装`yum-utils`软件包(提供`yum-config-manager`程序)并设置yum源为阿里云以便方便下载Docker Engine：

```bash
#安装yum-utils
sudo yum install -y yum-utils

#设置yum源为阿里云
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

#### 1.2 Docker的安装

安装最新版的Docker Engine和容器：

```bash
sudo yum install docker-ce docker-ce-cli containerd.io
```

安装时如果提示接受GPG密钥，请验证指纹是否匹配`060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`，如果匹配，继续安装即可。这个是用于检测安装包是否被篡改的，没有被篡改的话就说明我们安装的是安全的。

![image-20210215122150780](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210215122707.png) 

#### 1.3 Docker的启动与停止

```bash
#启动docker
sudo systemctl start docker

#停止docker
sudo systemctl stop docker

#重启docker
sudo systemctl restart docker

#设置开机启动
sudo systemctl enable docker

#查看docker状态
sudo systemctl status docker

#查看docker内容器的运行状态
sudo docker stats

#查看docker概要信息
sudo docker info

#查看docker帮助文档
sudo docker --help
```

#### 1.4 查看docker版本信息

```bash
[root@centos ~]# docker -v
Docker version 20.10.3, build 48d30b5
[root@centos ~]# docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:32:37 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
[root@centos ~]# 
```

#### 1.5 验证docker是否正确安装

```bash
[root@centos ~]# sudo systemctl start docker
[root@centos ~]# sudo docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

[root@centos ~]# 
```

**通过运行hello-world映像，验证Docker引擎是否正确安装。出现`Hello from Docker!`表示已经正确安装。**

#### 1.6 Docker的卸载

- 卸载Docker Engine、CLI和Containerd包：

```bash
sudo yum remove docker-ce docker-ce-cli containerd.io
```

- 删除镜像、容器、配置文件等内容：

```bash
sudo rm -rf /var/lib/docker
```

### 2.配置镜像加速

Docker从Docker Hub拉取镜像时，由于是从国外获取，所以速度较慢，我们可以通过配置国内镜像源的方式来提高拉取速度，这里主要介绍中国科学技术大学(USTC)和网易的开源镜像源。

- 编辑`daemon.json`文件：

```bash
vim /etc/docker/daemon.json
```

- 在`daemon.json`文件中输入以下内容并保存：

```json
{
  "registry-mirrors":["http://hub-mirror.c.163.com","https://docker.mirrors.ustc.edu.cn"]
}
```

- 重新加载配置文件并重启docker服务：

```bash
#重新加载配置文件
sudo systemctl daemon-reload

#重新启动docker
sudo systemctl restart docker
```

### 3.镜像相关命令

#### 3.1 查看镜像(docker images)

**用法：**

```bash
docker images [OPTIONS] [REPOSITORY[:TAG]]
```

`OPTIONS`就是下面表格中的内容，`REPOSITORY`是镜像的名称，`TAG`是镜像的标签。

**Options**

| 名称            | 默认值 | 描述                           |
| :-------------- | :----- | :--------------------------- |
| `--all , -a`    |        | 列出本地所有的镜像 |
| `--digests`     |        | 显示镜像的摘要信息     |
| `--filter , -f` |        | 根据提供的条件过滤输出 |
| `--format`      |        | 对镜像进行格式化展示 |
| `--no-trunc`    |        | 不截断输出(指的是会展示详细信息) |
| `--quiet , -q`  |        | 只显示镜像ID |

以下为了查看方便，所以我先使用`docker pull`命令拉取了几个镜像下来。

##### 3.1.1 查看所有镜像

使用`docker images`命令可以查看所有镜像，如下所示：

```bash
[root@centos ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
redis         5         e35748fd6a72   4 weeks ago     98.4MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
```

- `REPOSITORY`：镜像在仓库中的名称。
- `TAG`：镜像标签。
- `IMAGE ID`：镜像ID。
- `CREATED`：这个是镜像的创建日期，不是获取镜像的日期。
- `SIZE`：镜像大小。

这些镜像都存储在docker宿主机的`/var/lib/docker`目录下。

##### 3.1.2 查看指定名称的镜像

假如想要查看名称为redis的镜像，可以使用`docker images redis`命令，如下所示：

```bash
[root@centos ~]# docker images redis
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

根据名称查镜像，支持使用*号进行模糊匹配，如下所示：

```bash
[root@centos ~]# docker images red*
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

##### 3.1.3 查看指定名称及标签的镜像

比如使用`docker images redis:5`命令，就表示查出名称是**redis**，标签名是**5**的镜像，如下所示：

```bash
[root@centos ~]# docker images redis:5
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        5         e35748fd6a72   4 weeks ago   98.4MB
```

我们也可以只根据标签查镜像，比如想要查标签名是**latest**的所有镜像，可以使用`docker images *:latest`命令，查询结果如下所示：

```bash
[root@centos ~]# docker images *:latest
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
```

##### 3.1.4 查看标签为空的镜像

可以使用`docker images -f "dangling=true"`命令列出**TAG**那一列值为空的镜像，如果dangling为false的话，就是列出**TAG**那一列值不为空的镜像。效果展示如下：

```bash
[root@centos ~]# docker images -f "dangling=true"
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
<none>              <none>              450e15c7459f        10 hours ago        177MB
<none>              <none>              96ae66cb0553        16 hours ago        283MB
```

##### 3.1.5 只展示镜像ID

这里使用的是`docker images -q`命令，假设我们只想展示redis镜像的镜像id，效果如下：

```bash
[root@centos ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
tomcat        latest    bf4709e77b18   5 days ago      667MB
redis         latest    eb0ab2d55fdf   5 days ago      104MB
busybox       latest    b97242f89c8a   4 weeks ago     1.23MB
redis         5         e35748fd6a72   4 weeks ago     98.4MB
hello-world   latest    bf756fb1ae65   13 months ago   13.3kB
[root@centos ~]# docker images redis
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
redis        latest    eb0ab2d55fdf   5 days ago    104MB
redis        5         e35748fd6a72   4 weeks ago   98.4MB
[root@centos ~]# docker images -q redis
eb0ab2d55fdf
e35748fd6a72
```

##### 3.1.6 自定义镜像的展示效果

这里需要用到`docker images --format`命令，该命令后跟的是自定义的输出模板，可以有如下占位符：

| 占位符          | 描述                             |
| --------------- | -------------------------------- |
| `.ID`           | 镜像ID                           |
| `.Repository`   | 镜像名称                         |
| `.Tag`          | 镜像标签                         |
| `.Digest`       | 镜像摘要                         |
| `.CreatedSince` | 镜像被创建至今已经过去了多长时间 |
| `.CreatedAt`    | 镜像被创建的具体时间             |
| `.Size`         | 镜像大小                         |

- 带表头展示镜像ID和名称：

```bash
[root@centos ~]# docker images --format "table {{.ID}}\t{{.Repository}}"
IMAGE ID       REPOSITORY
bf4709e77b18   tomcat
eb0ab2d55fdf   redis
b97242f89c8a   busybox
e35748fd6a72   redis
bf756fb1ae65   hello-world
```

- 不带表头展示镜像ID和名称：

```bash
[root@centos ~]# docker images --format "{{.ID}}\t{{.Repository}}"
bf4709e77b18    tomcat
eb0ab2d55fdf    redis
b97242f89c8a    busybox
e35748fd6a72    redis
bf756fb1ae65    hello-world
```

- 不带表头展示镜像名称、镜像标签和镜像大小：

```bash
[root@centos ~]# docker images --format "{{.Repository}}--->{{.Tag}}--->{{.Size}}"
tomcat--->latest--->667MB
redis--->latest--->104MB
busybox--->latest--->1.23MB
redis--->5--->98.4MB
hello-world--->latest--->13.3kB
```

- 不带表头展示镜像名称和时间：

```bash
[root@centos ~]# docker images --format "{{.Repository}}\t{{.CreatedAt}}\t{{.CreatedSince}}"
tomcat  2021-02-10 16:30:33 +0800 CST   5 days ago
redis   2021-02-10 01:03:48 +0800 CST   5 days ago
busybox 2021-01-13 17:25:26 +0800 CST   4 weeks ago
redis   2021-01-13 03:00:16 +0800 CST   4 weeks ago
hello-world     2020-01-03 09:21:37 +0800 CST   13 months ago
```

#### 3.2 搜索镜像(docker search)

##### 3.2.1 用法

```bash
docker search [OPTIONS] TERM
```

##### 3.2.2 描述说明

`docker search`用于从[Docker Hub](https://hub.docker.com)中搜索指定的镜像。

##### 3.2.3 选项

| 名称            | 默认值 | 描述                   |
| --------------- | ------ | ---------------------- |
| `--filter , -f` |        | 根据提供的条件过滤输出 |
| `--format`      |        | 对镜像进行格式化展示   |
| `--limit`       | 25     | 搜索结果的最大数量     |
| `--no-trunc`    |        | 不截断输出             |

##### 3.2.4 案例

###### 3.2.4.1 通过名称搜索镜像

假设我们想从docker Hub中搜索名称包含redis的镜像，可以使用`docker search redis`命令，如下所示：

![image-20210216193854357](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216195058.png) 

- `NAME`：镜像在仓库中的名称。

- `DESCRIPTION`：镜像的描述信息。
- `STARS`：镜像的收藏数。
- `OFFICIAL`：是否为docker官方发布的镜像。
- `AUTOMATED`：是否为自动化构建的镜像。

###### 3.2.4.2 限制搜索结果的展示数量

我们在搜索镜像时，默认情况下，会展示25条搜索结果，如果我们想要改变展示数量的话，可以使用`--limit`。比如我们只想展示5条记录，可以使用`docker search --limit 5 redis`命令，如下所示：

![image-20210216195906707](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216200003.png) 

###### 3.2.4.3 根据条件过滤展示搜索结果

我们可以使用`-f`or`--filter`进行条件过滤，过滤条件使用的是`key=value`这种键值对的形式，可以有多个过滤条件。

支持的过滤条件如下：

- `stars`：数字类型，表示镜像拥有的收藏数量。
- `is-automated`：布尔类型，表示是否为自动化构建的镜像。
- `is-official`：布尔类型，表示是否为官方发布的镜像。

**STARS**

搜索名称包含redis并且收藏数不小于15的镜像，可以使用`docker search -f stars=15 redis`命令。

![image-20210216202421991](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216202441.png) 

**IS-AUTOMATED**

搜索名称包含redis并且是自动化构建的镜像，可以使用`docker search -f is-automated=true redis`命令。

![image-20210216203156607](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216203159.png) 

**IS-OFFICIAL**

搜索名称包含redis并且是官方发布的镜像，可以使用`docker search -f is-official=true redis`命令。

![image-20210216203558030](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216203601.png) 

**组合过滤**

搜索名称包含redis并且是自动化构建的镜像，可以用`docker search -f is-automated=true -f stars=15 redis`命令。

![image-20210216204800097](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216204802.png) 

###### 3.2.4.4 自定义展示镜像的搜索结果

可以使用`--format`选项对搜索结果进行格式化输出，可以有如下占位符：

| 占位符         | 描述                   |
| -------------- | ---------------------- |
| `.Name`        | 镜像名称               |
| `.Description` | 镜像描述               |
| `.StarCount`   | 镜像收藏数             |
| `.IsOfficial`  | 是否为官方发布的镜像   |
| `.IsAutomated` | 是否为自动化构建的镜像 |

- 可以使用`docker search --format "table {{.Name}}\t{{.StarCount}}" redis`命令搜索名称包含redis，并且带表头只显示镜像名称和收藏数的镜像。

![image-20210216210251429](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216210253.png) 

- 可以使用`docker search --format "{{.Name}}" redis`命令搜索名称包含redis，并且不带表头只显示镜像名称的镜像。

![image-20210216210621283](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216213813.png) 

###### 3.2.4.5 展示搜索结果的详细信息

我们在搜索镜像的时候可以发现，描述信息并没有完全展示，如果我们想要完全展示的话，就需要用到`--no-trunc`选项，比如我们使用`docker search --no-trunc redis`命令搜索redis，可以发现，描述信息已经被全部展示了。

![image-20210217123205172](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123207.png) 

#### 3.3 拉取镜像(docker pull)

##### 3.3.1 根据名称拉取镜像

假设我们想要拉取nginx镜像，可以使用`docker pull nginx`命令，该命令拉取的镜像的标签默认是latest。

![image-20210216213756947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216213759.png) 

##### 3.3.2 根据名称和标签拉取镜像

我们也可以指定标签来拉取镜像，比如使用`docker pull nginx:1.19.6`命令拉取指定标签的镜像。

![image-20210216214204028](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216214206.png) 

#### 3.4 删除镜像(docker rmi)

##### 3.4.1 不加标签删除

不加标签默认会删除标签为latest的镜像，比如使用`docker rmi nginx`命令删除nginx镜像。

![image-20210216220851333](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216220854.png) 

##### 3.4.2 指定标签删除

比如使用`docker rmi nginx:mainline`命令删除标签为mainline的镜像。

![image-20210216221645629](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210216221647.png) 

##### 3.4.3 根据镜像id删除

比如使用`docker rmi b9e1dc12387a`命令删除该id对应的镜像。

![image-20210217095107558](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217095115.png) 

##### 3.4.4 强制删除镜像

我们可以使用`--force`或者`-f`强制删除一个镜像，比如使用`docker rmi -f f6d0b4767a6c`命令强制删除该id对应的镜像。

![image-20210217095612682](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217095618.png) 

##### 3.4.5 删除所有镜像

可以使用`docker rmi -f $(docker images -aq)`命令删除本地所有镜像。

![image-20210217114301947](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217114305.png) 

### 4.容器相关命令

#### 4.1 查看容器(docker ps)

**用法：**

```bash
docker ps [OPTIONS]
```

**Options**

| 名称            | 默认值 | 描述                                                         |
| --------------- | ------ | ------------------------------------------------------------ |
| `--all , -a`    |        | 显示所有容器(不使用该参数的话，默认只会显示正在运行中的容器) |
| `--filter , -f` |        | 根据提供的条件过滤输出                                       |
| `--format`      |        | 对容器进行格式化展示                                         |
| `--last , -n`   | -1     | 显示最后创建的容器(包括所有状态)                             |
| `--latest , -l` |        | 显示最近一次创建的容器(包括所有状态)                         |
| `--no-trunc`    |        | 不截断输出                                                   |
| `--quiet , -q`  |        | 只显示容器id                                                 |
| `--size , -s`   |        | 显示文件总大小                                               |

##### 4.1.1 查看所有容器

可以使用`docker ps -a`命令查看所有容器，包括正在运行的和已经停止运行的。

![image-20210217121258115](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217121301.png) 

##### 4.1.2 查看正在运行中的容器

使用`docker ps`命令可以查看所有正在运行中的容器，已经停止的容器，不会展示出来。

![image-20210217121502796](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123755.png) 

##### 4.1.3 展示容器的详细信息

比如可以使用`docker ps --no-trunc`命令展示正在运行中的容器的详细信息。

![image-20210217123712412](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217123759.png) 

由上图可知，默认情况下**CONTAINER ID**和**COMMAND**这两列下的内容都被进行了截取，而只有在使用了`--no-trunc`选项之后这两列下的内容才完全展示出来。

##### 4.1.4 容器的磁盘大小展示

可以使用`docker ps -s`命令展示容器大小，展示的结果中会有两个数值，一个是容器真实增加的大小，一个是整个容器的虚拟大小，**容器虚拟大小 = 容器真实增加的大小 + 容器镜像的大小**。

![image-20210217124744087](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217124748.png) 

##### 4.1.5 根据条件过滤容器

我们可以使用`-f`or`--filter`进行条件过滤，过滤条件使用的是`key=value`这种键值对的形式，可以有多个过滤条件。

支持的过滤条件如下：

- `id`：容器的id。
- `name`：容器的名称。
- `label`：表示键或键值对的任意字符串。
- `exited`：表示容器退出的状态码，只有在使用`-a`这个选项时该条件才会生效。
- `status`：容器的状态(`created`,`restarting`,`running`,`removing`,`paused`,`exited`,`dead`)。
- `ancestor`：过滤从指定镜像创建的容器。
- `before` or `since`：过滤在给定的容器ID或名称之前或之后创建的容器。
- `volume`：过滤挂载有指定数据卷的容器。
- `network`：过滤连接到指定网络的容器。
- `publish` or `expose`：过滤发布或公开给定端口的容器。。
- `health`：根据容器的健康检查状态过滤容器(`starting`,`healthy`,`unhealthy`,`none`)。
- `isolation`：Windows daemon使用(`default`,`process`,`hyperv`)。
- `is-task`：是否是一个服务的task(`true` or `false`)。

###### 4.1.5.1 根据容器id或容器名称进行过滤

使用`docker ps -af "id=b64edfe27b8b"`命令或者`docker ps -af "name=bold_bouman"`命令就是根据容器id及容器名称进行过滤的方式。

![image-20210217172323762](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217173138.png) 

###### 4.1.5.2 根据容器退出的状态码进行过滤

比如只想展示退出的状态码是0的容器，可以使用`docker ps -af "exited=0"`命令。

![image-20210217173136555](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217173319.png) 

###### 4.1.5.3 根据容器的状态进行过滤

假设我们只想展示正在运行的容器，这时候就可以使用`docker ps -af status=running`命令。

![image-20210217173639022](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174126.png) 

###### 4.1.5.4 根据镜像过滤容器

假设我们只想展示tomcat这个镜像创建的容器，可以使用`docker ps -af ancestor=tomcat`命令。

![image-20210217174122193](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174640.png) 

除了可以使用镜像名称过滤外，也可以使用镜像id来过滤该镜像对应的容器。这种方式需要我们先获取到镜像的id，然后再根据id过滤即可，可以使用`docker ps -af ancestor=$(docker images -q tomcat)`命令。

![image-20210217174633731](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217174646.png) 

##### 4.1.6 格式化展示容器

可以使用`--format`选项对容器进行格式化结果展示，可以有如下占位符：

| 占位符        | 描述                                       |
| :------------ | :----------------------------------------- |
| `.ID`         | 容器id                                     |
| `.Image`      | 镜像名称                                   |
| `.Command`    | 启动命令                                   |
| `.CreatedAt`  | 容器创建的时间                             |
| `.RunningFor` | 容器被创建至今已经过去了多长时间           |
| `.Ports`      | 端口信息                                   |
| `.State`      | 容器状态(比如`created`,`running`,`exited`) |
| `.Status`     | 带有持续时间和运行状况的状态               |
| `.Size`       | 容器磁盘大小                               |
| `.Names`      | 容器名称                                   |
| `.Labels`     | 分配给容器的所有标签                       |
| `.Label`      | 指定的标签值                               |
| `.Mounts`     | 容器中挂载的卷的名称                       |
| `.Networks`   | 连接到容器的网络名称                       |

使用`docker ps -a --format "table {{.ID}}\t{{.Image}}\t{{.CreatedAt}}\t{{.RunningFor}}\t{{.State}}\t{{.Status}}\t{{.Names}}"`命令进行格式化演示，如下所示：

![image-20210217182003114](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217182011.png) 

##### 4.1.7 显示最近创建的容器

如果我们想要展示最近一次或者前几次创建的容器，可以使用`-l`和`-n`选项来实现，比如使用`docker ps -l`命令就是展示最近一次创建的容器，使用`docker ps -n 3`命令则是展示前3次创建的容器。

![image-20210217185123880](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217185125.png) 

#### 4.2 运行容器(docker run)

**用法：**

```bash
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

**常用选项：**

| 名称             | 默认值 | 描述                                             |
| :--------------- | :----- | :----------------------------------------------- |
| `-d`             |        | 后台运行容器，并返回容器id，也即启动守护式容器   |
| `--name`         |        | 为容器指定一个名称                               |
| `-i`             |        | 以交互模式运行容器，通常与`-t`同时使用           |
| `-t`             |        | 为容器重新分配一个伪输入终端，通常与`-i`同时使用 |
| `-p`             |        | 指定端口映射，格式为：**宿主机端口:容器端口**    |
| `-P`             |        | 随机端口映射，容器内部端口随机映射到主机的端口   |
| `--rm`           |        | 当容器退出时自动移除该容器                       |
| `--privileged`   |        | 给这个容器扩展权限                               |
| `--workdir , -w` |        | 指定容器的工作目录                               |
| `--volume , -v`  |        | 绑定挂载卷                                       |

##### 4.2.1 前台运行容器

假设直接使用`docker run nginx`命令运行nginx，这种就属于前台运行，前台运行会占用我们的窗口。

![image-20210217202517929](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217203000.png) 

为了验证容器是否运行成功，可以另开一个窗口进行查看。由下图可知，容器确实运行成功了。

![image-20210217202710813](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217202942.png) 

##### 4.2.2 后台运行容器

如果想要后台运行容器，需要用到`-d`选项。比如可以使用`docker run -d tomcat`命令后台运行tomcat容器。

![image-20210217211959212](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217212001.png) 

##### 4.2.3 给需要运行的容器指定名称

我们可以使用`docker run --name mytomcat -d tomcat`命令通过后台的方式运行一个tomcat容器，并将该容器命名为mytomcat。

![image-20210217213909480](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217213916.png) 

##### 4.2.4 容器端口映射

容器中启动的应用，外部方式默认情况下是无法访问到的，这时候就可以通过端口映射的方式和宿主机进行关联，比如可以使用`-P`选项随机映射到宿主机的某个端口上。使用`docker run --name mynginx -P -d nginx`命令运行nginx容器就是指把运行的容器对应的80端口映射到宿主机的49153端口上，这时外部通过宿主机的49153端口就可以访问到容器中运行的nginx了。

![image-20210217214554883](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217220158.png) 

除了随机映射外，我们还可以通过`-p`选项指定端口映射。如下图所示，外部通过宿主机的12345端口就可以访问到容器中使用80端口运行的nginx了。使用的命令是` docker run --name nginxtest -p 12345:80 -d nginx`。

![image-20210217220153801](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217220205.png) 

##### 4.2.5 运行并进入容器

我们可以使用`-i`和`-t`选项在启动容器后就进入容器与容器进行交互。比如使用`docker run -it centos:7`命令就会启动并进入到容器中，下图中的`ls`命令就是在centos容器中使用的。

![image-20210217221342809](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210217221903.png)

##### 4.2.6 进入容器的指定目录

假设我们想在运行容器后就直接进入到`/etc/yum`目录中，那么可以使用`docker run -w /etc/yum -it centos:7`命令来实现，如果该目录不存在，则会在容器中自动新建该目录。

![image-20210218095253265](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218095258.png) 

我们也可以直接进入容器的指定目录下执行指定的命令后再退出容器，比如我们想要在容器的`/etc/yum`目录下执行`ls`命令后再退出容器，可以使用`docker run -w /etc/yum -it centos:7 ls`命令。

![image-20210218100027654](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218100037.png) 

#### 4.3 退出容器

```bash
exit  # 使用-it选项运行并进入centos容器后，使用该命令退出容器后，同时也会停止容器
Ctrl + P + Q  # 退出不停止容器
```

#### 4.4 删除容器(docker rm)

与删除镜像的用法差不多，如果想要强制删除的话，需要用到`-f`选项，也可以通过容器id进行全量删除。

- 根据容器名称删除(比如：`docker rm amazing_jang`)

![image-20210218102908307](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218102910.png) 

- 根据容器id删除(比如：`docker rm 844c7ea979a4`)

![image-20210218103127487](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218103143.png) 

- 强制删除容器(比如：`docker rm -f def0deead9e5`)

使用`-f`选项可以删除正在运行中的容器。

![image-20210218103558726](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218103600.png) 

- 全量删除容器(比如：`docker rm $(docker ps -aq)`)

![image-20210218104535412](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218104538.png) 

- 删除多个容器(比如：`docker rm 9309fcf92cd6 ee765a728229`)

![image-20210218182229334](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218182231.png) 

#### 4.5 进入容器(docker exec)

我们可以通过容器名称或者容器id来进入容器，进入容器的命令后面可以跟`sh`也可以跟`bash`，比如我们想要进入一个正在运行的nginx容器中，可以使用`docker exec -it 8abd33e52701 sh`命令，8abd33e52701是容器的id，也可以使用`docker exec -it mynginx bash`命令，mynginx是容器的名称。

![image-20210218112401907](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218112408.png) 

#### 4.6 容器的停止和启动

我们可以使用`docker stop 容器名称|容器id`命令来停止容器，使用`docker start 容器名称|容器id`命令来启动容器。

![image-20210218115455420](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218115457.png) 

#### 4.7 容器和宿主机之间的文件拷贝

我们可以将宿主机上的文件拷贝到容器中，也可以将容器中的文件拷贝到宿主机上。

- **宿主机--->容器：**

```bash
docker cp 宿主机的文件或目录 容器名称或id:容器目录
```

假设我们想将宿主机的`/root/nginx/linux-nginx-1.16.1.tar.gz`文件拷贝到容器的`/home`路径下，可以使用下图中的命令，当我们进入到容器的`/home`路径下时，发现确实有`linux-nginx-1.16.1.tar.gz`文件，说明拷贝成功了。

![image-20210218121407834](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218121410.png) 

- **容器--->宿主机：**

```bash
docker cp 容器名称或id:容器的文件或目录 宿主机的目录
```

比如使用`docker cp mynginx:/lib/init/vars.sh /root/test`命令将容器中的`/lib/init/vars.sh`文件拷贝到宿主机的`/root/test`目录下。由下图可知，已经拷贝成功了。

![image-20210218123608436](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218123610.png) 

#### 4.8 目录挂载(容器数据卷操作)

我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器，而且这个操作是双向绑定的，也就是说，容器内的操作也会影响到宿主机，可以实现备份功能。

使用目录挂载的话，当容器被删除的时候，宿主机与容器映射的目录下的内容并不会被删除。如果多个容器挂载了同一个目录，当其中一个容器被删除的时候，其他容器的该目录下的内容并不会受到影响。

> 容器与宿主机之间的数据卷属于引用的关系，数据卷是从外界挂载到容器内部中的，所以可以脱离容器的生命周期而独立存在，正是由于数据卷的生命周期并不等同于容器的生命周期，在容器退出或者删除以后，数据卷才不会受到影响。
>
> 目录挂载操作可能会出现权限不足的提示。这是因为CentOS7中的安全模块SELinux把权限禁掉了，在docker run时可以通过`--privileged=true`给该容器加权限来解决挂载的目录没有权限的问题。

##### 4.8.1 指定目录挂载

如果想要在运行容器的时候使用目录挂载，需要使用`-v`选项，该选项后跟的目录的格式为:`宿主机目录:容器目录`。也可以使用`docker run -v 宿主机目录:容器目录 -v 宿主机目录2:容器目录2 镜像名`这种格式进行多目录挂载。

假设我们想把宿主机的`/root/test`路径和容器的`/home/gsl`路径(没有该路径的话会自动创建)进行映射，那么我们可以在运行容器的时候使用`docker run --name mynginx -d -v /root/test:/home/gsl nginx`命令实现。然后我们进入到容器的`/home/gsl`目录下会发现，之前宿主机的`/root/test`目录下的vars.sh文件，在容器的`/home/gsl`目录下也存在，这就说明已经完成了目录挂载，这时不管对哪一个目录进行操作，都会完成数据同步。

![image-20210218153900305](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218153903.png) 

如果我们想要知道宿主机和容器之间的这个目录映射关系，可以使用`docker inspect 容器名称|容器id`命令查看，比如使用`docker inspect mynginx|grep -A9 "Mounts"`命令。

![image-20210218160018559](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218160154.png) 

##### 4.8.2 匿名目录挂载

匿名挂载不需要我们在运行容器时再指定宿主机的目录，只要指定容器的目录即可，然后宿主机上对应的目录都会自动生成到`/var/lib/docker/volumes`路径下。比如使用`docker run --name mynginx -d -v /usr/local/data nginx`。

![image-20210218164411072](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218164415.png) 

##### 4.8.3 具名目录挂载

具名挂载就是给数据卷起一个名字，容器外对应的目录会在`/var/lib/docker/volumes`路径中生成。比如我们给宿主机上的数据卷起名为host_data，使用`docker run --name mynginx01 -d -v host_data:/usr/local/data nginx`命令即可。

![image-20210218172143590](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218172145.png) 

##### 4.8.4 只读/读写

```bash
# 只读。只能通过修改宿主机内容实现对容器的数据管理，不能在容器中修改映射到容器的目录下的文件。
docker run -v /宿主机目录:容器目录:ro 镜像名
# 读写。默认就是读写，也就是说进行目录挂载后，宿主机和容器都能对映射目录下的文件进行修改。
docker run -v /宿主机目录:容器目录:rw 镜像名
```

##### 4.8.5 继承(volumes-from)

假设我们已经运行了一个使用了目录挂载的容器A，然后我们还想运行一个带目录挂载的容器B，并且希望容器B使用挂载对应宿主机的目录和容器中映射的目录和容器A都一样，这时候就可以使用`--volumes-from`选项来实现。命令如下：

```bash
# 运行mynginx容器
docker run -d --name mynginx -v /root/test:/usr/local/data nginx
# 运行mynginx01容器，并继承mynginx容器的目录挂载
docker run -d --name mynginx01 --volumes-from mynginx nginx
# 查看mynginx容器的目录挂载信息
docker inspect mynginx|grep -A9 "Mounts"
# 查看mynginx01容器的目录挂载信息
docker inspect mynginx01|grep -A9 "Mounts"
```

![image-20210218175903870](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218175906.png) 

##### 4.8.6 查看数据卷的基本信息

可以使用`docker volume inspect 数据卷名称`来查看数据卷的基本信息，比如之前创建了一个名字叫host_data的数据卷，那就可以使用`docker volume inspect host_data`命令查看这个数据卷的基本信息。

![image-20210218181625687](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218181628.png) 

##### 4.8.7 查看容器IP信息

可以使用`docker inspect`命令查看容器的IP信息，比如使用`docker inspect mynginx|grep -A16 "Networks"`命令查看mynginx容器的IP信息。

![image-20210218182755742](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218182758.png) 

#### 4.9 提交镜像(docker commit)

我们可以使用`docker commit`命令把自己更改过的容器创建成一个新的镜像。

**用法：**

```bash
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]
```

**选项：**

| 名称             | 默认值 | 描述                               |
| ---------------- | ------ | ---------------------------------- |
| `--author , -a`  |        | 该选项用于添加镜像提交人的信息     |
| `--change , -c`  |        | 对创建的映像应用Dockerfile指令     |
| `--message , -m` |        | 该选项用于添加提交镜像时的描述信息 |
| `--pause , -p`   | true   | 在镜像的提交期间暂停容器           |

**命令举例：**

```bash
# ”gongsl“是作者，"installed nginx"是描述信息，“mycentos”是生成的镜像的名称，“1.0.0”是生成的镜像的标签
docker commit -a="gongsl" -m="installed nginx" 容器id|容器名称 mycentos:1.0.0
```

当我们根据容器创建了一个新的镜像后，我们使用`docker images`命令是可以展示出这个新的镜像的。

![image-20210218201801415](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218201803.png) 

**实操演示：**

下面我就实操演示一下，如何在一个运行的centos容器中安装nginx并生成一个新的镜像。

![演示](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210218213901.gif) 

































