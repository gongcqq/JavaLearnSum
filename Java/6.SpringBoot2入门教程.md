### 1.编写一个HelloWorld

#### 1.1 版本问题

`SpringBoot2要求jdk至少要是1.8或者以上版本，maven至少3.3以上版本。`

#### 1.2 新建一个maven项目

![1](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235915.jpg) 

![2](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235927.jpg) 

![3](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108234926.jpg) 

![4](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235941.jpg) 

![5](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210108235949.png) 

#### 1.3 配置maven的settings.xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">

  <localRepository>E:\self-study\mvn_repository</localRepository>

  <mirrors>
     <mirror>
        <id>nexus-aliyun</id>
        <name>aliyun maven</name>
        <url>http://maven.aliyun.com/nexus/content/groups/public</url>
        <mirrorOf>central</mirrorOf>
     </mirror>
  </mirrors>

  <profiles>
    <profile>
        <id>jdk-1.8</id>
        <activation>
          <activeByDefault>true</activeByDefault>
          <jdk>1.8</jdk>
        </activation>
        <properties>
          <maven.compiler.source>1.8</maven.compiler.source>
          <maven.compiler.target>1.8</maven.compiler.target>
          <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
        </properties>
    </profile>
  </profiles>
</settings>
```

#### 1.4 pom.xml文件中引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.gongsl</groupId>
    <artifactId>SpringBootProject</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.7.RELEASE</version>
    </parent>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

    <!--spring-boot-maven-plugin可以为我们创建一个可执行的jar-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

#### 1.5 创建启动类

```java
package com.gongsl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class,args);
    }
}
```

`启动类中的run方法是有返回值的，返回值就是IOC容器。`

#### 1.6 编写业务代码

```java
package com.gongsl.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @Author: gongsl
 * @Date: 2021-01-08 18:19
 */
@RestController
public class HelloController {

    @RequestMapping("/hello")
    public String home(){
        return "Hello SpringBoot2!";
    }
}
```

#### 1.7 运行测试

执行`MainApplication`类的`main`方法，然后浏览器地址栏输入 http://localhost:8080/hello 进行访问即可。

#### 1.8 修改端口启动

在maven项目的`src\main\resources`目录下新增`application.properties`配置文件，然后在文件中新增以下内容：

```properties
server.port=8081
```

这时端口就已经被修改成**8081**了，然后重新运行启动类的`main`方法，最后在浏览器地址栏输入 http://localhost:8081/hello 进行访问即可。

#### 1.9 通过cmd窗口启动项目

如果我们在pom.xml文件中加了`spring-boot-maven-plugin`这个依赖的话，那么使用maven打成的包就是一个可执行的jar包。我们可以在cmd窗口中进行演示，这里需要用到`java -jar`命令，如下所示：

![演示](https://cdn.jsdelivr.net/gh/gongcqq/FigureBed@main/Image/Typora/20210109000012.gif) 

#### 1.10 注意事项

1. 如果浏览器地址栏访问url出现问题，首先检查是不是`MainApplication`启动类的位置有问题。该类一定要放在最外侧，要保证能够扫描到所有的controller,因为SpringBoot会自动加载启动类所在包下以及其子包下的所有组件；
2. 如果我们不想把启动类放在最外侧，或者想要自定义被扫描的包及其下的controller类的话，也是可以实现的，只需要在启动类的`@SpringBootApplication`注解中增加`scanBasePackages`参数即可，比如扫描`com.gongsl`包下的所有内容，就配置为`@SpringBootApplication(scanBasePackages = "com.gongsl")`即可；

```xml
如果启动类的包路径是“com.gongsl”的话，那么
@SpringBootApplication
等同于
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan("com.gongsl")
```

3. 上面`HelloController`类上用的是`@RestController`注解，这个注解就是`@Controller`和`@ResponseBody`的组合注解；
4. 如果想知道`application.properties`配置文件中可以写哪些东西，那么我们可以参考[官方文档](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties)。

### 2.SpringBoot简介

#### 2.1 为什么使用SpringBoot

- SpringBoot能快速创建出生产级别的Spring应用。

#### 2.2 SpringBoot的优点

- 可以创建独立的Spring应用；
- 内嵌了web服务器；
- 自动starter依赖，简化了构建配置；
- 自动配置Spring以及第三方功能；
- 提供生产级别的监控、健康检查及外部化配置；
- 无代码生成、无需编写XML文件等。

`SpringBoot是整合Spring技术栈的一站式框架，也是简化Spring技术栈的快速开发脚手架。`

#### 2.3 SpringBoot的缺点

- 人称版本帝，迭代快，需要时刻关注变化；
- 封装太深，内部原理复杂，不容易精通。

#### 2.4 SpringBoot的时代背景

##### 2.4.1 微服务

- 微服务是一种架构风格；
- 微服务是一个应用拆分为一组小型服务；
- 每个服务运行在自己的进程内，也就是可独立部署和升级；
- 服务之间使用轻量级HTTP进行交互；
- 服务围绕业务功能拆分；
- 服务可以由全自动部署机制独立部署；
- 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术。

##### 2.4.2 分布式

###### 2.4.2.1 分布式的困难

- 远程调用

- 服务发现

- 负载均衡

- 服务容错

- 配置管理

- 服务监控

- 链路追踪

- 日志管理

- 任务调度

- ......

###### 2.4.2.2 分布式的解决方案

- SpringBoot + SpringCloud

##### 2.4.3 云原生

###### 2.4.3.1 上云的困难

- 服务自愈

- 弹性伸缩

- 服务隔离

- 自动化部署

- 灰度发布

- 流量治理

- ......

###### 2.4.3.2 上云的解决方案

- Cloud Native

#### 2.5 SpringBoot的特点

##### 2.5.1 依赖管理

###### 2.5.1.1 父项目做依赖管理

```xml
<!-- 通过spring-boot-starter-parent这个父项目做依赖管理 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.7.RELEASE</version>
</parent>

<!-- spring-boot-starter-parent这个父项目中还有下面这个父项目 -->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.7.RELEASE</version>
</parent>
```

`spring-boot-dependencies`这个父项目中几乎声明了所有开发中常用的依赖的版本号,这个就是自动版本仲裁机制。

###### 2.5.1.2 导入starter作为场景启动器

- 我们以后在pom.xml文件中会见到很多`spring-boot-starter-*`这种配置，这个就是场景启动器，后面的*号就代表了某种场景；
- 只要引入了某个场景的starter，这个场景的所有常规需要的依赖都会被自动引入；
- 如果我们想知道SpringBoot支持哪些场景的starter，可以到[官方文档](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/using-spring-boot.html#using-boot-starter)中进行查阅；
- 像`*-spring-boot-starter`这种starter一般都是第三方为我们提供的简化开发的场景启动器；
- 所有场景启动器最底层的依赖就是下面这个。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <version>2.3.7.RELEASE</version>
    <scope>compile</scope>
</dependency>
```

###### 2.5.1.3 自动版本仲裁

- 自动版本仲裁功能可以让我们无需关注版本号，因为在`spring-boot-dependencies`这个父项目中，所有涉及的依赖的版本号都已经配置在了`properties`标签下了，所以我们引入依赖时默认可以不写版本号；
- 不过引入非版本仲裁的jar包时，要写版本号。

###### 2.5.1.4 能够修改默认版本号 

我们也可以修改默认版本号。首先要在`spring-boot-dependencies`这个父项目中查看需要修改版本号的依赖的标签名是什么，比如mysql版本号对应的标签名就是`mysql.version`，假设我们想修改mysql的版本号为`5.1.43`，那就直接在项目的pom.xml文件中加入如下内容即可。

```xml
<properties>
    <mysql.version>5.1.43</mysql.version>
</properties>
```

##### 2.5.2 自动配置

假设就以`spring-boot-starter-web`这个依赖为例。

- 只要引入了上面那个web依赖，SpringBoot就会为我们自动引入tomcat依赖，自动给我们配置好tomcat；
- 同样会引入SpringMVC的全套组件，并自动配好SpringMVC的常用功能；
- 还会自动配好Web常见功能，比如字符编码问题等，并帮我们配置好了所有web开发的常见场景；
- SpringBoot也会为我们配置一个默认的包扫描路径，不用再手动进行包扫描的配置；
- SpringBoot为我们提供的各种配置都会赋予一个默认值
  - 默认配置最终都是映射到某个类上，如：MultipartProperties；
  - 配置文件的值最终会绑定某个类上，这个类会在容器中创建对象。
- SpringBoot是按需加载所有自动配置项，我们引入了哪些场景，这个场景的自动配置才会开启；
- SpringBoot所有的自动配置功能都在`spring-boot-autoconfigure`包里面，比如`spring-boot-autoconfigure-2.3.7.RELEASE.jar`包。

### 3.常用注解的用法

#### 3.1 @bean注解和@Configuration注解

##### 3.1.1 前置准备

###### 3.1.1.1 引入依赖

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

这里引入lombok依赖时不用加版本号，因为SpringBoot的自动版本仲裁功能已经为我们设置好了对应的版本号，我们可以在`spring-boot-dependencies`这个父项目中根据`lombok.version`标签查看到对应的版本号是什么。

###### 3.1.1.2 增加两个实体类

```java
package com.gongsl.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.ToString;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:27
 */
@Data
@ToString
@AllArgsConstructor
public class User {
    private String name;
    private Integer age;
    private String gender;
}
```

```java
package com.gongsl.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.ToString;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:33
 */
@Data
@ToString
@AllArgsConstructor
public class Pet {
    private String name;
}
```

###### 3.1.1.3 新增配置类

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration
public class MyConfig {

    @Bean
    public User userTest(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

##### 3.1.2 @bean、@Configuration的用法

- 之前Spring想要将某个组件放到IOC容器中，一般会在一个xml配置文件中进行配置，而SpringBoot不再使用配置文件，而是使用配置类，我们可以新建一个类，比如`MyConfig`类，然后只要我们在这个类上加上`@Configuration`注解，那这个类就是**配置类**，这个类等同于之前我们使用的配置文件；
- 以前在配置文件中，我们可以使用`bean`标签来给容器添加组件，现在我们在配置类中的方法上使用`@Bean`注解可以完成同样的效果；
- 以上面的`userTest`方法为例，该方法使用了`@bean`注解，就表示向容器中添加了一个组件，方法名就是组件id，方法的返回类型就是组件的类型，方法的返回值就是组件在容器中的实例；
- 如果我们不希望方法名作为容器中组件的id的话，也可以自定义，比如把上面配置类中`userTest`方法的`@bean`注解改成`@Bean("user")`，就把组件id改为"user"了，我们可以在启动类中进行验证，如下所示：

**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration
public class MyConfig {

    @Bean("user")
    public User userTest(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

**启动类：**

```java
package com.gongsl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        //获取所有组件id的名称
        String[] beanNames = run.getBeanDefinitionNames();
        for (String name : beanNames) {
            if("user".equals(name) || "petCat".equals(name)){
                System.out.print(name+" ");
            }
        }
    }
}

//运行结果：user petCat
```

- 配置类中使用`@bean`注解在方法上给容器注入的组件，默认是单实例的。由于是单实例，所以容器中同一个实例无论怎么获取，获取多少次，都是一样的，验证如下：

```java
package com.gongsl;

import com.gongsl.bean.Pet;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        Pet pet1 = run.getBean(Pet.class);
        Pet pet2 = run.getBean(Pet.class);
        System.out.println(pet1==pet2);//运行结果：true

        //通过组件id更精确地获取
        Pet petCat1 = run.getBean("petCat", Pet.class);
        Pet petCat2 = run.getBean("petCat", Pet.class);
        System.out.println(petCat1==petCat2);//运行结果：true
    }
}
```

- 配置类本身也是容器中的一个组件。如果不是的话，当我们从容器中获取的时候是会报错的，验证如下：

```java
package com.gongsl;

import com.gongsl.config.MyConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        MyConfig bean = run.getBean(MyConfig.class);
        System.out.println(bean);
    }
}

//运行结果：com.gongsl.config.MyConfig$$EnhancerBySpringCGLIB$$33e871dd@55f45b92
```

##### 3.1.3 proxyBeanMethods属性的用法

1. 和SpringBoot1相比，SpringBoot2中的`@Configuration`注解新增了一个`proxyBeanMethods`属性(这个属性是Spring5.2版本以后才有的，SpringBoot2中Spring的版本就是5.2)，该属性的默认值是true；
2. 外部无论对配置类中已经使用`@bean`注解注入到容器中的组件方法调用多少次，获取到的都是已经注入到容器中的单实例对象，之所以出现这种情况，就是因为配置类的`@Configuration`注解中`proxyBeanMethods`属性的默认值是true的原因；
3. 当配置类的`@Configuration`注解中`proxyBeanMethods`属性为true时，如果我们直接从容器中获取配置类，可以发现，获取到的结果是`com.gongsl.config.MyConfig$$EnhancerBySpringCGLIB$$33e871dd@55f45b92`。从结果中的`EnhancerBySpringCGLIB`可以发现，`MyConfig`类并不是一个普通的配置类，而是一个被SpringCGLIB增强了的代理对象；
4. 当`proxyBeanMethods`属性为true时，如果我们调用配置类中使用过`@bean`注解的方法，比如`petCat()`方法，那么SpringBoot总会检查该方法是否已经被注入到容器中，如果发现容器中有该方法返回的组件，那么就直接从容器中获取，这时候无论我们调用多少次`petCat()`方法，返回的Pet对象都是同一个，即之前放入容器中的那一个；
5. 如果`proxyBeanMethods`属性为false，那么当我们调用`petCat()`方法时，SpringBoot就不会再检查该方法是否已经被注入到容器中，自然也就不会再从容器中获取组件，而是直接调用该方法，由于`petCat()`方法中的逻辑就是创建一个Pet对象，所以这时每调用一次`petCat()`方法就会创建一个新的Pet对象，这样每次调用`petCat()`方法返回的Pet对象就都不相同了，代码验证如下：

**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration(proxyBeanMethods = false)
public class MyConfig {

    @Bean("user")
    public User userTest(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

**启动类：**

```java
package com.gongsl;

import com.gongsl.bean.Pet;
import com.gongsl.config.MyConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        MyConfig bean = run.getBean(MyConfig.class);
        System.out.println(bean);//运行结果：com.gongsl.config.MyConfig@437ebf59

        Pet pet1 = bean.petCat();
        Pet pet2 = bean.petCat();
        System.out.println(pet1==pet2);//运行结果：false
    }
}
```

当配置类中的`proxyBeanMethods`属性为false时，我们可以发现，pet1和pet2并不是同一个对象，而且从容器中获取的配置类也不带`EnhancerBySpringCGLIB`了，而变成了`com.gongsl.config.MyConfig@437ebf59`。如果我们把配置类中的`proxyBeanMethods`属性设置成true的话，上面pet1和pet2就会是同一个对象，运行结果也自然就是true了。

6. 配置类的`@Configuration`注解中`proxyBeanMethods`属性可以用来解决组件依赖问题，这个属性也引申出了两种模式，分别是**Full模式**和**Lite模式**。当proxyBeanMethods属性值为true时，就是Full模式，这个是默认模式，属性值为false时就是Lite模式。如果组件之间存在依赖关系的话，我们要使用Full模式来保证单实例，无依赖关系则可以使用Lite模式。Lite模式可以减少SpringBoot的判断，加速容器启动的过程。

可以将Pet类设置为User类的一个属性来验证组件依赖：

**User实体类：**

```java
package com.gongsl.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.ToString;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:27
 */
@Data
@ToString
@AllArgsConstructor
public class User {
    private String name;
    private Integer age;
    private String gender;
    private Pet pet;
}
```
**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration(proxyBeanMethods = false)
public class MyConfig {

    @Bean("user")
    public User userTest(){
        return new User("张三",18,"男",petCat());
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

**启动类：**

```java
package com.gongsl;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        //从容器中获取User对象
        User user = run.getBean("user", User.class);
        //从容器中获取Pet对象
        Pet pet = run.getBean("petCat", Pet.class);
        System.out.println(user.getPet()==pet);//运行结果：false
    }
}
```

配置类中的`proxyBeanMethods`属性设置为了false，所以启动类中运行结果是false。也就是说，从容器中获取的User对象中的pet和容器中的不是一个，这样就无法保证pet的单实例了，那我们把pet注入到容器中就没有意义了，所以遇到这种组件依赖的情况，`proxyBeanMethods`属性要设置为true才行。

#### 3.2 @Import注解

- 该注解的值默认是一个数组，书写格式为`@Import({User.class,Pet.class})`，如果数组中只有一个元素，也可以写成`@Import(User.class)`这种形式；
- 我们可以使用这个注解给容器中自动创建多个不同类型的组件，每个组件的组件id就是数组中各元素的全类名；
- 我们也可以使用`@Import`注解把jar包中的类给注入到容器中；
- 如果想要使用`@Import`注解把某个类注入到容器中，那么这个类一定要有无参的构造方法才行。

我们可以把User类、Pet类以及spring-webmvc这个jar包中的ModelAndView类都注入到容器中，演示代码如下：

**User类：**

```java
package com.gongsl.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:27
 */
@Data
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private String name;
    private Integer age;
    private String gender;
}
```

**Pet类：**

```java
package com.gongsl.bean;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:33
 */
@Data
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Pet {
    private String name;
}
```

**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.web.servlet.ModelAndView;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Import({User.class,Pet.class, ModelAndView.class})
@Configuration
public class MyConfig {

    /*@Bean("user")
    public User userTest(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }*/
}
```

**启动类：**

```java
package com.gongsl;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.web.servlet.ModelAndView;
import java.util.Arrays;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        //根据类型获取容器中的组件id
        String[] userArr = run.getBeanNamesForType(User.class);
        System.out.println(Arrays.toString(userArr));//运行结果：[com.gongsl.bean.User]

        String[] petArr = run.getBeanNamesForType(Pet.class);
        System.out.println(Arrays.toString(petArr));//运行结果：[com.gongsl.bean.Pet]

        String[] servletArr = run.getBeanNamesForType(ModelAndView.class);
        //运行结果：[org.springframework.web.servlet.ModelAndView]
        System.out.println(Arrays.toString(servletArr));
    }
}
```

通过启动类中的运行结果可以发现，这三个对象都已经注入到容器中了，而且组件id就是全类名。

#### 3.3 @Conditional的子注解

- `@Conditional`注解包含了很多的子注解，比如：

```xml
@ConditionalOnJava
@ConditionalOnProperty
@ConditionalOnResource
@ConditionalOnExpression
@ConditionalOnSingleCandidate
@ConditionalOnBean
@ConditionalOnMissingBean
@ConditionalOnClass
@ConditionalOnMissingClass
@ConditionalOnWebApplication
@ConditionalOnNotWebApplication
```

- `@Conditional`及其子注解都是条件注解，即当我们满足这个注解指定的条件的时候，我们才给容器中注入相关的组件，或者干相应的事；
- `@Conditional`注解及其子注解一般用在配置类中，即包含`@Configuration`注解的类。

以`@ConditionalOnBean`注解为例验证条件注解的用法：

**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration
public class MyConfig {

    @Bean
    public User user1(){
        return new User("张三",18,"男");
    }

    @ConditionalOnBean(name = "user12")
    @Bean
    public User user2(){
        return new User("李四",20,"女");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

**启动类：**

```java
package com.gongsl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import java.util.ArrayList;
import java.util.List;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        List<String> list = new ArrayList<String>();
        //获取容器中的所有组件id
        String[] names = run.getBeanDefinitionNames();
        for (String name : names) {
            if("user1".equals(name) || "user2".equals(name) || "petCat".equals(name)){
                list.add(name);
            }
        }
        System.out.println(list);//运行结果：[user1, petCat]
    }
}
```

1. 配置类中`user2`方法上的`@ConditionalOnBean(name = "user12")`注解表示，只有当容器中有名叫“user12”的组件id时，`user2`方法上的`@bean`注解才会生效，即才会把user2注入到容器中；
2. 如果把配置类中的`@ConditionalOnBean(name = "user12")`改成`@ConditionalOnBean(name = "user1")`的话，启动类中的运行结果就是：[user1, user2, petCat]；
3. 类似`@ConditionalOnBean`这种条件注解也可以放到类上面(一般都是指配置类)，表示只有当条件注解中的条件满足时，类中的方法上把组件注入到容器中等操作才会生效；
4. 配置类上的`@Configuration`注解是会把该类作为一个组件注入到容器中的，但是如果类似`@ConditionalOnBean`这种条件注解放到配置类上面且条件注解中的条件不满足的话，配置类上的`@Configuration`注解就不会生效，配置类自然也不会再被注入到容器中了。

#### 3.4 @ImportResource注解

在之前使用Spring开发项目的时候，我们想要把bean注入到容器中，一般都是使用的配置文件。如果现在使用`@bean`注解了，但是之前使用的配置文件还想保留，也不想把配置文件中的bean标签一个个都转成`@bean`注解的话，就可以使用这个`@ImportResource`注解来解决这个问题。

@ImportResource注解的用法案例如下：

在`src\main\resources`目录下新增了一个bean.xml文件，内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="haha" class="com.gongsl.bean.User">
        <property name="name" value="李四"></property>
        <property name="age" value="20"></property>
        <property name="gender" value="女"></property>
    </bean>
</beans>
```

**配置类：**

```java
package com.gongsl.config;

import com.gongsl.bean.Pet;
import com.gongsl.bean.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;

/**
 * @Author: gongsl
 * @Date: 2021-01-11 21:35
 */
@Configuration
@ImportResource("classpath:bean.xml")
public class MyConfig {

    @Bean
    public User user(){
        return new User("张三",18,"男");
    }

    @Bean
    public Pet petCat(){
        return new Pet("汤姆猫");
    }
}
```

**启动类：**

```java
package com.gongsl;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import java.util.ArrayList;
import java.util.List;

/**
 * 主程序类
 * @Author: gongsl
 * @Date: 2021-01-08 18:18
 */
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        //返回的是IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

        List<String> list = new ArrayList<String>();
        //获取容器中的所有组件id
        String[] names = run.getBeanDefinitionNames();
        for (String name : names) {
            if("haha".equals(name) || "user".equals(name) || "petCat".equals(name)){
                list.add(name);
            }
        }
        System.out.println(list);//运行结果：[user, petCat, haha]
    }
}
```

启动类的运行结果中包含了“haha”这个组件id，说明配置类中的`@ImportResource("classpath:bean.xml")`注解生效了，已经把配置文件中bean标签的内容注入到了容器中。

#### 3.5 @ConfigurationProperties注解



































































