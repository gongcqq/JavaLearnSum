### 1.使用前的准备

#### 1.1 jdk版本

代码中使用的是`jdk1.8`版本。

#### 1.2 导入jar包

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.22</version>
    <scope>provided</scope>
</dependency>
```

### 2.Lombok的常用注解

#### 2.1 @NonNull注解

##### 2.1.1 注解的作用

该注解可以作用于成员变量或者方法参数中，使用该注解后，生成的代码中会增加变量值是否为null的判断逻辑，为null则抛出空指针异常。

##### 2.1.2 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.test;

import lombok.NonNull;

public class PojoTest {
    public static void main(String[] args) {
        test("Tom");
    }

    public static void test(@NonNull String name){
        System.out.println("name = " + name);
    }
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.test;

import lombok.NonNull;

public class PojoTest {
    public PojoTest() {
    }

    public static void main(String[] args) {
        test("Tom");
    }

    public static void test(@NonNull String name) {
        if (name == null) {
            throw new NullPointerException("name is marked non-null but is null");
        } else {
            System.out.println("name = " + name);
        }
    }
}
```

> **说明**：由以上代码可知，使用`@NonNull`注解标注name后，生成的代码中增加了对name是否为null的判断逻辑。

#### 2.2 @Setter注解

##### 2.2.1 注解的作用

该注解可以作用于类或变量上。作用于类上时，可以生成该类所有的实例变量的setter方法；作用于变量上时，可以生成该变量对应的setter方法。

##### 2.2.2 注解属性详解

该注解的三个常用属性如下：

- `value`：用于设置setter方法的访问控制符，包含PUBLIC、MODULE、PROTECTED、PACKAGE、PRIVATE、NONE，默认为PUBLIC，NONE表示不生成setter方法，即停用注解功能；
- `onMethod`：该属性的属性值是注解，属性值的所有注解都会被放在生成的方法上，java8之后使用该属性需要在属性后加下划线，即"onMethod_={@注解名}"；
- `onParam`：该属性的属性值也是注解，属性值的所有注解都会被放在生成的方法参数上，java8之后使用该属性也需要在属性后加下划线，即"onParam_={@注解名}"。

##### 2.2.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.Setter;

@Setter
public class Person {
    private Integer id;
    private String name;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

public class Person {
    private Integer id;
    private String name;

    public Person() {
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

我们也可以将@Setter注解的几个属性都使用上看看效果，比如下面这样：

```java
package com.gongsl.lombok.pojo;

import lombok.AccessLevel;
import lombok.NonNull;
import lombok.Setter;

@Setter
public class Person {

    private Integer id;

    /**
     * 生成setter方法后，会给方法的参数上加上@NonNull注解
     */
    @Setter(onParam_ = {@NonNull})
    private String name;

    /**
     * 生成setter方法后，会在方法上加上@Deprecated注解
     */
    @Setter(onMethod_ = {@Deprecated})
    private String gender;

    /**
     * 使用"value = AccessLevel.NONE"属性后，将不会再给"isAdult"变量生成setter方法
     */
    @Setter(value = AccessLevel.NONE)
    private Boolean isAdult;

    /**
     * 我们也可以将@Setter与变量放在一行，这行写法和放在变量上是一样的，
     * 然后下面是将变量生成的setter方法的控制符改成private
     */
    private @Setter(value = AccessLevel.PRIVATE) String other;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;

public class Person {
    private Integer id;
    private String name;
    private String gender;
    private Boolean isAdult;
    private String other;

    public Person() {
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public void setName(@NonNull String name) {
        if (name == null) {
            throw new NullPointerException("name is marked non-null but is null");
        } else {
            this.name = name;
        }
    }

    /** @deprecated */
    @Deprecated
    public void setGender(String gender) {
        this.gender = gender;
    }

    private void setOther(String other) {
        this.other = other;
    }
}
```

> **说明**：可以发现，编译后生成的代码都是符合预期的，像setOther方法的控制符，也变成private了。

#### 2.3 @Getter注解

##### 2.3.1 注解的作用

该注解可以作用于类或变量上。作用于类上时，可以生成该类所有的实例变量的getter方法；作用于变量上时，可以生成该变量对应的getter方法。

##### 2.3.2 注解属性详解

该注解的三个常用属性如下：

- `value`：用于设置getter方法的访问控制符，包含PUBLIC、MODULE、PROTECTED、PACKAGE、PRIVATE、NONE，默认为PUBLIC，NONE表示不生成getter方法，即停用注解功能；
- `onMethod`：该属性的属性值是注解，属性值的所有注解都会被放在生成的方法上，java8之后使用该属性需要在属性后加下划线，即"onMethod_={@注解名}"；
- `lazy`：表示懒加载，默认值为false。如果设置为true，参数必须由final修饰。

##### 2.3.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AccessLevel;
import lombok.Getter;

@Getter
public class Person {

    private Integer id;

    /**
     * 使用"lazy = true"的话，lombok会对name属性进行缓存
     */
    @Getter(lazy = true)
    private final String name = "Tom";

    /**
     * 生成getter方法后，会在方法上加上@Deprecated注解
     */
    @Getter(onMethod_ = {@Deprecated})
    private String gender;

    /**
     * 使用"value = AccessLevel.NONE"属性后，将不会再给"isAdult"变量生成getter方法
     */
    @Getter(value = AccessLevel.NONE)
    private Boolean isAdult;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import java.util.concurrent.atomic.AtomicReference;

public class Person {
    private Integer id;
    private final AtomicReference<Object> name = new AtomicReference();
    private String gender;
    private Boolean isAdult;

    public Person() {
    }

    public Integer getId() {
        return this.id;
    }

    public String getName() {
        Object value = this.name.get();
        if (value == null) {
            synchronized(this.name) {
                value = this.name.get();
                if (value == null) {
                    String actualValue = "Tom";
                    value = "Tom" == null ? this.name : "Tom";
                    this.name.set(value);
                }
            }
        }

        return (String)((String)(value == this.name ? null : value));
    }

    /** @deprecated */
    @Deprecated
    public String getGender() {
        return this.gender;
    }
}
```

> **说明**：我们在"name"属性上使用`lazy = true`时，可以发现生成的getName()方法中使用了双检锁，所以lombok也为我们解决了线程安全问题。

#### 2.4 @EqualsAndHashCode注解

##### 2.4.1 注解的作用

该注解主要作用于类上，使用该注解会默认生成`equals`、`canEqual`以及`hashCode`三个方法。

##### 2.4.2 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.EqualsAndHashCode;

@EqualsAndHashCode
public class Person {
    private Integer id;
    private String name;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

public class Person {
    private Integer id;
    private String name;

    public Person() {
    }

    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (!(o instanceof Person)) {
            return false;
        } else {
            Person other = (Person)o;
            if (!other.canEqual(this)) {
                return false;
            } else {
                Object this$id = this.id;
                Object other$id = other.id;
                if (this$id == null) {
                    if (other$id != null) {
                        return false;
                    }
                } else if (!this$id.equals(other$id)) {
                    return false;
                }

                Object this$name = this.name;
                Object other$name = other.name;
                if (this$name == null) {
                    if (other$name != null) {
                        return false;
                    }
                } else if (!this$name.equals(other$name)) {
                    return false;
                }

                return true;
            }
        }
    }

    protected boolean canEqual(Object other) {
        return other instanceof Person;
    }

    public int hashCode() {
        int PRIME = true;
        int result = 1;
        Object $id = this.id;
        int result = result * 59 + ($id == null ? 43 : $id.hashCode());
        Object $name = this.name;
        result = result * 59 + ($name == null ? 43 : $name.hashCode());
        return result;
    }
}
```

#### 2.5 @ToString注解

##### 2.5.1 注解的作用

作用于类上，可以覆盖默认的toString()方法，输出格式如下所示：

```java
ClassName(fieldName=fieleValue, fieldName2=fieleValue2)
```

##### 2.5.2 注解属性详解

该注解的几个常用属性如下：

- `includeFieldNames`：在打印时是否包括字段的名称，默认为true；
- `callSuper`：是否将父类toString的输出包含到输出结果中(先调用)，默认为false；
- `doNotUseGetters`：是否要不通过调用getter方法获取属性值，默认为false，表示使用getter方法获取属性值；
- `onlyExplicitlyIncluded`：打印结果仅包含显式标记为@ToString.Include的字段和方法，默认为false，当该属性值为true时，则必须搭配@ToString.Include注解使用，否则不打印任何字段；
- ==Include==：这是@ToString注解里面的一个注解，只有在`onlyExplicitlyIncluded=true`时，使用该注解才能生效，使用方式是`@ToString.Include`，如果该注解标注在方法上，则方法的返回值也会被包含到toString()方法的输出结果中，该注解有如下两个属性：
  - `name`：可以使用该属性设置打印结果中字段的名称；
  - `rank`：该属性用于设置字段在打印结果中的优先级，默认是0，值越大优先级越高，就越排在前面。
- ==Exclude==：这也是@ToString注解里面的一个注解，使用该注解标注的字段，不会出现在打印结果中。

##### 2.5.3 代码演示

单纯地使用`@ToString`注解的话，源代码如下：

```java
package com.gongsl.lombok.pojo;

import lombok.Getter;
import lombok.ToString;

@Getter
@ToString
public class Person {
    private Integer id;
    private String name;
    private String gender;
}
```

编译后生成的代码如下：

```java
package com.gongsl.lombok.pojo;

public class Person {
    private Integer id;
    private String name;
    private String gender;

    public Person() {
    }

    public Integer getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public String getGender() {
        return this.gender;
    }

    public String toString() {
        return "Person(id=" + this.getId() + ", name=" + this.getName() + ", gender=" + this.getGender() + ")";
    }
}
```

如果将上面的`@ToString`改成`@ToString(includeFieldNames = false)`的话，生成的toString()就是下面这样：

```java
public String toString() {
    return "Person(" + this.getId() + ", " + this.getName() + ", " + this.getGender() + ")";
}
```

> **说明**：可以发现，打印的结果中，去掉了字段的名称，只包含了字段的值。

如果将上面的`@ToString`改为`@ToString(doNotUseGetters = true)`的话，生成的toString()就是下面这样：

```java
public String toString() {
    return "Person(id=" + this.id + ", name=" + this.name + ", gender=" + this.gender + ")";
}
```

> **说明**：可以发现，打印结果中字段的值不是通过getter方法获取的了，而是直接取的对应成员变量的值。

下面演示`callSuper`属性的效果，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.Getter;
import lombok.ToString;

@Getter
@ToString
public class Father {
    private String resultCode;
    private String resultValue;
}
```

```java
package com.gongsl.lombok.pojo;

import lombok.Getter;
import lombok.ToString;

@Getter
@ToString(callSuper = true)
public class Person extends Father {
    private Integer id;
    private String name;
    private String gender;
}
```

编译后Person类的内容如下所示：

```java
package com.gongsl.lombok.pojo;

public class Person extends Father {
    private Integer id;
    private String name;
    private String gender;

    public Person() {
    }

    public Integer getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public String getGender() {
        return this.gender;
    }

    public String toString() {
        return "Person(super=" + super.toString() + ", id=" + this.getId() + ", name=" + this.getName() + ", gender=" + this.getGender() + ")";
    }
}
```

如果Person类不是使用的`@ToString(callSuper = true)`，而是使用`@ToString`的话，生成的toString()方法就是下面这样：

```java
public String toString() {
    return "Person(id=" + this.getId() + ", name=" + this.getName() + ", gender=" + this.getGender() + ")";
}
```

> **说明**：可以发现，直接使用`@ToString`注解的话，toString()方法中并不会打印父类toString()方法的内容。

下面再来演示一下`@ToString.Include`注解的用法，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.Getter;
import lombok.ToString;

@Getter
@ToString(onlyExplicitlyIncluded = true)
public class Person {
    private Integer id;
    @ToString.Include
    private String name;
    @ToString.Include(name = "sex", rank = 2)
    private String gender;
}
```

编译后生成的toString()方法内容如下所示：

```java
public String toString() {
    return "Person(sex=" + this.getGender() + ", name=" + this.getName() + ")";
}
```

**结果说明**：

- 由于只有在`onlyExplicitlyIncluded=true`时`@ToString.Include`注解才能生效，它们要结合在一起使用，所以这里就设置onlyExplicitlyIncluded=true了；
- 由编译后的toString()方法可知，没有使用`@ToString.Include`注解标注的id字段，并没有出现在toString()方法的打印结果中；
- 使用`@ToString.Include`注解的`name`属性可以设置字段在打印结果中的名称，所以在toString()方法中gender字段的名称就变成了sex，而不是gender；
- 使用`@ToString.Include`注解的`rank`属性可以设置字段在打印结果中的优先级，由于默认值是0，而gender字段设置为了2，数字比别的字段都大，所以gender字段就排在了打印结果的最前面。

最后演示下`@ToString.Exclude`注解的用法，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.Getter;
import lombok.ToString;

@Getter
@ToString
public class Person {
    private Integer id;
    @ToString.Exclude
    private String name;
    private String gender;
}
```

编译后生成的toString()方法内容如下所示：

```java
public String toString() {
    return "Person(id=" + this.getId() + ", gender=" + this.getGender() + ")";
}
```

> **说明**：由于name字段使用`@ToString.Exclude`注解进行了标注，所以该字段就没有出现在toString()方法的打印结果中。

#### 2.6 @RequiredArgsConstructor注解

##### 2.6.1 注解的作用

作用于类上，用于生成包含final修饰符和@NonNull注解的成员变量的构造方法。

##### 2.6.2 注解属性详解

该注解的三个常用属性如下：

- `staticName`：使生成的构造方法私有化，并且生成一个返回值类型为当前对象的静态方法，该方法的入参是final和@NonNull注解修饰的变量。如果类中没有final或@NonNull注解修饰的变量，则直接私有化无参构造方法，并生成一个返回值类型为当前对象的无参静态方法；
- `onConstructor`：该属性的属性值是注解，属性值的所有注解都会被放在生成的构造方法上，java8之后使用该属性需要在属性后加下划线，即"onConstructor_={@注解名}"；
- `access`：设置构造方法的访问修饰符，如果同时使用了`staticName`属性，那么将设置该属性生成的静态方法的访问修饰符。如果使用==access = AccessLevel.NONE==，那么将不会生成包含final修饰符和@NonNull注解的成员变量的构造方法，即便使用了`staticName`属性，也不会生成相应的静态方法，即停用注解功能。

##### 2.6.3 代码演示

如果类中没有final或@NonNull注解修饰的变量，那么使用`@RequiredArgsConstructor`注解是没有任何效果的，比如下面这样：

```java
package com.gongsl.lombok.pojo;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class Person {
    private Integer id;
    private String name;
    private String gender;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

public class Person {
    private Integer id;
    private String name;
    private String gender;

    public Person() {
    }
}
```

为了看到效果，现将源代码修改为如下内容：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;
}
```

再次编译后，生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;

public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;

    public Person(String name, @NonNull String gender) {
        if (gender == null) {
            throw new NullPointerException("gender is marked non-null but is null");
        } else {
            this.name = name;
            this.gender = gender;
        }
    }
}
```

下面演示一下`staticName`属性的效果，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor(staticName = "of")
public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;
}
```

编译后生成的代码内容如下：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;

public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;

    private Person(String name, @NonNull String gender) {
        if (gender == null) {
            throw new NullPointerException("gender is marked non-null but is null");
        } else {
            this.name = name;
            this.gender = gender;
        }
    }

    public static Person of(String name, @NonNull String gender) {
        return new Person(name, gender);
    }
}
```

> **说明**：可以发现，构造方法已经被私有化了，而且根据我们指定的方法名生成了一个对应的静态方法。

下面再演示一下`onConstructor`属性，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor(onConstructor_ = {@Deprecated})
public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;
}
```

编译后生成的代码内容如下：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;

public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;

    /** @deprecated */
    @Deprecated
    public Person(String name, @NonNull String gender) {
        if (gender == null) {
            throw new NullPointerException("gender is marked non-null but is null");
        } else {
            this.name = name;
            this.gender = gender;
        }
    }
}
```

最后演示一些`access`属性，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AccessLevel;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor(access = AccessLevel.PROTECTED)
public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;
}
```

编译后生成的代码内容如下：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;

public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;

    protected Person(String name, @NonNull String gender) {
        if (gender == null) {
            throw new NullPointerException("gender is marked non-null but is null");
        } else {
            this.name = name;
            this.gender = gender;
        }
    }
}
```

> **说明**：可以发现，构造方法的访问修饰符已经变成了protected。

如果我们搭配`staticName`属性一起使用的话，修改的就是生成的静态方法的访问修饰符了，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AccessLevel;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor(staticName = "of", access = AccessLevel.PROTECTED)
public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;
}
```

编译后生成的代码内容如下：

```java
package com.gongsl.lombok.pojo;

import lombok.NonNull;

public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;

    private Person(String name, @NonNull String gender) {
        if (gender == null) {
            throw new NullPointerException("gender is marked non-null but is null");
        } else {
            this.name = name;
            this.gender = gender;
        }
    }

    protected static Person of(String name, @NonNull String gender) {
        return new Person(name, gender);
    }
}
```

#### 2.7 @Data注解

##### 2.7.1 注解的作用

该注解作用于类上，`@Data`注解包含以下注解，是以下注解的集合：

```java
@Setter
@Getter
@ToString
@EqualsAndHashCode
@RequiredArgsConstructor
```

##### 2.7.2 注解属性详解

该注解的属性如下：

- `staticConstructor`：使生成的构造方法私有化，并且生成一个返回值类型为当前对象的静态方法，该方法的入参是final和@NonNull注解修饰的变量。如果类中没有final或@NonNull注解修饰的变量的话，则直接私有化无参构造方法，并生成一个返回值类型为当前对象的无参静态方法。

##### 2.7.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.Data;
import lombok.NonNull;

@Data(staticConstructor = "of")
public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;
}
```

编译后生成的代码内容如下所示：

```java
 com.gongsl.lombok.pojo;

import lombok.NonNull;

public class Person {
    private Integer id;
    private final String name;
    @NonNull
    private String gender;

    private Person(String name, @NonNull String gender) {
        if (gender == null) {
            throw new NullPointerException("gender is marked non-null but is null");
        } else {
            this.name = name;
            this.gender = gender;
        }
    }

    public static Person of(String name, @NonNull String gender) {
        return new Person(name, gender);
    }

    public Integer getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    @NonNull
    public String getGender() {
        return this.gender;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public void setGender(@NonNull String gender) {
        if (gender == null) {
            throw new NullPointerException("gender is marked non-null but is null");
        } else {
            this.gender = gender;
        }
    }

    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (!(o instanceof Person)) {
            return false;
        } else {
            Person other = (Person)o;
            if (!other.canEqual(this)) {
                return false;
            } else {
                label47: {
                    Object this$id = this.getId();
                    Object other$id = other.getId();
                    if (this$id == null) {
                        if (other$id == null) {
                            break label47;
                        }
                    } else if (this$id.equals(other$id)) {
                        break label47;
                    }

                    return false;
                }

                Object this$name = this.getName();
                Object other$name = other.getName();
                if (this$name == null) {
                    if (other$name != null) {
                        return false;
                    }
                } else if (!this$name.equals(other$name)) {
                    return false;
                }

                Object this$gender = this.getGender();
                Object other$gender = other.getGender();
                if (this$gender == null) {
                    if (other$gender != null) {
                        return false;
                    }
                } else if (!this$gender.equals(other$gender)) {
                    return false;
                }

                return true;
            }
        }
    }

    protected boolean canEqual(Object other) {
        return other instanceof Person;
    }

    public int hashCode() {
        int PRIME = true;
        int result = 1;
        Object $id = this.getId();
        int result = result * 59 + ($id == null ? 43 : $id.hashCode());
        Object $name = this.getName();
        result = result * 59 + ($name == null ? 43 : $name.hashCode());
        Object $gender = this.getGender();
        result = result * 59 + ($gender == null ? 43 : $gender.hashCode());
        return result;
    }

    public String toString() {
        return "Person(id=" + this.getId() + ", name=" + this.getName() + ", gender=" + this.getGender() + ")";
    }
}
```

#### 2.8 @NoArgsConstructor注解

##### 2.8.1 注解的作用

作用于类上，用于生成一个无参构造方法。

##### 2.8.2 注解属性详解

该注解的几个常用属性如下：

- `staticName`：用于生成一个无参的返回类型为当前对象的静态方法，staticName属性值即为静态方法名；
- `onConstructor`：该属性的属性值是注解，属性值的所有注解都会被放在生成的构造方法上，java8之后使用该属性需要在属性后加下划线，即"onConstructor_={@注解名}"；
- `access`：设置构造方法的访问修饰符，如果同时使用了`staticName`属性，那么将设置该属性生成的静态方法的访问修饰符。如果使用==access = AccessLevel.NONE==，即表示停用注解功能。就算使用了`staticName`属性，也不会生成相应的静态方法；
- `force`：默认值为false，值为true的话，可以将所有final修饰的字段初始化为0、null、false。

##### 2.8.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(
        staticName = "newInstance",
        onConstructor_ = {@Deprecated},
        access = AccessLevel.PROTECTED,
        force = true
)
public class Person {
    private Integer id;
    private String name;
    private final String gender;
    private final int age;
    private final boolean flag;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

public class Person {
    private Integer id;
    private String name;
    private final String gender = null;
    private final int age = 0;
    private final boolean flag = false;

    /** @deprecated */
    @Deprecated
    private Person() {
    }

    protected static Person newInstance() {
        return new Person();
    }
}
```

#### 2.9 @AllArgsConstructor注解

##### 2.9.1 注解的作用

作用于类上，用于生成一个参数为所有实例变量的构造方法。

##### 2.9.2 注解属性详解

该注解的三个常用属性如下：

- `staticName`：用于生成一个参数为所有实例变量的返回类型为当前对象的静态方法，staticName属性值即为静态方法名；
- `onConstructor`：该属性的属性值是注解，属性值的所有注解都会被放在生成的构造方法上，java8之后使用该属性需要在属性后加下划线，即"onConstructor_={@注解名}"；
- `access`：设置构造方法的访问修饰符，如果同时使用了`staticName`属性，那么将设置该属性生成的静态方法的访问修饰符。如果使用==access = AccessLevel.NONE==，即表示停用注解功能。就算使用了`staticName`属性，也不会生成相应的静态方法。

##### 2.9.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;

@AllArgsConstructor(
        staticName = "newInstance",
        onConstructor_ = {@Deprecated},
        access = AccessLevel.PROTECTED
)
public class Person {
    private Integer id;
    private String name;
    private String gender;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

public class Person {
    private Integer id;
    private String name;
    private String gender;

    /** @deprecated */
    @Deprecated
    private Person(Integer id, String name, String gender) {
        this.id = id;
        this.name = name;
        this.gender = gender;
    }

    protected static Person newInstance(Integer id, String name, String gender) {
        return new Person(id, name, gender);
    }
}
```

#### 2.10 @Accessors注解

##### 2.10.1 注解的作用

可以使用该注解实现链式调用，前提是使用该注解的类的属性字段要有对应的setter和getter方法。

##### 2.10.2 注解属性详解

该注解的三个常用属性如下：

- `fluent`：设置为true时，setter和getter方法名即为字段名，默认我false；
- `chain`：设置为true时，可以链式调用，即setter方法返回this，默认为false；
- `prefix`：指定前缀，生成的setter和getter方法会去掉指定的前缀(需要遵守驼峰命名)。

##### 2.10.3 代码演示

使用`@Accessors`注解的实体类如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.Data;
import lombok.experimental.Accessors;

@Data
@Accessors(chain = true)
public class Person {
    private Integer id;
    private String name;
    private String gender;
}
```

测试类如下所示：

```java
package com.gongsl.lombok.test;

import com.gongsl.lombok.pojo.Person;

public class PojoTest {
    public static void main(String[] args) {
        //下面这种方式就是链式调用
        Person person = new Person().setId(2).setName("Tom").setGender("男");
        System.out.println(person);
    }
}
```

测试类运行结果如下：

```java
Person(id=2, name=Tom, gender=男)
```

> <font color="red">注意事项：</font>我看网上很多人都说`@Accessors`注解有不少坑，比如使用该注解后序列化和反序列化有问题呀，

##### 2.10.4 注意事项

1. 网上很多人有提到说`@Accessors`注解有不少坑，比如使用<font color="aquamarine blue">@Accessors(fluent = true)</font>后会对序列化和反序列化有影响；
2. 也有人说如果使用<font color="aquamarine blue">@Accessors(chain = true)</font>的话，在使用EasyExcel时会有问题。因为EasyExcel里面使用了`net.sf.cglib.beans.BeanMap`工具类进行属性拷贝，而开启链式调用后，setter方法返回的不是void了，所以会导致属性拷贝失败，具体可以看[博客](https://blog.csdn.net/qq_28036249/article/details/108035369)上面的详细介绍；
3. 还有人说开启链式调用后，在使用`org.springframework.cglib.beans.BeanMap`时也会有问题，详情可以参考对应[博客](https://blog.csdn.net/javaloverkehui/article/details/121950500)；
4. 还是属性拷贝的问题，有的说开启链式调用后，会导致有些工具类中的BeanUtils.copyProperties失效。

别的坑我都还没试过，关于属性拷贝这一条，我实践了一下，常用的几个工具类中的属性拷贝都是没问题的，我这边实践的实体类如下所示：

```java
package com.gongsl.pojo.dto;

import com.gongsl.pojo.*;
import lombok.Data;
import lombok.experimental.Accessors;
import java.io.Serializable;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Data
@Accessors(chain = true)
public class OrigDTO extends Father implements Serializable {
    private int id;
    private Integer cardId;
    private String name;
    private boolean flag;
    private Boolean initFlag;
    private Extend extend;
    private String[] strArr;
    private ExtendInfo[] extendInfos;
    private Set<String> strSet;
    private List<String> strList;
    private List<Other> otherList;
    private Map<String, String> strMap;
    private Map<String, Default> otherMap;
}
```

实践用到的工具类如下所示：

```java
org.mapstruct.Mapper
org.dozer.DozerBeanMapper
org.springframework.beans.BeanUtils#copyProperties
org.apache.commons.beanutils.BeanUtils#copyProperties
cn.hutool.core.bean.BeanUtil#toBean
```

> **说明**：以上五个工具类我都试过了，对于OrigDTO实体类中多种多样的属性，都能拷贝成功。但是`@Accessors`注解毕竟还是有可能存在别的坑，所以还是需要谨慎使用。

#### 2.11 @Builder注解

##### 2.11.1 注解的作用

作用于类上，将其变成建造者模式，可以以链的形式调用。

##### 2.11.2 注解属性详解

该注解的几个常用属性如下：

- ==Default==：这是@Builder注解里面的一个注解，我们在使用@Builder注解后，会导致非final修饰的字段的默认值失效，解决办法就是使用这个注解，用法是`@Builder.Default`；
- `builderMethodName`：指定创建内部静态类的方法名，默认值为"builder"；
- `buildMethodName`：指定创建实体类的方法名，默认值为"build"；
- `builderClassName`：指定创建的内部静态类的类名，默认创建的类名为当前类名后面拼个Builder，比如我们使用注解的类是Person类，那这个内部静态类的类名就是PersonBuilder；
- `toBuilder`：默认值为false，设置为true的话，会生成一个toBuilder方法，然后我们可以通过这个方法对实体类的属性值进行链式修改；
- `access`：用于设置生成的builder类和builder方法的权限修饰符，默认是public；
- `setterPrefix`：使用@Builder注解后，默认会生成一个内部静态类，静态类中会有给每个字段设置值的方法，方法名默认就是字段名，使用该属性就是给这些方法名设置前缀的；
- ==ObtainVia==：这是@Builder注解里面的一个注解，表示变量从什么地方获取值，只有当设置`toBuilder = true`时该注解才生效。该注解中还有如下三个属性：
  - `field`：表示字段赋值时从某个字段上取值，对应的字段必须存在，两个字段的类型必须一致；
  - `method`：表示字段赋值时从某个方法上取值，对应的方法必须存在，方法返回值类型必须和字段类型一致；
  - `isStatic`：搭配`method`属性，默认值为false，设置为true表示从某个静态方法的返回值取值，静态方法入参为当前对象。

##### 2.11.3 代码演示

在实际开发时，我们一般都会用到`@Data`注解，如果此时再使用`@Builder`注解的话，会导致无参构造方法丢失，而如果手动添加无参数构造方法或者使用`@NoArgsConstructor`注解却都会报错。所以如果我们希望保留无参构造方法的话，那么当`@Data`注解和`@Builder`注解同时出现时，需要将`@NoArgsConstructor`注解和`@AllArgsConstructor`注解都加上才可以，如下所示：

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    ......
}
```

###### 2.11.3.1 演示不使用属性的场景

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    private String gender;
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

public class Person {
    private Integer id;
    private String name;
    private String gender;

    public static Person.PersonBuilder builder() {
        return new Person.PersonBuilder();
    }

    public Integer getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public String getGender() {
        return this.gender;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (!(o instanceof Person)) {
            return false;
        } else {
            Person other = (Person)o;
            if (!other.canEqual(this)) {
                return false;
            } else {
                label47: {
                    Object this$id = this.getId();
                    Object other$id = other.getId();
                    if (this$id == null) {
                        if (other$id == null) {
                            break label47;
                        }
                    } else if (this$id.equals(other$id)) {
                        break label47;
                    }

                    return false;
                }

                Object this$name = this.getName();
                Object other$name = other.getName();
                if (this$name == null) {
                    if (other$name != null) {
                        return false;
                    }
                } else if (!this$name.equals(other$name)) {
                    return false;
                }

                Object this$gender = this.getGender();
                Object other$gender = other.getGender();
                if (this$gender == null) {
                    if (other$gender != null) {
                        return false;
                    }
                } else if (!this$gender.equals(other$gender)) {
                    return false;
                }

                return true;
            }
        }
    }

    protected boolean canEqual(Object other) {
        return other instanceof Person;
    }

    public int hashCode() {
        int PRIME = true;
        int result = 1;
        Object $id = this.getId();
        int result = result * 59 + ($id == null ? 43 : $id.hashCode());
        Object $name = this.getName();
        result = result * 59 + ($name == null ? 43 : $name.hashCode());
        Object $gender = this.getGender();
        result = result * 59 + ($gender == null ? 43 : $gender.hashCode());
        return result;
    }

    public String toString() {
        return "Person(id=" + this.getId() + ", name=" + this.getName() + ", gender=" + this.getGender() + ")";
    }

    public Person() {
    }

    public Person(Integer id, String name, String gender) {
        this.id = id;
        this.name = name;
        this.gender = gender;
    }

    public static class PersonBuilder {
        private Integer id;
        private String name;
        private String gender;

        PersonBuilder() {
        }

        public Person.PersonBuilder id(Integer id) {
            this.id = id;
            return this;
        }

        public Person.PersonBuilder name(String name) {
            this.name = name;
            return this;
        }

        public Person.PersonBuilder gender(String gender) {
            this.gender = gender;
            return this;
        }

        public Person build() {
            return new Person(this.id, this.name, this.gender);
        }

        public String toString() {
            return "Person.PersonBuilder(id=" + this.id + ", name=" + this.name + ", gender=" + this.gender + ")";
        }
    }
}
```

测试类的内容如下所示：

```java
package com.gongsl.lombok.test;

import com.gongsl.lombok.pojo.Person;

public class PojoTest {
    public static void main(String[] args) {
        //下面这种方式就是通过@Builder注解实现的链式调用
        Person person = Person.builder().id(2).name("Tom").gender("男").build();
        System.out.println(person);
    }
}
```

运行结果如下所示：

```java
Person(id=2, name=Tom, gender=男)
```

###### 2.11.3.2 演示@Builder.Default的用法

假设我们给实体类中某个字段设置个默认值，比如gender字段，如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    private String gender = "男";
}
```

而我们在测试类中不再给这个字段设置值，直接输出的话，会发现之前设置的默认值失效了，如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        Person person = Person.builder().id(2).name("Tom").build();
        System.out.println(person);//输出结果：Person(id=2, name=Tom, gender=null)
    }
}
```

对于给非final修饰的字段设置默认值的时候，必须使用`@Builder.Default`注解修饰才行，如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    @Builder.Default
    private String gender = "男";
}
```

测试类的内容不变，输出结果中，就会输出默认值的内容了，如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        Person person = Person.builder().id(2).name("Tom").build();
        System.out.println(person);//输出结果：Person(id=2, name=Tom, gender=男)
    }
}
```

###### 2.11.3.3 演示toBuilder属性

源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder(toBuilder = true)
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    private String gender;
}
```

使用`toBuilder = true`后，编译后的代码中就会多一个toBuilder()方法，如下所示：

![image-20220605135921787](D:\Program Files (x86)\Typora\images\3.Lombok常见注解的用法\image-20220605135921787.png) 

我们可以使用toBuilder()方法对已经设置过属性值的实体类的属性再进行修改，如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        //使用链式调用设置属性值
        Person person = Person.builder().id(2).name("Tom").build();
        System.out.println(person);
        //使用toBuilder()方法修改实体类的属性值
        person = person.toBuilder().name("Jerry").gender("男").build();
        System.out.println(person);
    }
}
```

运行结果如下所示：

```java
Person(id=2, name=Tom, gender=null)
Person(id=2, name=Jerry, gender=男)
```

###### 2.11.3.4 演示setterPrefix属性

源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder(setterPrefix = "with")
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    private String gender;
}
```

测试类的内容如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        //我们使用链式调用给属性设置属性值时，调用的方法名前面都加了一个"with"，并且方法名还是驼峰命名
        Person person = Person.builder().withId(2).withName("Tom").withGender("男").build();
        System.out.println(person);//输出结果：Person(id=2, name=Tom, gender=男)
    }
}
```

###### 2.11.3.5 演示@Builder.ObtainVia的用法

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder(toBuilder = true)
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    private String gender;
    //表示identity字段将从name字段取值
    @Builder.ObtainVia(field = "name")
    private String identity;
    //表示testOne字段将从init()方法的返回值取值
    @Builder.ObtainVia(method = "init")
    private String testOne;
    //表示testTwo字段将从test(Person person)方法的返回值取值，该方法必须是静态的，且入参是当前对象
    @Builder.ObtainVia(method = "test", isStatic = true)
    private String testTwo;

    public String init(){
        return "初始化";
    }

    public static String test(Person person){
        return person.getName() + "猫";
    }
}
```

测试类的内容如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        Person person = Person.builder().id(2).name("Tom").gender("男").build();
        System.out.println(person);
        person = person.toBuilder().build();
        System.out.println(person);
    }
}
```

运行结果如下所示：

```java
Person(id=2, name=Tom, identity=null, gender=男, testOne=null, testTwo=null)
Person(id=2, name=Tom, identity=Tom, gender=男, testOne=初始化, testTwo=Tom猫)
```

> **注意**：只有当设置`toBuilder = true`时，使用==@Builder.ObtainVia==注解才生效。

###### 2.11.3.6 指定泛型构建

我们在平时开发中经常会用到泛型，而`@Builder`也是支持指定泛型构建的，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Person<T> {
    private Integer id;
    private String name;
    private String gender;
    private T identity;
}
```

测试类的内容如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        //链式调用时可指定泛型
        Person person = Person.<String>builder().id(2).name("Tom").gender("男").build();
        System.out.println(person);//输出结果：Person(id=2, name=Tom, gender=男)
    }
}
```

###### 2.11.3.7 搭配@Singular注解使用

在平时开发时，实体类中的属性经常会存在集合形式，这时搭配`@Singular`注解使用就会更简单，源代码如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.*;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    @Singular
    private List<String> nameLists;
    //如果字段名不是复数形式，使用@Singular注解时，必须设置value属性值
    @Singular(value = "addAge")
    private List<Integer> ageList;
}
```

测试类的内容如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        Person person = Person.builder().id(2).name("Tom")
                .nameList("小王").nameList("小明")
                .addAge(20).addAge(25)
                .build();
        System.out.println(person);
    }
}
```

运行结果如下所示：

```java
Person(id=2, name=Tom, nameLists=[小王, 小明], ageList=[20, 25, 30])
```

通过以上测试类中的代码可知，搭配`@Singular`注解后，对于集合属性，我们可以直接使用nameList方法和addAge方法向集合中添加元素。这两个方法其实都是自动生成的，生成的代码中这两个方法的内容如下：

```java
public Person.PersonBuilder nameList(String nameList) {
    if (this.nameLists == null) {
        this.nameLists = new ArrayList();
    }

    this.nameLists.add(nameList);
    return this;
}

public Person.PersonBuilder addAge(Integer addAge) {
    if (this.ageList == null) {
        this.ageList = new ArrayList();
    }

    this.ageList.add(addAge);
    return this;
}
```

#### 2.12 @SuperBuilder注解

##### 2.12.1 注解的作用

单纯使用@Builder注解的话，我们在进行链式调用时，是无法给父类的属性设置值的，而@SuperBuilder注解就是为了解决这一问题的，使用@SuperBuilder注解时，要求父类也要使用@SuperBuilder注解才行，不然还是无法给父类的属性设置值。

##### 2.12.2 注解属性详解

该注解的几个常用属性如下：

- `builderMethodName`：指定创建内部静态类的方法名，默认值为"builder"；
- `buildMethodName`：指定创建实体类的方法名，默认值为"build"；
- `toBuilder`：默认值为false，设置为true的话，会生成一个toBuilder方法，然后我们可以通过这个方法对实体类的属性值进行链式修改；
- `setterPrefix`：使用注解时，默认会生成一个内部静态类，静态类中会有给每个字段设置值的方法，方法名默认就是字段名，使用该属性就是给这些方法名设置前缀的。

##### 2.12.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@NoArgsConstructor
@AllArgsConstructor
public class Father {
    private String resultCode;
    private String resultValue;
}
```

```java
package com.gongsl.lombok.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@NoArgsConstructor
@AllArgsConstructor
@ToString(callSuper = true)
public class Person extends Father {
    private Integer id;
    private String name;
}
```

测试类中的内容如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        //resultCode就是父类中的属性
        Person person = Person.builder().id(2).name("Tom").resultCode("code").build();
        System.out.println(person);
    }
}
```

运行结果如下所示：

```java
Person(super=Father(resultCode=code, resultValue=null), id=2, name=Tom)
```

> **说明**：由运行结果可知，使用`@SuperBuilder`注解后，确实可以成功给父类的字段设置值了。

#### 2.13 @Singular注解

##### 2.13.1 注解的作用

作用于集合字段，需要配合`@Builder`注解进行使用。使用该注解标注集合字段后，默认会生成向集合中添加元素的方法。

##### 2.13.2 注解属性详解

该注解的两个属性如下：

- `value`：如果指定了该属性，那么向集合中添加单个元素的方法名即为该属性的属性值，如果不指定该属性，那么集合字段名需要是复数形式；
- `ignoreNullCollections`：默认值是false，设置为true的话表示生成的代码中，不会再对该注解标注的集合字段进行空指针校验。

##### 2.13.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.pojo;

import lombok.*;
import java.util.List;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private Integer id;
    private String name;
    @Singular(ignoreNullCollections = true)
    private List<Integer> ageLists;
    @Singular(value = "putTest")
    private Map<String, Object> testMap;
}
```

测试类中的内容如下所示：

```java
public class PojoTest {
    public static void main(String[] args) {
        Person person = Person.builder().id(2).name("Tom")
                .putTest("name","Jerry")
                .putTest("age",22)
                .ageList(10).ageList(15)
                .build();
        System.out.println(person);
    }
}
```

运行结果如下所示：

```java
Person(id=2, name=Tom, ageLists=[10, 15], testMap={name=Jerry, age=22})
```

#### 2.14 @Slf4j注解

##### 2.14.1 注解的作用

作用于类上，生成对应的log对象，用于记录日志的。类似的日志注解还有很多，主要是`@Slf4j`最常用，所以这里只介绍这个注解，其他日志注解都是一样的用法，具体可参考[官网](https://projectlombok.org/features/log)相关说明。

##### 2.14.2 注解属性详解

该注解的属性如下：

- `topic`：该属性是用于设置getLogger(String name)方法参数的。

##### 2.14.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.test;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class PojoTest {
    public static void main(String[] args) {
        System.out.println("test...");
    }
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.test;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PojoTest {
    private static final Logger log = LoggerFactory.getLogger(PojoTest.class);

    public PojoTest() {
    }

    public static void main(String[] args) {
        System.out.println("test...");
    }
}
```

假设我们使用的是`@Slf4j(topic = "testName")`，那么最终编译后的内容就是下面这样：

```java
package com.gongsl.lombok.test;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PojoTest {
    private static final Logger log = LoggerFactory.getLogger("testName");

    public PojoTest() {
    }

    public static void main(String[] args) {
        System.out.println("test...");
    }
}
```

> **说明**：可以发现，使用topic属性后，`getLogger`方法的参数值就变成了topic属性的属性值。

#### 2.15 @SneakyThrows注解

##### 2.15.1 注解的作用

作用于方法上，主要作用是对异常进行捕获并抛出。

##### 2.15.2 注解属性详解

该注解的属性如下：

- `value`：用于指定注解针对哪种异常类型做处理，默认为java.lang.Throwable。

##### 2.15.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.test;

import lombok.SneakyThrows;
import java.sql.SQLException;

public class PojoTest {
    public static void main(String[] args) {
        System.out.println("test...");
    }

    @SneakyThrows
    public static void testA(int count) {
        if (count == 0) {
            throw new SQLException();
        } else if (count == 1) {
            throw new NoSuchMethodException();
        }
    }

    //这里的意思是，@SneakyThrows注解只处理NoSuchMethodException异常，所以这个异常不用我们手动处理
    @SneakyThrows(NoSuchMethodException.class)
    public static void testB(int count) throws SQLException {
        if (count == 0) {
            System.out.println("这里是业务逻辑...");
            throw new SQLException();
        } else if (count == 1) {
            System.out.println("这里也是业务逻辑...");
            throw new NoSuchMethodException();
        } else if (count == 2) {
            System.out.println("这里还是业务逻辑...");
            throw new NullPointerException();
        }
    }
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.test;

import java.sql.SQLException;

public class PojoTest {
    public PojoTest() {
    }

    public static void main(String[] args) {
        System.out.println("test...");
    }

    public static void testA(int count) {
        try {
            if (count == 0) {
                throw new SQLException();
            } else if (count == 1) {
                throw new NoSuchMethodException();
            }
        } catch (Throwable var2) {
            throw var2;
        }
    }

    public static void testB(int count) throws SQLException {
        try {
            if (count == 0) {
                System.out.println("这里是业务逻辑...");
                throw new SQLException();
            } else if (count == 1) {
                System.out.println("这里也是业务逻辑...");
                throw new NoSuchMethodException();
            } else if (count == 2) {
                System.out.println("这里还是业务逻辑...");
                //这个是非检查异常，可以不用手动捕获或抛出
                throw new NullPointerException();
            }
        } catch (NoSuchMethodException var2) {
            throw var2;
        }
    }
}
```

> **说明**：对于非RuntimeException及其子类的检查异常，编译器是要求我们必须去处理的，要么使用`throws`进行抛出，要么使用`try...catch`进行捕获。而使用==@SneakyThrows==注解后，对于检查异常，我们不必再手动处理，该注解会为我们自动捕获并抛出。当方法中可能会产生多个检查异常时，我们也可以使用该注解的value属性来设置需要该注解来帮我们处理的异常，对于没有使用该注解处理的检查异常，我们仍然需要手动捕获或抛出。

#### 2.16 @Synchronized注解

##### 2.16.1 注解的作用

作用于方法上，用于替换synchronized关键字。

##### 2.16.2 注解属性详解

该注解的属性如下：

- `value`：用于指定锁对象，当锁对象不存在时，则编译不通过。

##### 2.16.3 代码演示

源代码内容如下所示：

```java
package com.gongsl.lombok.test;

import lombok.Synchronized;

public class PojoTest {
    private final Object readLock = new Object();

    public static void main(String[] args) {
        System.out.println("test...");
    }

    @Synchronized
    public static void hello() {
        System.out.println("world");
    }

    @Synchronized
    public int answerToLife() {
        return 42;
    }

    @Synchronized("readLock")
    public void foo() {
        System.out.println("bar");
    }
}
```

编译后生成的代码内容如下所示：

```java
package com.gongsl.lombok.test;

public class PojoTest {
    private static final Object $LOCK = new Object[0];
    private final Object $lock = new Object[0];
    private final Object readLock = new Object();

    public PojoTest() {
    }

    public static void main(String[] args) {
        System.out.println("test...");
    }

    public static void hello() {
        synchronized($LOCK) {
            System.out.println("world");
        }
    }

    public int answerToLife() {
        synchronized(this.$lock) {
            return 42;
        }
    }

    public void foo() {
        synchronized(this.readLock) {
            System.out.println("bar");
        }
    }
}
```